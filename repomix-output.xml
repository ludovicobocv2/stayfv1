This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  alimentacao/
    page.tsx
  assistente-ia/
    page.tsx
  auth/
    cadastro/
      page.tsx
    callback/
      route.ts
    login/
      page.tsx
    layout.tsx
  autoconhecimento/
    page.tsx
  components/
    ai/
      AIAssistant.tsx
    alimentacao/
      LembreteHidratacao.tsx
      PlanejadorRefeicoes.tsx
      RegistroRefeicoes.tsx
    autoconhecimento/
      EditorNotas.tsx
      ListaNotas.tsx
      ModoRefugio.tsx
    estudos/
      RegistroEstudos.tsx
      TemporizadorPomodoro.tsx
    financas/
      AdicionarDespesa.tsx
      CalendarioPagamentos.tsx
      EnvelopesVirtuais.tsx
      RastreadorGastos.tsx
    hiperfocos/
      ConversorInteresses.tsx
      SistemaAlternancia.tsx
      TemporizadorFoco.tsx
      VisualizadorProjetos.tsx
    humor/
      MoodDataMigration.tsx
      MoodForm.tsx
      MoodRecordItem.tsx
      MoodRecordList.tsx
    inicio/
      ChecklistMedicamentos.tsx
      LembretePausas.tsx
      ListaPrioridades.tsx
      PainelDia.tsx
    layout/
      AuthControl.tsx
      Footer.tsx
      Header.tsx
      MainNav.tsx
      Sidebar.tsx
      ThemeToggle.tsx
      UserMenu.tsx
    lazer/
      AtividadesLazer.tsx
      SugestoesDescanso.tsx
      TemporizadorLazer.tsx
    perfil/
      DataMigration.tsx
      InformacoesPessoais.tsx
      MetasDiarias.tsx
      PreferenciasVisuais.tsx
    providers/
      supabase-provider.tsx
    saude/
      DataExportForm.tsx
      FatoresHumor.tsx
      HumorCalendar.tsx
      MedicamentosList.tsx
      MedicationDataMigration.tsx
      MedicationForm.tsx
      MedicationItem.tsx
      MedicationList.tsx
      MonitoramentoHumor.tsx
      RegistroMedicamentos.tsx
      StatCard.tsx
    sono/
      ConfiguracaoLembretes.tsx
      RegistroSono.tsx
      SleepDataMigration.tsx
      VisualizadorSemanal.tsx
    ui/
      Alert.tsx
      Badge.tsx
      Button.tsx
      Card.tsx
      Checkbox.tsx
      Container.tsx
      Input.tsx
      Label.tsx
      LoadingIndicator.tsx
      Modal.tsx
      Section.tsx
      Select.tsx
      Slider.tsx
      StatCard.tsx
      Tabs.tsx
      Textarea.tsx
      Toast.tsx
      Tooltip.tsx
    ErrorBoundary.jsx
    ExportarImportarDados.tsx
    SyncStatus.tsx
    SyncStatusNotification.js
    ThemeProvider.tsx
  context/
    AuthContext.tsx
    ToastContext.tsx
  dashboard/
    sono/
      page.tsx
  estudos/
    page.tsx
  financas/
    page.tsx
  hiperfocos/
    page.tsx
  hooks/
    useAuth.ts
    useBidirectionalSync.ts
    useDataSync.ts
    useFetch.js
    useHumor.ts
    useMedications.ts
    usePriorities.ts
    useSleep.ts
    useToast.ts
  lazer/
    page.tsx
  lib/
    services/
      api.js
    utils/
      apiClient.js
      errorHandler.js
      logger.js
      queryPerformance.js
    ai.ts
    contentSummarizer.ts
    dataService.ts
    README.md
    supabase.ts
    supabaseExport.ts
    testHelper.ts
    utils.ts
  perfil/
    ajuda/
      page.tsx
    page.tsx
  roadmap/
    page.tsx
  saude/
    exportar-dados/
      page.tsx
    page.tsx
  sono/
    page.tsx
  store/
    index.ts
    rootReducer.ts
    store.ts
  stores/
    alimentacaoStore.ts
    atividadesStore.ts
    autoconhecimentoStore.ts
    dataTransferStore.ts
    financasStore.ts
    hiperfocosStore.ts
    painelDiaStore.ts
    perfilStore.ts
    pomodoroStore.ts
    prioridadesStore.ts
    registroEstudosStore.ts
    sonoStore.ts
    store.ts
    sugestoesStore.ts
  test/
    auth/
      auth-test.tsx
      page.tsx
    supabase/
      page.tsx
    integration-test.tsx
    page.tsx
    supabase-connection-test.tsx
  types/
    index.ts
    supabase.ts
  config.ts
  globals.css
  layout.tsx
  page.tsx
  providers.tsx
cursor/
  rules/
    domain/
      backend.mdc
      frontend.mdc
    modes/
      architect.mdc
      ask.mdc
      code.mdc
      debug.mdc
      test.mdc
    patterns/
      architecture.mdc
      code_style.mdc
      testing.mdc
    tasks/
      debugging.mdc
      features.mdc
      refactoring.mdc
memory-bank/
  core/
    activeContext.md
    architecture.md
    productContext.md
    projectbrief.md
  navigation/
    changelog.md
    index.md
  specialized/
    codeDocMap.md
    hooks_supabase.md
    migracao_supabase.md
    test_strategy.md
    troubleshooting.md
  templates/
    document_template.md
  activeContext.md
  changelog.md
  code_mode.md
  debug_mode.md
  decisions.md
  index.md
  progress.md
  README.md
  techDebt.md
  test_mode.md
public/
  images/
    cat-icon.svg
    logo.svg
  sounds/
    alarm.mp3
    alarm.ogg
  favicon.svg
supabase/
  migrations/
    20240512000000_create_missing_tables.sql
.cursorrules
.env.production
.env.vercel
.eslintrc.json
.gitignore
app.json
deploy.sh
middleware.ts
next.config.js
package.json
postcss.config.js
README.md
tailwind.config.js
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/auth/layout.tsx">
import { Metadata } from 'next'
import { ReactNode } from 'react'

export const metadata: Metadata = {
  title: 'Login - StayFocus',
  description: 'Faça login na sua conta StayFocus'
}

export default function AuthLayout({ children }: { children: ReactNode }) {
  return <>{children}</>
}
</file>

<file path="cursor/rules/domain/backend.mdc">
/**
 * @description Regras e diretrizes para o domínio Backend no projeto StayFocus.
 * Este domínio é responsável pela lógica de negócios, persistência de dados e APIs.
 * @autoAttach {
 *   "patterns": ["**/backend/**/*", "**/*.py", "**/*.sql", "**/api/**/*"],
 *   "description": "Arquivos relacionados ao backend da aplicação"
 * }
 */

// Arquitetura Backend
const BACKEND_ARCHITECTURE = {
  framework: {
    core: "FastAPI",
    database: "PostgreSQL + TimescaleDB",
    orm: "SQLAlchemy",
    validation: "Pydantic"
  },
  structure: {
    api: [
      "/api/v1 - Endpoints da API",
      "/api/dependencies - Injeção de dependências",
      "/api/middleware - Middlewares da aplicação",
      "/api/utils - Utilitários da API"
    ],
    core: [
      "/core/config - Configurações",
      "/core/security - Segurança",
      "/core/events - Sistema de eventos",
      "/core/logging - Configuração de logs"
    ],
    models: [
      "/models - Modelos do banco de dados",
      "/schemas - Schemas Pydantic",
      "/repositories - Camada de acesso a dados",
      "/services - Lógica de negócios"
    ]
  }
};

// Padrões de Desenvolvimento
const DEVELOPMENT_PATTERNS = {
  api: {
    structure: [
      "Rotas em módulos separados",
      "Validação com Pydantic",
      "Documentação com OpenAPI",
      "Versionamento de API"
    ],
    endpoints: [
      "Nomenclatura RESTful",
      "Respostas padronizadas",
      "Tratamento de erros",
      "Rate limiting"
    ]
  },
  database: {
    models: [
      "Modelos SQLAlchemy",
      "Migrations com Alembic",
      "Índices otimizados",
      "Relacionamentos explícitos"
    ],
    queries: [
      "Queries otimizadas",
      "Uso de joins apropriados",
      "Paginação eficiente",
      "Cache quando necessário"
    ]
  }
};

// Padrões de Segurança
const SECURITY_PATTERNS = {
  authentication: {
    jwt: [
      "Tokens JWT",
      "Refresh tokens",
      "Expiração adequada",
      "Rotação de tokens"
    ],
    oauth: [
      "OAuth 2.0",
      "Provedores externos",
      "Fluxo seguro",
      "Validação de tokens"
    ]
  },
  authorization: {
    rbac: [
      "Controle baseado em roles",
      "Permissões granulares",
      "Middleware de autorização",
      "Auditoria de acessos"
    ],
    data: [
      "Filtragem por usuário",
      "Validação de ownership",
      "Sanitização de inputs",
      "Logs de acesso"
    ]
  }
};

// Padrões de Performance
const PERFORMANCE_PATTERNS = {
  database: {
    optimization: [
      "Índices apropriados",
      "Queries otimizadas",
      "Connection pooling",
      "Query caching"
    ],
    timescale: [
      "Hypertables para séries temporais",
      "Políticas de retenção",
      "Continuous aggregates",
      "Compressão de dados"
    ]
  },
  caching: {
    strategies: [
      "Cache em memória",
      "Cache distribuído",
      "Invalidação seletiva",
      "Cache warming"
    ],
    layers: [
      "Cache de aplicação",
      "Cache de banco de dados",
      "Cache de API",
      "Cache de consultas"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "README.md em cada módulo",
    "Documentação de API (OpenAPI)",
    "Modelos de dados",
    "Fluxos de autenticação"
  ],
  api: [
    "Descrição dos endpoints",
    "Parâmetros e tipos",
    "Exemplos de requests/responses",
    "Códigos de erro"
  ],
  database: [
    "Schema do banco",
    "Índices e constraints",
    "Políticas de backup",
    "Estratégias de migração"
  ]
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "techContext.md",
    "systemPatterns.md",
    "decisions.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Documentar mudanças em changelog.md",
    "Atualizar knowledgeGraph.md"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  code: [
    "Legibilidade",
    "Manutenibilidade",
    "Performance",
    "Testabilidade"
  ],
  api: [
    "Consistência",
    "Documentação",
    "Performance",
    "Segurança"
  ],
  data: [
    "Integridade",
    "Consistência",
    "Performance",
    "Backup/Recovery"
  ]
};
</file>

<file path="cursor/rules/domain/frontend.mdc">
/**
 * @description Regras e diretrizes para o domínio Frontend no projeto StayFocus.
 * Este domínio é responsável pela interface do usuário, experiência do usuário e interações client-side.
 * @autoAttach {
 *   "patterns": ["**/frontend/**/*", "**/*.tsx", "**/*.ts", "**/*.css", "**/*.scss"],
 *   "description": "Arquivos relacionados ao frontend da aplicação"
 * }
 */

// Arquitetura Frontend
const FRONTEND_ARCHITECTURE = {
  framework: {
    core: "Next.js",
    styling: ["Tailwind CSS", "Chakra UI"],
    stateManagement: "Zustand",
    routing: "Next.js Router"
  },
  structure: {
    components: [
      "/components/common - Componentes reutilizáveis",
      "/components/features - Componentes específicos de feature",
      "/components/layout - Componentes de layout",
      "/components/ui - Componentes de UI básicos"
    ],
    pages: [
      "/pages - Rotas e páginas",
      "/pages/api - API routes",
      "/pages/_app.tsx - Configuração global",
      "/pages/_document.tsx - Documento HTML base"
    ],
    styles: [
      "/styles/globals.css - Estilos globais",
      "/styles/themes - Temas da aplicação",
      "/styles/components - Estilos específicos"
    ]
  }
};

// Padrões de Desenvolvimento
const DEVELOPMENT_PATTERNS = {
  components: {
    structure: [
      "Componente em arquivo separado",
      "Tipos em arquivo .types.ts",
      "Hooks em arquivo .hooks.ts",
      "Testes em arquivo .test.ts"
    ],
    naming: {
      files: "PascalCase.tsx",
      components: "PascalCase",
      hooks: "useCamelCase",
      types: "IPascalCase"
    }
  },
  stateManagement: {
    stores: [
      "Separar por domínio",
      "Usar slices do Zustand",
      "Implementar persistência quando necessário",
      "Documentar shape do estado"
    ],
    updates: [
      "Ações imutáveis",
      "Evitar mutações diretas",
      "Usar seletores para performance",
      "Documentar side effects"
    ]
  }
};

// Padrões de UI/UX
const UI_UX_PATTERNS = {
  design: {
    colors: [
      "Usar tokens do tema",
      "Seguir paleta definida",
      "Manter consistência",
      "Considerar acessibilidade"
    ],
    layout: [
      "Layout responsivo",
      "Mobile-first",
      "Grid system",
      "Espaçamento consistente"
    ]
  },
  interaction: {
    feedback: [
      "Loading states",
      "Error handling",
      "Success feedback",
      "Animações suaves"
    ],
    accessibility: [
      "ARIA labels",
      "Keyboard navigation",
      "Screen reader support",
      "Color contrast"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "README.md em cada diretório",
    "Documentação de componentes",
    "Guia de estilos",
    "Documentação de APIs"
  ],
  components: [
    "Descrição do propósito",
    "Props e tipos",
    "Exemplos de uso",
    "Dependências"
  ],
  storybook: [
    "Stories para componentes",
    "Documentação interativa",
    "Variantes e estados",
    "Guias de uso"
  ]
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "techContext.md",
    "systemPatterns.md",
    "ui_ux_improvements.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Documentar mudanças em changelog.md",
    "Atualizar knowledgeGraph.md"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  code: [
    "Legibilidade",
    "Manutenibilidade",
    "Performance",
    "Reutilização"
  ],
  ui: [
    "Consistência",
    "Responsividade",
    "Acessibilidade",
    "Usabilidade"
  ],
  documentation: [
    "Clareza",
    "Completude",
    "Exemplos práticos",
    "Manutenção"
  ]
};
</file>

<file path="cursor/rules/modes/architect.mdc">
/**
 * @description Regras e diretrizes para o modo Arquiteto no projeto StayFocus.
 * Este modo é responsável pelo design do sistema, decisões de arquitetura e direção técnica.
 * @autoAttach {
 *   "patterns": ["**/architecture/**/*", "**/design/**/*", "**/*.arch.md"],
 *   "description": "Arquivos relacionados à arquitetura e design do sistema"
 * }
 */

// Responsabilidades Principais
const ARCHITECT_RESPONSIBILITIES = {
  systemDesign: [
    "Definição da arquitetura do sistema",
    "Escolha de padrões de design",
    "Modelagem de componentes",
    "Definição de interfaces"
  ],
  patternDecisions: [
    "Seleção de padrões arquiteturais",
    "Definição de padrões de comunicação",
    "Estabelecimento de padrões de código",
    "Padronização de interfaces"
  ],
  technicalDirection: [
    "Definição de roadmap técnico",
    "Avaliação de tecnologias",
    "Gestão de débito técnico",
    "Direcionamento de evolução do sistema"
  ]
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "systemPatterns.md",
    "decisions.md",
    "techDebt.md",
    "architecture.mdc"
  ],
  updates: [
    "Atualizar knowledgeGraph.md para mudanças arquiteturais",
    "Documentar decisões técnicas em decisions.md",
    "Manter systemPatterns.md atualizado",
    "Registrar débitos técnicos em techDebt.md"
  ]
};

// Padrões de Validação
const VALIDATION_PATTERNS = {
  architectural: [
    "Verificar consistência com padrões existentes",
    "Avaliar impacto em componentes existentes",
    "Validar escalabilidade da solução",
    "Confirmar viabilidade técnica"
  ],
  documentation: [
    "Garantir documentação atualizada",
    "Verificar referências cruzadas",
    "Validar diagramas arquiteturais",
    "Confirmar rastreabilidade de decisões"
  ]
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "systemPatterns.md",
    "decisions.md",
    "knowledgeGraph.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar mudanças em changelog.md",
    "Notificar stakeholders via communicationRegistry.md"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  design: [
    "Simplicidade e clareza",
    "Modularidade",
    "Extensibilidade",
    "Manutenibilidade"
  ],
  documentation: [
    "Completude",
    "Precisão",
    "Atualidade",
    "Rastreabilidade"
  ]
};
</file>

<file path="cursor/rules/modes/ask.mdc">
/**
 * @description Regras e diretrizes para o modo Ask no projeto StayFocus.
 * Este modo é responsável pela recuperação de informações, clarificação de contexto e busca na documentação.
 * @autoAttach {
 *   "patterns": ["**/*.md", "**/*.doc", "**/*.txt", "**/docs/**/*"],
 *   "description": "Arquivos de documentação e informação"
 * }
 */

// Responsabilidades Principais
const ASK_RESPONSIBILITIES = {
  informationRetrieval: [
    "Busca em documentação",
    "Consulta a código-fonte",
    "Acesso a decisões técnicas",
    "Recuperação de contexto"
  ],
  contextClarification: [
    "Esclarecimento de dúvidas",
    "Explicação de decisões",
    "Detalhamento de implementações",
    "Contextualização de mudanças"
  ],
  documentationSearch: [
    "Navegação em documentos",
    "Busca por palavras-chave",
    "Localização de referências",
    "Acesso a histórico"
  ]
};

// Padrões de Busca
const SEARCH_PATTERNS = {
  documentation: {
    priority: [
      "Memory Bank",
      "Código-fonte",
      "Comentários",
      "Histórico de mudanças"
    ],
    methods: [
      "Busca por palavra-chave",
      "Navegação hierárquica",
      "Referências cruzadas",
      "Tags semânticas"
    ]
  },
  context: {
    sources: [
      "activeContext.md",
      "decisions.md",
      "systemPatterns.md",
      "techContext.md"
    ],
    hierarchy: [
      "Visão geral",
      "Detalhes específicos",
      "Exemplos",
      "Referências"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "index.md",
    "knowledgeGraph.md",
    "activeContext.md"
  ],
  search: [
    "Priorizar documentos atuais",
    "Verificar referências cruzadas",
    "Validar contexto temporal",
    "Confirmar relevância"
  ],
  response: [
    "Fornecer contexto completo",
    "Incluir referências",
    "Indicar fonte da informação",
    "Sugerir documentação relacionada"
  ]
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "index.md",
    "knowledgeGraph.md",
    "activeContext.md"
  ],
  postUpdate: [
    "Registrar consultas frequentes",
    "Atualizar índices de busca",
    "Melhorar documentação conforme necessidade"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  search: [
    "Precisão",
    "Relevância",
    "Completude",
    "Eficiência"
  ],
  response: [
    "Clareza",
    "Contextualização",
    "Utilidade",
    "Rastreabilidade"
  ],
  documentation: [
    "Organização",
    "Acessibilidade",
    "Atualidade",
    "Interconexão"
  ]
};
</file>

<file path="cursor/rules/modes/code.mdc">
/**
 * @description Regras e diretrizes para o modo Código no projeto StayFocus.
 * Este modo é responsável pela implementação, desenvolvimento, modificação de código e controle de qualidade.
 * @autoAttach {
 *   "patterns": ["**/*.ts", "**/*.tsx", "**/*.py", "**/*.sql"],
 *   "description": "Arquivos de código-fonte do projeto"
 * }
 */

// Responsabilidades Principais
const CODE_RESPONSIBILITIES = {
  implementation: [
    "Desenvolvimento de novas funcionalidades",
    "Implementação de padrões arquiteturais",
    "Codificação de componentes",
    "Integração de sistemas"
  ],
  codeModification: [
    "Refatoração de código existente",
    "Otimização de performance",
    "Correção de bugs",
    "Atualização de dependências"
  ],
  documentation: [
    "Documentação de código",
    "Atualização de documentação técnica",
    "Manutenção de comentários",
    "Criação de exemplos de uso"
  ],
  qualityControl: [
    "Implementação de testes",
    "Revisão de código",
    "Aplicação de padrões de código",
    "Monitoramento de métricas"
  ]
};

// Padrões de Código
const CODE_PATTERNS = {
  typescript: {
    style: "Seguir ESLint e Prettier configurados",
    naming: {
      components: "PascalCase",
      functions: "camelCase",
      constants: "UPPER_SNAKE_CASE",
      interfaces: "IPascalCase"
    },
    organization: [
      "Imports agrupados por tipo",
      "Componentes em arquivos separados",
      "Tipos/interfaces em arquivo .types.ts",
      "Hooks em arquivo .hooks.ts"
    ]
  },
  python: {
    style: "Seguir PEP 8",
    naming: {
      classes: "PascalCase",
      functions: "snake_case",
      constants: "UPPER_SNAKE_CASE",
      variables: "snake_case"
    },
    organization: [
      "Imports ordenados (stdlib, third-party, local)",
      "Classes em arquivos separados",
      "Models em /models",
      "Schemas em /schemas"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "codeDocMap.md",
    "techContext.md",
    "code_style.mdc"
  ],
  codeComments: [
    "Documentar funções complexas",
    "Explicar decisões não óbvias",
    "Incluir exemplos de uso",
    "Referenciar tickets/issues relacionados"
  ],
  updates: [
    "Manter codeDocMap.md atualizado",
    "Documentar mudanças em changelog.md",
    "Atualizar techContext.md quando necessário"
  ]
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "techContext.md",
    "systemPatterns.md",
    "codeDocMap.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar mudanças em changelog.md",
    "Atualizar progress.md"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  code: [
    "Legibilidade",
    "Manutenibilidade",
    "Performance",
    "Testabilidade"
  ],
  testing: [
    "Cobertura adequada",
    "Testes significativos",
    "Testes de edge cases",
    "Testes de integração"
  ],
  documentation: [
    "Clareza",
    "Completude",
    "Atualidade",
    "Relevância"
  ]
};
</file>

<file path="cursor/rules/modes/debug.mdc">
/**
 * @description Regras e diretrizes para o modo Debug no projeto StayFocus.
 * Este modo é responsável pela investigação de problemas, resolução de erros e otimização de performance.
 * @autoAttach {
 *   "patterns": ["**/logs/**/*", "**/*.log", "**/tests/**/*", "**/debug/**/*"],
 *   "description": "Arquivos relacionados a debugging, logs e testes"
 * }
 */

// Responsabilidades Principais
const DEBUG_RESPONSIBILITIES = {
  investigation: [
    "Análise de logs e erros",
    "Reprodução de problemas",
    "Identificação de causas raiz",
    "Documentação de problemas"
  ],
  errorResolution: [
    "Correção de bugs",
    "Validação de fixes",
    "Testes de regressão",
    "Documentação de soluções"
  ],
  performance: [
    "Identificação de gargalos",
    "Otimização de código",
    "Análise de métricas",
    "Melhorias de performance"
  ]
};

// Padrões de Debug
const DEBUG_PATTERNS = {
  logging: {
    levels: [
      "ERROR: Problemas críticos",
      "WARN: Situações inesperadas",
      "INFO: Informações importantes",
      "DEBUG: Detalhes de execução"
    ],
    format: [
      "Timestamp",
      "Nível do log",
      "Contexto",
      "Mensagem",
      "Stack trace (se aplicável)"
    ]
  },
  investigation: {
    steps: [
      "Reproduzir o problema",
      "Coletar logs relevantes",
      "Analisar stack trace",
      "Identificar padrões"
    ],
    tools: [
      "Chrome DevTools",
      "VS Code Debugger",
      "Python Debugger",
      "Logging Framework"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "debugging.mdc",
    "techDebt.md",
    "progress.md"
  ],
  bugReport: [
    "Descrição do problema",
    "Passos para reproduzir",
    "Comportamento esperado",
    "Comportamento atual",
    "Logs relevantes"
  ],
  solution: [
    "Causa raiz identificada",
    "Solução implementada",
    "Testes realizados",
    "Impacto da mudança"
  ]
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "techDebt.md",
    "progress.md",
    "decisions.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar bugs em techDebt.md",
    "Documentar soluções em decisions.md"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  investigation: [
    "Profundidade da análise",
    "Qualidade dos logs",
    "Reprodutibilidade",
    "Documentação clara"
  ],
  solution: [
    "Efetividade",
    "Performance",
    "Testabilidade",
    "Manutenibilidade"
  ],
  documentation: [
    "Clareza",
    "Completude",
    "Rastreabilidade",
    "Utilidade"
  ]
};
</file>

<file path="cursor/rules/modes/test.mdc">
/**
 * @description Regras e diretrizes para o modo Teste no projeto StayFocus.
 * Este modo é responsável pela criação e execução de testes, garantia de qualidade e análise de cobertura.
 * @autoAttach {
 *   "patterns": ["**/*.test.ts", "**/*.spec.ts", "**/tests/**/*", "**/__tests__/**/*"],
 *   "description": "Arquivos de teste e especificações"
 * }
 */

// Responsabilidades Principais
const TEST_RESPONSIBILITIES = {
  testCreation: [
    "Desenvolvimento de testes unitários",
    "Criação de testes de integração",
    "Implementação de testes e2e",
    "Definição de casos de teste"
  ],
  qualityAssurance: [
    "Validação de requisitos",
    "Verificação de comportamentos",
    "Teste de edge cases",
    "Garantia de cobertura"
  ],
  coverageAnalysis: [
    "Análise de cobertura de código",
    "Identificação de gaps",
    "Priorização de testes",
    "Relatórios de cobertura"
  ]
};

// Padrões de Teste
const TEST_PATTERNS = {
  unitTests: {
    naming: "describe('ComponentName', () => { it('should behavior', () => {}) })",
    structure: [
      "Arrange (setup)",
      "Act (execução)",
      "Assert (verificação)"
    ],
    tools: [
      "Jest",
      "React Testing Library",
      "Pytest",
      "Coverage tools"
    ]
  },
  integration: {
    focus: [
      "Interações entre componentes",
      "Fluxos de dados",
      "APIs e serviços",
      "Estado global"
    ],
    tools: [
      "Supertest",
      "MSW",
      "Database fixtures",
      "Mock services"
    ]
  },
  e2e: {
    scenarios: [
      "Fluxos principais",
      "Casos de erro",
      "Performance",
      "Usabilidade"
    ],
    tools: [
      "Cypress",
      "Playwright",
      "Selenium",
      "k6"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "testing.mdc",
    "techContext.md",
    "progress.md"
  ],
  testDocs: [
    "Descrição do teste",
    "Pré-condições",
    "Passos de execução",
    "Resultados esperados"
  ],
  coverage: [
    "Métricas atuais",
    "Áreas críticas",
    "Plano de melhoria",
    "Histórico de progresso"
  ]
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "techContext.md",
    "systemPatterns.md",
    "progress.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar cobertura em progress.md",
    "Documentar padrões em testing.mdc"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  tests: [
    "Confiabilidade",
    "Manutenibilidade",
    "Legibilidade",
    "Eficiência"
  ],
  coverage: [
    "Cobertura de código",
    "Cobertura de casos",
    "Cobertura de caminhos",
    "Cobertura de branches"
  ],
  documentation: [
    "Clareza",
    "Completude",
    "Atualidade",
    "Utilidade"
  ]
};
</file>

<file path="cursor/rules/patterns/architecture.mdc">
---
description: 
globs: 
alwaysApply: false
---
</file>

<file path="cursor/rules/patterns/code_style.mdc">
/**
 * @description Regras e diretrizes de estilo de código para o projeto StayFocus.
 * Define padrões de formatação, nomenclatura e organização de código.
 * @autoAttach {
 *   "patterns": ["**/*.{ts,tsx,py}", "**/.eslintrc.*", "**/.prettierrc.*", "**/pyproject.toml"],
 *   "description": "Arquivos de código fonte e configuração de estilo"
 * }
 */

// Padrões Gerais
const GENERAL_PATTERNS = {
  naming: {
    variables: [
      "camelCase para JavaScript/TypeScript",
      "snake_case para Python",
      "Nomes descritivos e significativos",
      "Evitar abreviações não óbvias"
    ],
    functions: [
      "camelCase para JavaScript/TypeScript",
      "snake_case para Python",
      "Verbo + substantivo",
      "Indicar ação clara"
    ],
    classes: [
      "PascalCase para todas as linguagens",
      "Substantivo ou frase nominal",
      "Nome descritivo do propósito",
      "Evitar sufixos desnecessários"
    ],
    constants: [
      "UPPER_SNAKE_CASE",
      "Prefixo para tipo quando necessário",
      "Agrupar constantes relacionadas",
      "Documentar valor e propósito"
    ]
  },
  formatting: {
    indentation: [
      "2 espaços para JavaScript/TypeScript",
      "4 espaços para Python",
      "Sem tabs",
      "Alinhar elementos relacionados"
    ],
    spacing: [
      "Espaço após palavras-chave",
      "Espaço ao redor de operadores",
      "Linha em branco entre blocos lógicos",
      "Máximo uma linha em branco consecutiva"
    ]
  }
};

// Padrões TypeScript/JavaScript
const TS_JS_PATTERNS = {
  typescript: {
    types: [
      "Interfaces para contratos públicos",
      "Types para unions e intersections",
      "Generics quando apropriado",
      "Documentar tipos complexos"
    ],
    imports: [
      "Import nomeado vs default",
      "Agrupar imports por origem",
      "Ordenar alfabeticamente",
      "Remover imports não utilizados"
    ]
  },
  react: {
    components: [
      "Componentes funcionais",
      "Props interface com 'I' prefix",
      "Prop spreading com cuidado",
      "Memoization quando necessário"
    ],
    hooks: [
      "Prefixo 'use' obrigatório",
      "Um hook por arquivo",
      "Documentar dependências",
      "Tratar cleanup"
    ]
  }
};

// Padrões Python
const PYTHON_PATTERNS = {
  general: {
    imports: [
      "Import absoluto preferido",
      "Agrupar por stdlib, third-party, local",
      "Ordenar alfabeticamente em grupos",
      "Um import por linha"
    ],
    typing: [
      "Type hints em todas as funções",
      "Usar tipos do typing module",
      "Documentar tipos complexos",
      "Validar com mypy"
    ]
  },
  fastapi: {
    routes: [
      "Decorator com método HTTP",
      "Path parameters tipados",
      "Response models explícitos",
      "Documentar responses"
    ],
    models: [
      "Pydantic models para validação",
      "SQLAlchemy models para DB",
      "Documentar campos",
      "Validadores quando necessário"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  comments: {
    usage: [
      "Explicar 'por quê' não 'o quê'",
      "Manter atualizados",
      "Remover comentários obsoletos",
      "Usar TODO com ticket reference"
    ],
    format: [
      "// para comentários inline",
      "/* */ para blocos",
      "/** */ para documentação",
      "# para Python"
    ]
  },
  docstrings: {
    typescript: [
      "JSDoc para funções públicas",
      "Documentar parâmetros",
      "Documentar retorno",
      "Exemplos quando complexo"
    ],
    python: [
      "Google style docstrings",
      "Args, Returns, Raises",
      "Exemplos em doctest",
      "Tipos nos docstrings"
    ]
  }
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "techContext.md",
    "systemPatterns.md",
    "code_style.mdc"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar novos padrões",
    "Atualizar documentação",
    "Notificar equipe"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  readability: [
    "Clareza do código",
    "Consistência de estilo",
    "Documentação adequada",
    "Organização lógica"
  ],
  maintainability: [
    "Modularidade",
    "Baixo acoplamento",
    "Alta coesão",
    "Testabilidade"
  ],
  performance: [
    "Eficiência do código",
    "Otimização apropriada",
    "Uso de memória",
    "Tempo de execução"
  ]
};
</file>

<file path="cursor/rules/patterns/testing.mdc">
/**
 * @description Regras e diretrizes de testes para o projeto StayFocus.
 * Define padrões, estratégias e boas práticas para testes.
 * @autoAttach {
 *   "patterns": ["**/*.test.{ts,tsx}", "**/*.spec.{ts,tsx}", "**/*_test.py", "**/tests/**/*"],
 *   "description": "Arquivos de testes e configurações relacionadas"
 * }
 */

// Estratégias de Teste
const TEST_STRATEGIES = {
  types: {
    unit: [
      "Testes isolados",
      "Mocking de dependências",
      "Cobertura de casos de borda",
      "Foco em comportamento"
    ],
    integration: [
      "Fluxos completos",
      "Interação entre módulos",
      "Testes de API",
      "Testes de banco de dados"
    ],
    e2e: [
      "Fluxos de usuário",
      "Testes de UI",
      "Cenários reais",
      "Performance"
    ]
  },
  approach: {
    tdd: [
      "Red-Green-Refactor",
      "Testes antes do código",
      "Ciclos curtos",
      "Feedback rápido"
    ],
    bdd: [
      "Cenários de comportamento",
      "Given-When-Then",
      "Documentação viva",
      "Colaboração"
    ]
  }
};

// Padrões de Teste Frontend
const FRONTEND_TEST_PATTERNS = {
  react: {
    components: [
      "Renderização",
      "Interações de usuário",
      "Props e estado",
      "Ciclo de vida"
    ],
    hooks: [
      "Comportamento",
      "Efeitos colaterais",
      "Atualizações de estado",
      "Limpeza"
    ]
  },
  tools: {
    jest: [
      "Matchers personalizados",
      "Mocks e spies",
      "Snapshots",
      "Coverage"
    ],
    rtl: [
      "Queries por papel",
      "Eventos de usuário",
      "Assertions de acessibilidade",
      "Async utilities"
    ]
  }
};

// Padrões de Teste Backend
const BACKEND_TEST_PATTERNS = {
  api: {
    endpoints: [
      "Status codes",
      "Payload validation",
      "Error handling",
      "Rate limiting"
    ],
    integration: [
      "Database operations",
      "External services",
      "Authentication",
      "Authorization"
    ]
  },
  tools: {
    pytest: [
      "Fixtures",
      "Parametrização",
      "Markers",
      "Coverage"
    ],
    factories: [
      "Model factories",
      "Fake data",
      "Estado consistente",
      "Cleanup"
    ]
  }
};

// Padrões de Mocking
const MOCKING_PATTERNS = {
  types: {
    mocks: [
      "Comportamento simulado",
      "Verificação de chamadas",
      "Retornos customizados",
      "Exceções"
    ],
    stubs: [
      "Respostas fixas",
      "Simplificação",
      "Estado controlado",
      "Performance"
    ]
  },
  tools: {
    jest: [
      "jest.mock()",
      "jest.spyOn()",
      "mockImplementation",
      "mockResolvedValue"
    ],
    pytest: [
      "monkeypatch",
      "pytest-mock",
      "unittest.mock",
      "async mocks"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  test: {
    structure: [
      "Descrição do teste",
      "Arrange-Act-Assert",
      "Casos de teste claros",
      "Comentários explicativos"
    ],
    naming: [
      "should_when_given",
      "Descrição clara",
      "Agrupamento lógico",
      "Consistência"
    ]
  },
  coverage: {
    reports: [
      "Cobertura de linhas",
      "Cobertura de branches",
      "Funções testadas",
      "Complexidade ciclomática"
    ],
    goals: [
      "Mínimo 80% cobertura",
      "100% em código crítico",
      "Qualidade > Quantidade",
      "Manutenção contínua"
    ]
  }
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "techContext.md",
    "systemPatterns.md",
    "testing.mdc"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar padrões de teste",
    "Atualizar documentação",
    "Notificar equipe"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  tests: [
    "Confiabilidade",
    "Manutenibilidade",
    "Performance",
    "Clareza"
  ],
  coverage: [
    "Abrangência",
    "Relevância",
    "Efetividade",
    "Eficiência"
  ],
  documentation: [
    "Clareza",
    "Completude",
    "Atualidade",
    "Utilidade"
  ]
};
</file>

<file path="cursor/rules/tasks/debugging.mdc">
---
description: 
globs: 
alwaysApply: false
---
/**
 * @description Regras e diretrizes para tarefas de debugging no projeto StayFocus.
 * Define o processo de investigação, resolução de problemas e otimização.
 * @autoAttach {
 *   "patterns": ["**/debug/**/*", "**/*.log", "**/tests/**/*", "**/coverage/**/*"],
 *   "description": "Arquivos relacionados a debugging e logs"
 * }
 */

// Processo de Debug
const DEBUG_PROCESS = {
  investigation: {
    steps: [
      "Reproduzir o problema",
      "Coletar informações",
      "Analisar logs",
      "Identificar padrões"
    ],
    tools: [
      "Chrome DevTools",
      "VS Code Debugger",
      "Python Debugger",
      "PostgreSQL Explain"
    ]
  },
  analysis: {
    frontend: [
      "Console logs",
      "Network requests",
      "Component lifecycle",
      "Estado da aplicação"
    ],
    backend: [
      "Logs de API",
      "Queries SQL",
      "Stack traces",
      "Métricas de performance"
    ]
  }
};

// Padrões de Logging
const LOGGING_PATTERNS = {
  levels: {
    error: "Problemas críticos que precisam de atenção imediata",
    warn: "Situações inesperadas mas não críticas",
    info: "Informações importantes do fluxo normal",
    debug: "Detalhes para debugging"
  },
  format: {
    required: [
      "Timestamp",
      "Nível do log",
      "Contexto",
      "Mensagem",
      "Stack trace (se erro)"
    ],
    context: [
      "ID da requisição",
      "Usuário",
      "Ambiente",
      "Versão da aplicação"
    ]
  }
};

// Estratégias de Debug
const DEBUG_STRATEGIES = {
  frontend: {
    react: [
      "React DevTools",
      "Component inspection",
      "Props/State debugging",
      "Performance profiling"
    ],
    network: [
      "Network tab analysis",
      "Request/Response inspection",
      "Cache verification",
      "CORS issues"
    ]
  },
  backend: {
    api: [
      "Request logging",
      "Response validation",
      "Middleware debugging",
      "Authentication flow"
    ],
    database: [
      "Query analysis",
      "Index usage",
      "Connection issues",
      "Transaction debugging"
    ]
  }
};

// Ferramentas de Debug
const DEBUG_TOOLS = {
  development: [
    "VS Code Debugger",
    "Chrome DevTools",
    "React Developer Tools",
    "Redux DevTools"
  ],
  monitoring: [
    "Logging system",
    "APM tools",
    "Error tracking",
    "Performance monitoring"
  ],
  testing: [
    "Jest debugger",
    "Pytest debugger",
    "Coverage reports",
    "Integration tests"
  ]
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  bugReport: {
    required: [
      "Descrição do problema",
      "Passos para reproduzir",
      "Comportamento esperado",
      "Comportamento atual"
    ],
    context: [
      "Ambiente",
      "Versão",
      "Logs relevantes",
      "Screenshots"
    ]
  },
  solution: {
    documentation: [
      "Causa raiz",
      "Solução implementada",
      "Testes realizados",
      "Prevenção futura"
    ],
    update: [
      "Atualizar debugging.mdc",
      "Documentar em decisions.md",
      "Registrar em changelog.md",
      "Atualizar techDebt.md"
    ]
  }
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "debugging.mdc",
    "techDebt.md",
    "decisions.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar soluções",
    "Documentar padrões",
    "Atualizar knowledgeGraph.md"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  process: [
    "Eficiência na identificação",
    "Precisão da solução",
    "Documentação clara",
    "Prevenção de recorrência"
  ],
  solution: [
    "Performance",
    "Robustez",
    "Manutenibilidade",
    "Testabilidade"
  ],
  documentation: [
    "Clareza",
    "Completude",
    "Rastreabilidade",
    "Utilidade"
  ]
};
</file>

<file path="cursor/rules/tasks/features.mdc">
/**
 * @description Regras e diretrizes para desenvolvimento de funcionalidades no projeto StayFocus.
 * Define o processo de planejamento, implementação e validação de novas features.
 * @autoAttach {
 *   "patterns": ["**/*.{ts,tsx,py}", "**/tests/**/*", "**/docs/**/*"],
 *   "description": "Arquivos de código fonte, testes e documentação"
 * }
 */

// Processo de Desenvolvimento
const DEVELOPMENT_PROCESS = {
  planning: {
    requirements: [
      "Análise de requisitos",
      "Definição de escopo",
      "Estimativa de tempo",
      "Identificação de dependências"
    ],
    design: [
      "Arquitetura da solução",
      "Design de interface",
      "Modelagem de dados",
      "Fluxo de interação"
    ]
  },
  implementation: {
    frontend: [
      "Componentes React",
      "Gerenciamento de estado",
      "Integração com API",
      "Testes unitários"
    ],
    backend: [
      "Endpoints API",
      "Lógica de negócio",
      "Persistência de dados",
      "Testes de integração"
    ]
  }
};

// Padrões de Feature
const FEATURE_PATTERNS = {
  ui: {
    components: [
      "Componentização",
      "Reutilização",
      "Responsividade",
      "Acessibilidade"
    ],
    interaction: [
      "Feedback visual",
      "Loading states",
      "Error handling",
      "Success feedback"
    ]
  },
  api: {
    endpoints: [
      "RESTful design",
      "Validação de dados",
      "Rate limiting",
      "Caching"
    ],
    responses: [
      "Status codes",
      "Error messages",
      "Payload structure",
      "Paginação"
    ]
  }
};

// Regras de Implementação
const IMPLEMENTATION_RULES = {
  code: {
    frontend: [
      "TypeScript strict",
      "ESLint rules",
      "Prettier config",
      "Component patterns"
    ],
    backend: [
      "Type hints",
      "PEP 8",
      "Async patterns",
      "Error handling"
    ]
  },
  testing: {
    unit: [
      "Jest/React Testing Library",
      "Pytest",
      "Mocking",
      "Coverage"
    ],
    integration: [
      "API tests",
      "E2E tests",
      "Performance tests",
      "Load tests"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "Descrição da feature",
    "Requisitos técnicos",
    "Guia de implementação",
    "Casos de teste"
  ],
  updates: {
    files: [
      "productContext.md",
      "systemPatterns.md",
      "progress.md",
      "decisions.md"
    ],
    content: [
      "Funcionalidades implementadas",
      "Decisões técnicas",
      "Dependências",
      "Próximos passos"
    ]
  }
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "productContext.md",
    "systemPatterns.md",
    "techContext.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar funcionalidades",
    "Documentar padrões",
    "Atualizar knowledgeGraph.md"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  functionality: [
    "Completude",
    "Corretude",
    "Performance",
    "Usabilidade"
  ],
  code: [
    "Legibilidade",
    "Manutenibilidade",
    "Testabilidade",
    "Reusabilidade"
  ],
  documentation: [
    "Clareza",
    "Completude",
    "Atualidade",
    "Utilidade"
  ]
};
</file>

<file path="cursor/rules/tasks/refactoring.mdc">
/**
 * @description Regras e diretrizes para tarefas de refatoração no projeto StayFocus.
 * Define padrões, processos e critérios para melhorar a qualidade do código.
 * @autoAttach {
 *   "patterns": ["**/*.{ts,tsx,py}", "**/tests/**/*"],
 *   "description": "Arquivos de código fonte e testes"
 * }
 */

// Padrões de Refatoração
const REFACTORING_PATTERNS = {
  code: {
    principles: [
      "DRY (Don't Repeat Yourself)",
      "SOLID",
      "KISS (Keep It Simple, Stupid)",
      "YAGNI (You Aren't Gonna Need It)"
    ],
    smells: [
      "Código duplicado",
      "Métodos longos",
      "Classes grandes",
      "Complexidade excessiva"
    ]
  },
  strategies: {
    extraction: [
      "Extrair método",
      "Extrair componente",
      "Extrair classe",
      "Extrair interface"
    ],
    organization: [
      "Mover método",
      "Mover classe",
      "Renomear",
      "Reorganizar estrutura"
    ]
  }
};

// Processo de Refatoração
const REFACTORING_PROCESS = {
  preparation: [
    "Identificar áreas problemáticas",
    "Analisar impacto",
    "Planejar mudanças",
    "Criar testes"
  ],
  execution: [
    "Aplicar mudanças incrementais",
    "Executar testes",
    "Revisar código",
    "Documentar alterações"
  ],
  validation: [
    "Testes de regressão",
    "Review de código",
    "Análise de performance",
    "Verificação de qualidade"
  ]
};

// Padrões de Código
const CODE_PATTERNS = {
  frontend: {
    react: [
      "Componentes funcionais",
      "Hooks customizados",
      "Props typing",
      "Memoization"
    ],
    state: [
      "Zustand stores",
      "Estado local",
      "Context API",
      "Imutabilidade"
    ]
  },
  backend: {
    python: [
      "Type hints",
      "Async/await",
      "Dependency injection",
      "Repository pattern"
    ],
    api: [
      "RESTful endpoints",
      "Validação de dados",
      "Error handling",
      "Middleware chain"
    ]
  }
};

// Regras de Documentação
const DOCUMENTATION_RULES = {
  required: [
    "Justificativa da refatoração",
    "Mudanças realizadas",
    "Impacto nas dependências",
    "Testes atualizados"
  ],
  updates: {
    files: [
      "decisions.md",
      "techDebt.md",
      "systemPatterns.md",
      "progress.md"
    ],
    content: [
      "Padrões aplicados",
      "Decisões técnicas",
      "Melhorias realizadas",
      "Débitos técnicos resolvidos"
    ]
  }
};

// Integrações com Memory Bank
const MEMORY_BANK_INTEGRATION = {
  preRead: [
    "systemPatterns.md",
    "techDebt.md",
    "decisions.md"
  ],
  postUpdate: [
    "Atualizar activeContext.md",
    "Registrar mudanças",
    "Documentar padrões",
    "Atualizar knowledgeGraph.md"
  ]
};

// Critérios de Qualidade
const QUALITY_CRITERIA = {
  code: [
    "Legibilidade",
    "Manutenibilidade",
    "Testabilidade",
    "Performance"
  ],
  architecture: [
    "Coesão",
    "Acoplamento",
    "Extensibilidade",
    "Reusabilidade"
  ],
  documentation: [
    "Clareza",
    "Completude",
    "Rastreabilidade",
    "Atualidade"
  ]
};
</file>

<file path="app/alimentacao/page.tsx">
import { Card, CardHeader, CardTitle, CardContent } from '@/app/components/ui/Card'
import { PlanejadorRefeicoes } from '@/app/components/alimentacao/PlanejadorRefeicoes'
import { RegistroRefeicoes } from '@/app/components/alimentacao/RegistroRefeicoes'
import { LembreteHidratacao } from '@/app/components/alimentacao/LembreteHidratacao'

export default function AlimentacaoPage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Alimentação</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Planejador de Refeições */}
        <Card>
          <CardHeader>
            <CardTitle>Planejador de Refeições</CardTitle>
          </CardHeader>
          <CardContent>
            <PlanejadorRefeicoes />
          </CardContent>
        </Card>
        
        {/* Registro Visual de Refeições */}
        <Card>
          <CardHeader>
            <CardTitle>Registro de Refeições</CardTitle>
          </CardHeader>
          <CardContent>
            <RegistroRefeicoes />
          </CardContent>
        </Card>
      </div>
      
      {/* Lembrete de Hidratação */}
      <Card>
        <CardHeader>
          <CardTitle>Lembrete de Hidratação</CardTitle>
        </CardHeader>
        <CardContent>
          <LembreteHidratacao />
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/assistente-ia/page.tsx">
import AIAssistant from "@/app/components/ai/AIAssistant";
import { Container } from "@/app/components/ui/Container";
import { Section } from "@/app/components/ui/Section";

export const metadata = {
  title: 'Assistente IA | StayFocus',
  description: 'Assistente de IA para ajudar pessoas neurodivergentes com organização, produtividade e bem-estar.',
};

export default function AssistentePage() {
  return (
    <Container>
      <Section title="Assistente de IA">
        <div className="max-w-4xl mx-auto">
          <h1 className="text-3xl font-bold mb-6">Assistente de IA</h1>
          <p className="mb-8 text-muted-foreground">
            Use nossa inteligência artificial para obter recomendações personalizadas 
            adaptadas às necessidades de pessoas neurodivergentes. Este assistente 
            pode ajudar com priorização de tarefas, criação de rotinas estruturadas, 
            planejamento de estudos e muito mais.
          </p>
          
          <AIAssistant />
        </div>
      </Section>
    </Container>
  );
}
</file>

<file path="app/auth/cadastro/page.tsx">
'use client';

import { useState } from 'react';
import { useAuthContext } from '../../context/AuthContext';
import { useRouter } from 'next/navigation';
import Link from 'next/link';

export default function CadastroPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [fullName, setFullName] = useState('');
  const [message, setMessage] = useState<{ text: string; type: 'success' | 'error' } | null>(null);
  
  const { signUpWithEmail, signInWithGoogle, loading } = useAuthContext();
  const router = useRouter();
  
  async function handleSignUp(e: React.FormEvent) {
    e.preventDefault();
    setMessage(null);
    
    // Validação básica
    if (password !== confirmPassword) {
      setMessage({ text: 'As senhas não coincidem', type: 'error' });
      return;
    }
    
    if (password.length < 6) {
      setMessage({ text: 'A senha deve ter pelo menos 6 caracteres', type: 'error' });
      return;
    }
    
    try {
      const { data, error } = await signUpWithEmail(email, password, {
        full_name: fullName
      });
      
      if (error) {
        throw error;
      } else {
        setMessage({ 
          text: 'Cadastro realizado! Verifique seu email para confirmar o cadastro.', 
          type: 'success' 
        });
        
        // Se não precisar de confirmação de email (configuração do Supabase)
        setTimeout(() => {
          router.push('/');
        }, 2000);
      }
    } catch (error: any) {
      console.error('Erro ao criar conta:', error);
      setMessage({ 
        text: error.message || 'Erro ao criar conta. Tente novamente.', 
        type: 'error' 
      });
    }
  }
  
  async function handleGoogleSignUp() {
    try {
      await signInWithGoogle();
      // OAuth redirecionará após autenticação
    } catch (error: any) {
      console.error('Erro ao cadastrar com Google:', error);
      setMessage({ 
        text: error.message || 'Erro ao cadastrar com Google.', 
        type: 'error' 
      });
    }
  }
  
  return (
    <div className="flex min-h-screen flex-col items-center justify-center p-4">
      <div className="w-full max-w-md space-y-8 rounded-xl bg-white p-8 shadow-lg dark:bg-gray-800">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Cadastro</h1>
          <p className="mt-2 text-gray-600 dark:text-gray-300">
            Crie sua conta para começar
          </p>
        </div>
        
        {message && (
          <div 
            className={`rounded-md p-4 ${
              message.type === 'success' ? 'bg-green-50 text-green-800' : 'bg-red-50 text-red-800'
            }`}
          >
            {message.text}
          </div>
        )}
        
        <form className="mt-8 space-y-6" onSubmit={handleSignUp}>
          <div className="space-y-4">
            <div>
              <label htmlFor="fullName" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Nome Completo
              </label>
              <input
                id="fullName"
                name="fullName"
                type="text"
                required
                className="mt-1 block w-full rounded-md border border-gray-300 bg-white px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                placeholder="Seu Nome Completo"
                value={fullName}
                onChange={(e) => setFullName(e.target.value)}
              />
            </div>
            
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Email
              </label>
              <input
                id="email"
                name="email"
                type="email"
                required
                className="mt-1 block w-full rounded-md border border-gray-300 bg-white px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                placeholder="seu@email.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Senha
              </label>
              <input
                id="password"
                name="password"
                type="password"
                required
                className="mt-1 block w-full rounded-md border border-gray-300 bg-white px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                placeholder="••••••••"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            
            <div>
              <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Confirmar Senha
              </label>
              <input
                id="confirmPassword"
                name="confirmPassword"
                type="password"
                required
                className="mt-1 block w-full rounded-md border border-gray-300 bg-white px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                placeholder="••••••••"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
              />
            </div>
          </div>
          
          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative flex w-full justify-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:bg-indigo-300"
            >
              {loading ? 'Cadastrando...' : 'Cadastrar'}
            </button>
          </div>
        </form>
        
        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300 dark:border-gray-700"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="bg-white px-2 text-gray-500 dark:bg-gray-800 dark:text-gray-400">
                Ou continue com
              </span>
            </div>
          </div>
          
          <div className="mt-6">
            <button
              onClick={handleGoogleSignUp}
              disabled={loading}
              className="flex w-full items-center justify-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600"
            >
              <svg className="h-5 w-5" viewBox="0 0 24 24">
                <path
                  d="M12.545, 10.239v3.821h5.445c-0.712, 2.315-2.647, 3.972-5.445, 3.972-3.332, 0-6.033-2.701-6.033-6.032s2.701-6.032, 6.033-6.032c1.498, 0, 2.866, 0.549, 3.921, 1.453l2.814-2.814C17.503, 2.988, 15.139, 2, 12.545, 2 7.021, 2, 2.543, 6.477, 2.543, 12s4.478, 10, 10.002, 10c8.396, 0, 10.249-7.85, 9.426-11.748l-9.426, 0.013z"
                  fill="currentColor"
                />
              </svg>
              Google
            </button>
          </div>
        </div>
        
        <div className="mt-6 text-center">
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Já tem uma conta?{' '}
            <Link 
              href="/auth/login" 
              className="font-medium text-indigo-600 hover:text-indigo-500 dark:text-indigo-400"
            >
              Faça login
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/auth/callback/route.ts">
import { createClient } from '@/app/lib/supabase'
import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET(request: Request) {
  const requestUrl = new URL(request.url)
  const code = requestUrl.searchParams.get('code')

  if (code) {
    const cookieStore = cookies()
    const supabase = createClient()

    await supabase.auth.exchangeCodeForSession(code)
  }

  return NextResponse.redirect(requestUrl.origin)
}
</file>

<file path="app/auth/login/page.tsx">
'use client';

import { useState } from 'react';
import { useAuthContext } from '../../context/AuthContext';
import { useRouter } from 'next/navigation';
import Link from 'next/link';

export const dynamic = 'force-dynamic';
export const revalidate = 0;

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState<{ text: string; type: 'success' | 'error' } | null>(null);
  
  const { signInWithEmail, signInWithGoogle, loading } = useAuthContext();
  const router = useRouter();
  
  async function handleLogin(e: React.FormEvent) {
    e.preventDefault();
    setMessage(null);
    
    try {
      const { error } = await signInWithEmail(email, password);
      
      if (error) {
        throw error;
      } else {
        setMessage({ text: 'Login bem-sucedido! Redirecionando...', type: 'success' });
        setTimeout(() => {
          router.push('/');
        }, 1000);
      }
    } catch (error: any) {
      console.error('Erro ao fazer login:', error);
      setMessage({ 
        text: error.message || 'Erro ao fazer login. Verifique suas credenciais.', 
        type: 'error' 
      });
    }
  }
  
  async function handleGoogleLogin() {
    try {
      await signInWithGoogle();
      // Não precisamos redirecionar aqui, o OAuth vai lidar com isso
    } catch (error: any) {
      console.error('Erro ao fazer login com Google:', error);
      setMessage({ 
        text: error.message || 'Erro ao fazer login com Google.', 
        type: 'error' 
      });
    }
  }
  
  return (
    <div className="flex min-h-screen flex-col items-center justify-center p-4">
      <div className="w-full max-w-md space-y-8 rounded-xl bg-white p-8 shadow-lg dark:bg-gray-800">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Login</h1>
          <p className="mt-2 text-gray-600 dark:text-gray-300">
            Acesse sua conta para continuar
          </p>
        </div>
        
        {message && (
          <div 
            className={`rounded-md p-4 ${
              message.type === 'success' ? 'bg-green-50 text-green-800' : 'bg-red-50 text-red-800'
            }`}
          >
            {message.text}
          </div>
        )}
        
        <form className="mt-8 space-y-6" onSubmit={handleLogin}>
          <div className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Email
              </label>
              <input
                id="email"
                name="email"
                type="email"
                required
                className="mt-1 block w-full rounded-md border border-gray-300 bg-white px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                placeholder="seu@email.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Senha
              </label>
              <input
                id="password"
                name="password"
                type="password"
                required
                className="mt-1 block w-full rounded-md border border-gray-300 bg-white px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                placeholder="••••••••"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
          </div>
          
          <div className="flex items-center justify-between">
            <div className="text-sm">
              <Link 
                href="/auth/recuperar-senha" 
                className="font-medium text-indigo-600 hover:text-indigo-500 dark:text-indigo-400"
              >
                Esqueceu sua senha?
              </Link>
            </div>
          </div>
          
          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative flex w-full justify-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:bg-indigo-300"
            >
              {loading ? 'Entrando...' : 'Entrar'}
            </button>
          </div>
        </form>
        
        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300 dark:border-gray-700"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="bg-white px-2 text-gray-500 dark:bg-gray-800 dark:text-gray-400">
                Ou continue com
              </span>
            </div>
          </div>
          
          <div className="mt-6">
            <button
              onClick={handleGoogleLogin}
              disabled={loading}
              className="flex w-full items-center justify-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600"
            >
              <svg className="h-5 w-5" viewBox="0 0 24 24">
                <path
                  d="M12.545, 10.239v3.821h5.445c-0.712, 2.315-2.647, 3.972-5.445, 3.972-3.332, 0-6.033-2.701-6.033-6.032s2.701-6.032, 6.033-6.032c1.498, 0, 2.866, 0.549, 3.921, 1.453l2.814-2.814C17.503, 2.988, 15.139, 2, 12.545, 2 7.021, 2, 2.543, 6.477, 2.543, 12s4.478, 10, 10.002, 10c8.396, 0, 10.249-7.85, 9.426-11.748l-9.426, 0.013z"
                  fill="currentColor"
                />
              </svg>
              Google
            </button>
          </div>
        </div>
        
        <div className="mt-6 text-center">
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Não tem uma conta?{' '}
            <Link 
              href="/auth/cadastro" 
              className="font-medium text-indigo-600 hover:text-indigo-500 dark:text-indigo-400"
            >
              Cadastre-se
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/autoconhecimento/page.tsx">
'use client'

import { useState } from 'react'
import { Anchor, PenSquare, X } from 'lucide-react'
import { EditorNotas } from '../components/autoconhecimento/EditorNotas'
import { ListaNotas } from '../components/autoconhecimento/ListaNotas'
import { ModoRefugio } from '../components/autoconhecimento/ModoRefugio'
import { Button } from '../components/ui/Button'
import { Container } from '../components/ui/Container'
import { Section } from '../components/ui/Section'
import { useAutoconhecimentoStore } from '../stores/autoconhecimentoStore'

export default function AutoconhecimentoPage() {
  const [abaSelecionada, setAbaSelecionada] = useState<'quem-sou' | 'meus-porques' | 'meus-padroes'>('quem-sou')
  const [notaSelecionada, setNotaSelecionada] = useState<string | null>(null)
  const [criandoNota, setCriandoNota] = useState(false)
  
  const { modoRefugio } = useAutoconhecimentoStore()
  
  // Mapeamento de títulos para exibição
  const tituloAbas = {
    'quem-sou': 'Quem sou',
    'meus-porques': 'Meus porquês',
    'meus-padroes': 'Meus padrões'
  }
  
  // Mapeamento de descrições para cada seção
  const descricaoAbas = {
    'quem-sou': 'Registre suas preferências, aversões e características pessoais estáveis',
    'meus-porques': 'Documente motivações e valores fundamentais que guiam suas decisões',
    'meus-padroes': 'Anote reações emocionais típicas e estratégias eficazes em momentos de crise'
  }
  
  // Função para selecionar uma nota
  const handleSelecionarNota = (id: string) => {
    setNotaSelecionada(id)
    setCriandoNota(false)
  }
  
  // Função para iniciar criação de nova nota
  const handleCriarNota = () => {
    setNotaSelecionada(null)
    setCriandoNota(true)
  }
  
  // Função para cancelar edição/criação
  const handleCancelar = () => {
    setNotaSelecionada(null)
    setCriandoNota(false)
  }
  
  // Função após salvar uma nota
  const handleSalvarNota = () => {
    setNotaSelecionada(null)
    setCriandoNota(false)
  }
  
  // Verifica se estamos no modo refúgio para simplificar a interface
  const interfaceSimplificada = modoRefugio
  
  return (
    <Container>
      {/* Cabeçalho com título */}
      <div className="flex items-center mb-6">
        <Anchor className="h-7 w-7 text-autoconhecimento-primary mr-3" aria-hidden="true" />
        <h1 className="text-2xl font-bold text-gray-800 dark:text-white">Notas de Autoconhecimento</h1>
      </div>
      
      {/* Navegação entre abas */}
      <div className="flex border-b border-gray-200 dark:border-gray-700 mb-6 overflow-x-auto">
        {(Object.keys(tituloAbas) as Array<keyof typeof tituloAbas>).map((aba) => (
          <button
            key={aba}
            className={`px-4 py-2 font-medium text-sm whitespace-nowrap rounded-t-lg transition-colors ${
              abaSelecionada === aba
                ? 'bg-autoconhecimento-light text-autoconhecimento-primary border-b-2 border-autoconhecimento-primary'
                : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
            }`}
            onClick={() => {
              setAbaSelecionada(aba)
              setNotaSelecionada(null)
              setCriandoNota(false)
            }}
            aria-current={abaSelecionada === aba ? 'page' : undefined}
          >
            {tituloAbas[aba]}
          </button>
        ))}
      </div>
      
      {/* Descrição da seção atual */}
      {!interfaceSimplificada && !notaSelecionada && !criandoNota && (
        <div className="mb-6 bg-autoconhecimento-light bg-opacity-60 dark:bg-gray-700 p-4 rounded-lg">
          <h2 className="text-lg font-medium text-autoconhecimento-primary mb-2">{tituloAbas[abaSelecionada]}</h2>
          <p className="text-gray-700 dark:text-gray-300">{descricaoAbas[abaSelecionada]}</p>
        </div>
      )}
      
      {/* Conteúdo principal */}
      <Section 
        title={tituloAbas[abaSelecionada]} 
        className={`${interfaceSimplificada ? 'bg-opacity-90' : ''} transition-opacity duration-300`}
      >
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Área de lista de notas */}
          <div className={notaSelecionada || criandoNota ? 'hidden lg:block' : 'block'}>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium text-gray-800 dark:text-white">
                Suas notas em {tituloAbas[abaSelecionada]}
              </h3>
              
              {!interfaceSimplificada && (
                <Button
                  onClick={handleCriarNota}
                  className="flex items-center text-sm bg-autoconhecimento-primary text-white hover:bg-autoconhecimento-hover transition-colors"
                  aria-label="Criar nova nota"
                >
                  <PenSquare size={16} className="mr-1" />
                  <span>Nova nota</span>
                </Button>
              )}
            </div>
            
            <ListaNotas 
              secaoAtual={abaSelecionada}
              onSelectNota={handleSelecionarNota}
            />
          </div>
          
          {/* Área de edição/visualização */}
          {(notaSelecionada || criandoNota) && (
            <div className="lg:col-span-1">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-medium text-gray-800 dark:text-white">
                  {criandoNota ? 'Nova nota' : 'Editar nota'}
                </h3>
                
                <Button
                  onClick={handleCancelar}
                  className="flex items-center text-sm bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
                  aria-label="Cancelar edição"
                >
                  <X size={16} className="mr-1" />
                  <span>Cancelar</span>
                </Button>
              </div>
              
              <EditorNotas
                id={notaSelecionada || undefined}
                secaoAtual={abaSelecionada}
                onSave={handleSalvarNota}
              />
            </div>
          )}
        </div>
      </Section>
      
      {/* Botão flutuante para Modo Refúgio */}
      <ModoRefugio />
    </Container>
  )
}
</file>

<file path="app/components/ai/AIAssistant.tsx">
"use client";

import { useState, useRef } from "react";
import { Button } from "@/app/components/ui/Button";
import { Textarea } from "@/app/components/ui/Textarea";
import { Input } from "@/app/components/ui/Input";
import { Select } from "@/app/components/ui/Select";
import { Card } from "@/app/components/ui/Card";
import { LoadingIndicator } from "@/app/components/ui/LoadingIndicator";
import { Alert } from "@/app/components/ui/Alert";
import { Badge } from "@/app/components/ui/Badge";
import { priorizarTarefas, gerarRotinaDiaria, planoDeEstudos, estrategiasSono, analiseFinanceira } from "@/app/lib/ai";

type AssistantMode = "prioridades" | "rotina" | "estudos" | "sono" | "financas";

export default function AIAssistant() {
  const [mode, setMode] = useState<AssistantMode>("prioridades");
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  // Campos para o modo prioridades
  const [tarefas, setTarefas] = useState("");
  const [contexto, setContexto] = useState("");
  
  // Campos para o modo rotina
  const [horaAcordar, setHoraAcordar] = useState("07:00");
  const [horaDormir, setHoraDormir] = useState("23:00");
  const [preferencias, setPreferencias] = useState("");
  
  // Campos para o modo estudos
  const [assunto, setAssunto] = useState("");
  const [objetivo, setObjetivo] = useState("");
  const [tempoDisponivel, setTempoDisponivel] = useState("");
  
  // Campos para o modo sono
  const [horasDormidas, setHorasDormidas] = useState<number>(7);
  const [problemasSono, setProblemasSono] = useState("");
  
  // Campos para o modo finanças
  const [renda, setRenda] = useState<number>(0);
  const [categorias, setCategorias] = useState<{ nome: string; valor: number }[]>([
    { nome: "Moradia", valor: 0 },
    { nome: "Alimentação", valor: 0 },
    { nome: "Transporte", valor: 0 },
    { nome: "Lazer", valor: 0 },
    { nome: "Outros", valor: 0 }
  ]);

  const resultRef = useRef<HTMLDivElement>(null);

  // Função para rolar até o resultado
  const scrollToResult = () => {
    if (resultRef.current) {
      resultRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  };

  const handleSubmit = async () => {
    setLoading(true);
    setError(null);
    setResult(null);
    
    try {
      let response: string;
      
      switch (mode) {
        case "prioridades":
          if (!tarefas.trim()) {
            throw new Error("Por favor, adicione pelo menos uma tarefa.");
          }
          const tarefasLista = tarefas.split('\n').filter(t => t.trim() !== '');
          response = await priorizarTarefas(tarefasLista, contexto);
          break;
          
        case "rotina":
          response = await gerarRotinaDiaria(horaAcordar, horaDormir, preferencias);
          break;
          
        case "estudos":
          if (!assunto.trim() || !objetivo.trim() || !tempoDisponivel.trim()) {
            throw new Error("Por favor, preencha todos os campos.");
          }
          response = await planoDeEstudos(assunto, objetivo, tempoDisponivel);
          break;
          
        case "sono":
          const problemasList = problemasSono.split('\n').filter(p => p.trim() !== '');
          response = await estrategiasSono(horasDormidas, problemasList);
          break;
          
        case "financas":
          if (renda <= 0) {
            throw new Error("Por favor, informe uma renda válida.");
          }
          const categoriasObj: Record<string, number> = {};
          categorias.forEach(cat => {
            categoriasObj[cat.nome] = cat.valor;
          });
          response = await analiseFinanceira(categoriasObj, renda);
          break;
          
        default:
          throw new Error("Modo de assistente inválido.");
      }
      
      setResult(response);
      // Rola para o resultado após um pequeno delay para garantir que o componente foi renderizado
      setTimeout(scrollToResult, 100);
    } catch (err) {
      console.error("Erro ao processar solicitação:", err);
      setError(err instanceof Error ? err.message : "Ocorreu um erro ao processar sua solicitação.");
    } finally {
      setLoading(false);
    }
  };

  const updateCategoria = (index: number, nome: string, valor: number) => {
    const newCategorias = [...categorias];
    newCategorias[index] = { nome, valor };
    setCategorias(newCategorias);
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-4">
        <h2 className="text-2xl font-bold">Assistente de IA para Neurodivergentes</h2>
        <p className="text-muted-foreground">
          Este assistente usa inteligência artificial para ajudar em vários aspectos da organização
          pessoal, adaptados às necessidades de pessoas neurodivergentes.
        </p>
        
        <div className="flex flex-wrap gap-2 mb-4">
          <Badge 
            className={`cursor-pointer ${mode === "prioridades" ? "bg-primary" : "bg-secondary"}`}
            onClick={() => setMode("prioridades")}
          >
            Priorização de Tarefas
          </Badge>
          <Badge 
            className={`cursor-pointer ${mode === "rotina" ? "bg-primary" : "bg-secondary"}`}
            onClick={() => setMode("rotina")}
          >
            Rotina Diária
          </Badge>
          <Badge 
            className={`cursor-pointer ${mode === "estudos" ? "bg-primary" : "bg-secondary"}`}
            onClick={() => setMode("estudos")}
          >
            Plano de Estudos
          </Badge>
          <Badge 
            className={`cursor-pointer ${mode === "sono" ? "bg-primary" : "bg-secondary"}`}
            onClick={() => setMode("sono")}
          >
            Qualidade do Sono
          </Badge>
          <Badge 
            className={`cursor-pointer ${mode === "financas" ? "bg-primary" : "bg-secondary"}`}
            onClick={() => setMode("financas")}
          >
            Finanças
          </Badge>
        </div>
        
        <Card className="p-6">
          {mode === "prioridades" && (
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Priorização de Tarefas</h3>
              <p className="text-sm text-muted-foreground">
                Adicione suas tarefas (uma por linha) e o assistente irá ajudar a priorizá-las de acordo com 
                as necessidades específicas de pessoas com TDAH.
              </p>
              
              <div>
                <label className="block text-sm font-medium mb-1">Tarefas (uma por linha)</label>
                <Textarea 
                  value={tarefas} 
                  onChange={(e) => setTarefas(e.target.value)} 
                  placeholder="Ex: Preparar apresentação para reunião&#10;Pagar contas&#10;Organizar mesa de trabalho" 
                  rows={5}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-1">Contexto Adicional (opcional)</label>
                <Textarea 
                  value={contexto} 
                  onChange={(e) => setContexto(e.target.value)} 
                  placeholder="Ex: Estou com baixa energia hoje e preciso me concentrar na apresentação que é para amanhã."
                  rows={3}
                />
              </div>
            </div>
          )}
          
          {mode === "rotina" && (
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Rotina Diária</h3>
              <p className="text-sm text-muted-foreground">
                Gere uma rotina diária estruturada adaptada às necessidades de pessoas com TDAH.
              </p>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium mb-1">Horário de Acordar</label>
                  <Input 
                    type="time" 
                    value={horaAcordar} 
                    onChange={(e) => setHoraAcordar(e.target.value)} 
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium mb-1">Horário de Dormir</label>
                  <Input 
                    type="time" 
                    value={horaDormir} 
                    onChange={(e) => setHoraDormir(e.target.value)} 
                  />
                </div>
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-1">Preferências e Necessidades (opcional)</label>
                <Textarea 
                  value={preferencias} 
                  onChange={(e) => setPreferencias(e.target.value)} 
                  placeholder="Ex: Preciso de 30 minutos para exercício físico diário. Trabalho das 9h às 17h. Medicação às 8h e 14h."
                  rows={3}
                />
              </div>
            </div>
          )}
          
          {mode === "estudos" && (
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Plano de Estudos</h3>
              <p className="text-sm text-muted-foreground">
                Crie um plano de estudos adaptado às necessidades de pessoas com TDAH.
              </p>
              
              <div>
                <label className="block text-sm font-medium mb-1">Assunto</label>
                <Input 
                  value={assunto} 
                  onChange={(e) => setAssunto(e.target.value)} 
                  placeholder="Ex: Matemática, História, Programação em Python" 
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-1">Objetivo</label>
                <Input 
                  value={objetivo} 
                  onChange={(e) => setObjetivo(e.target.value)} 
                  placeholder="Ex: Preparar para prova, aprender nova habilidade, revisar conteúdo" 
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-1">Tempo Disponível</label>
                <Input 
                  value={tempoDisponivel} 
                  onChange={(e) => setTempoDisponivel(e.target.value)} 
                  placeholder="Ex: 2 horas por dia, 5 dias" 
                />
              </div>
            </div>
          )}
          
          {mode === "sono" && (
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Qualidade do Sono</h3>
              <p className="text-sm text-muted-foreground">
                Obtenha estratégias para melhorar a qualidade do sono, considerando os desafios específicos do TDAH.
              </p>
              
              <div>
                <label className="block text-sm font-medium mb-1">Média de Horas Dormidas por Noite</label>
                <Input 
                  type="number" 
                  min="0" 
                  max="24" 
                  step="0.5"
                  value={horasDormidas} 
                  onChange={(e) => setHorasDormidas(Number(e.target.value))} 
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-1">Problemas Específicos (um por linha, opcional)</label>
                <Textarea 
                  value={problemasSono} 
                  onChange={(e) => setProblemasSono(e.target.value)} 
                  placeholder="Ex: Dificuldade para adormecer&#10;Acordar várias vezes durante a noite&#10;Sonolência diurna excessiva"
                  rows={3}
                />
              </div>
            </div>
          )}
          
          {mode === "financas" && (
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Finanças</h3>
              <p className="text-sm text-muted-foreground">
                Analise seus gastos e obtenha estratégias para melhorar a organização financeira.
              </p>
              
              <div>
                <label className="block text-sm font-medium mb-1">Renda Mensal (R$)</label>
                <Input 
                  type="number" 
                  min="0" 
                  step="100"
                  value={renda} 
                  onChange={(e) => setRenda(Number(e.target.value))} 
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium mb-1">Categorias de Gastos</label>
                {categorias.map((categoria, index) => (
                  <div key={index} className="flex gap-2 mb-2">
                    <Input 
                      className="w-1/2"
                      value={categoria.nome} 
                      onChange={(e) => updateCategoria(index, e.target.value, categoria.valor)} 
                      placeholder="Nome da categoria" 
                    />
                    <Input 
                      className="w-1/2"
                      type="number" 
                      min="0" 
                      step="10"
                      value={categoria.valor} 
                      onChange={(e) => updateCategoria(index, categoria.nome, Number(e.target.value))} 
                      placeholder="Valor (R$)" 
                    />
                  </div>
                ))}
              </div>
            </div>
          )}
          
          <div className="mt-6">
            <Button 
              onClick={handleSubmit} 
              disabled={loading}
              className="w-full"
            >
              {loading ? <LoadingIndicator /> : 'Gerar Recomendações'}
            </Button>
          </div>
        </Card>
        
        {error && (
          <Alert variant="destructive" className="mt-4">
            {error}
          </Alert>
        )}
        
        {result && (
          <div ref={resultRef} className="mt-6">
            <Card className="p-6">
              <h3 className="text-lg font-semibold mb-4">Recomendações</h3>
              <div className="whitespace-pre-line">{result}</div>
            </Card>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/components/alimentacao/LembreteHidratacao.tsx">
'use client'

import { Droplet, PlusCircle, MinusCircle } from 'lucide-react'
import { useAlimentacaoStore } from '@/app/stores/alimentacaoStore'

export function LembreteHidratacao() {
  const { 
    coposBebidos, 
    metaDiaria, 
    ultimoRegistro, 
    adicionarCopo, 
    removerCopo, 
    ajustarMeta 
  } = useAlimentacaoStore()

  // Calcular a porcentagem de progresso
  const progresso = Math.min((coposBebidos / metaDiaria) * 100, 100)

  return (
    <div className="space-y-4">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between">
        <div className="mb-4 md:mb-0">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-1">
            Acompanhamento de Hidratação
          </h3>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Registre os copos de água que você bebe durante o dia
          </p>
        </div>
        
        <div className="flex items-center space-x-2">
          <button
            onClick={() => ajustarMeta(-1)}
            className="p-1 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700"
            aria-label="Diminuir meta diária"
            disabled={metaDiaria <= 1}
          >
            <MinusCircle className="h-6 w-6" />
          </button>
          
          <div className="px-3 py-1 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
            <span className="text-sm font-medium text-blue-700 dark:text-blue-300">
              Meta: {metaDiaria} copos
            </span>
          </div>
          
          <button
            onClick={() => ajustarMeta(1)}
            className="p-1 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700"
            aria-label="Aumentar meta diária"
            disabled={metaDiaria >= 15}
          >
            <PlusCircle className="h-6 w-6" />
          </button>
        </div>
      </div>

      {/* Barra de progresso */}
      <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4 overflow-hidden">
        <div
          className="bg-blue-500 h-full transition-all duration-500 ease-out"
          style={{ width: `${progresso}%` }}
          role="progressbar"
          aria-valuenow={coposBebidos}
          aria-valuemin={0}
          aria-valuemax={metaDiaria}
        ></div>
      </div>

      <div className="flex items-center justify-between">
        <div className="text-sm text-gray-600 dark:text-gray-400">
          {coposBebidos} de {metaDiaria} copos
          {ultimoRegistro && (
            <span className="ml-2">
              (Último: {ultimoRegistro})
            </span>
          )}
        </div>
        
        <div className="text-blue-600 dark:text-blue-400">
          {progresso.toFixed(0)}%
        </div>
      </div>

      {/* Visualização dos copos */}
      <div className="flex flex-wrap gap-2 my-4 justify-center">
        {Array.from({ length: metaDiaria }).map((_, index) => (
          <div
            key={index}
            className={`w-12 h-16 flex items-center justify-center rounded-b-lg border border-t-0 ${
              index < coposBebidos
                ? 'bg-blue-100 border-blue-300 dark:bg-blue-900/30 dark:border-blue-700'
                : 'bg-gray-100 border-gray-300 dark:bg-gray-800 dark:border-gray-700'
            }`}
            aria-label={index < coposBebidos ? 'Copo bebido' : 'Copo não bebido'}
          >
            <Droplet
              className={`h-8 w-8 ${
                index < coposBebidos
                  ? 'text-blue-500 dark:text-blue-400'
                  : 'text-gray-400 dark:text-gray-600'
              }`}
            />
          </div>
        ))}
      </div>

      {/* Botões de ação */}
      <div className="flex justify-center space-x-4">
        <button
          onClick={adicionarCopo}
          disabled={coposBebidos >= metaDiaria}
          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          aria-label="Registrar um copo de água"
        >
          Registrar Copo
        </button>
        
        <button
          onClick={removerCopo}
          disabled={coposBebidos <= 0}
          className="px-4 py-2 bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 disabled:opacity-50 disabled:cursor-not-allowed"
          aria-label="Remover um copo de água"
        >
          Remover Copo
        </button>
      </div>

      {/* Dicas */}
      <div className="mt-6 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg text-sm text-blue-800 dark:text-blue-300">
        <h4 className="font-medium mb-1">Dicas de Hidratação:</h4>
        <ul className="list-disc pl-5 space-y-1">
          <li>Mantenha uma garrafa de água sempre visível</li>
          <li>Beba um copo ao acordar e antes de cada refeição</li>
          <li>Configure lembretes no celular a cada 1-2 horas</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="app/components/alimentacao/PlanejadorRefeicoes.tsx">
'use client'

import { useState } from 'react'
import { Clock, Plus, Save, Trash2 } from 'lucide-react'
import { useAlimentacaoStore } from '@/app/stores/alimentacaoStore'

type Refeicao = {
  id: string
  horario: string
  descricao: string
}

export function PlanejadorRefeicoes() {
  const { refeicoes, adicionarRefeicao, atualizarRefeicao, removerRefeicao } = useAlimentacaoStore()
  const [novaRefeicao, setNovaRefeicao] = useState({ horario: '', descricao: '' })
  const [editando, setEditando] = useState<string | null>(null)

  const handleAdicionarRefeicao = () => {
    if (!novaRefeicao.horario || !novaRefeicao.descricao) return

    adicionarRefeicao(novaRefeicao.horario, novaRefeicao.descricao)
    setNovaRefeicao({ horario: '', descricao: '' })
  }

  const iniciarEdicao = (id: string, horario: string, descricao: string) => {
    setEditando(id)
    setNovaRefeicao({ horario, descricao })
  }

  const salvarEdicao = () => {
    if (!editando || !novaRefeicao.horario || !novaRefeicao.descricao) return

    atualizarRefeicao(editando, novaRefeicao.horario, novaRefeicao.descricao)
    setEditando(null)
    setNovaRefeicao({ horario: '', descricao: '' })
  }

  const cancelarEdicao = () => {
    setEditando(null)
    setNovaRefeicao({ horario: '', descricao: '' })
  }

  return (
    <div className="space-y-4">
      <div className="space-y-2">
        {refeicoes.map((refeicao) => (
          <div
            key={refeicao.id}
            className="flex items-center p-3 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
          >
            <div className="flex items-center text-alimentacao-primary mr-3">
              <Clock className="h-5 w-5" />
            </div>
            
            {editando === refeicao.id ? (
              <>
                <input
                  type="time"
                  value={novaRefeicao.horario}
                  onChange={(e) => setNovaRefeicao({ ...novaRefeicao, horario: e.target.value })}
                  className="w-24 px-2 py-1 mr-2 border border-gray-300 dark:border-gray-600 rounded dark:bg-gray-700 dark:text-white"
                />
                <input
                  type="text"
                  value={novaRefeicao.descricao}
                  onChange={(e) => setNovaRefeicao({ ...novaRefeicao, descricao: e.target.value })}
                  className="flex-1 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded dark:bg-gray-700 dark:text-white"
                  placeholder="Descrição da refeição"
                />
                <button
                  onClick={salvarEdicao}
                  className="ml-2 p-1 text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300"
                  aria-label="Salvar edição"
                >
                  <Save className="h-5 w-5" />
                </button>
                <button
                  onClick={cancelarEdicao}
                  className="ml-1 p-1 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                  aria-label="Cancelar edição"
                >
                  <Trash2 className="h-5 w-5" />
                </button>
              </>
            ) : (
              <>
                <span className="font-medium text-gray-700 dark:text-gray-300 w-16">
                  {refeicao.horario}
                </span>
                <span className="flex-1 text-gray-900 dark:text-white">
                  {refeicao.descricao}
                </span>
                <button
                  onClick={() => iniciarEdicao(refeicao.id, refeicao.horario, refeicao.descricao)}
                  className="ml-2 p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                  aria-label="Editar refeição"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                </button>
                <button
                  onClick={() => removerRefeicao(refeicao.id)}
                  className="ml-1 p-1 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                  aria-label="Remover refeição"
                >
                  <Trash2 className="h-5 w-5" />
                </button>
              </>
            )}
          </div>
        ))}
      </div>

      <div className="mt-4 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
        <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Adicionar Nova Refeição
        </h3>
        <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
          <input
            type="time"
            value={novaRefeicao.horario}
            onChange={(e) => setNovaRefeicao({ ...novaRefeicao, horario: e.target.value })}
            className="w-full sm:w-24 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
          />
          <input
            type="text"
            value={novaRefeicao.descricao}
            onChange={(e) => setNovaRefeicao({ ...novaRefeicao, descricao: e.target.value })}
            className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
            placeholder="Descrição da refeição"
          />
          <button
            onClick={handleAdicionarRefeicao}
            disabled={!novaRefeicao.horario || !novaRefeicao.descricao}
            className="w-full sm:w-auto px-4 py-2 bg-alimentacao-primary text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Plus className="h-5 w-5 inline mr-1" />
            Adicionar
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/alimentacao/RegistroRefeicoes.tsx">
'use client'

import { useState } from 'react'
import { Camera, Plus, X } from 'lucide-react'
import { useAlimentacaoStore } from '@/app/stores/alimentacaoStore'
import Image from 'next/image'

// Ícones simples para tipos de refeição
const tiposRefeicao = [
  { id: 'cafe', emoji: '☕', nome: 'Café' },
  { id: 'fruta', emoji: '🍎', nome: 'Fruta' },
  { id: 'salada', emoji: '🥗', nome: 'Salada' },
  { id: 'proteina', emoji: '🍗', nome: 'Proteína' },
  { id: 'carboidrato', emoji: '🍚', nome: 'Carboidrato' },
  { id: 'sobremesa', emoji: '🍰', nome: 'Sobremesa' },
  { id: 'agua', emoji: '💧', nome: 'Água' },
]

export function RegistroRefeicoes() {
  const { registros, adicionarRegistro, removerRegistro } = useAlimentacaoStore()
  const [novoRegistro, setNovoRegistro] = useState({
    horario: '',
    descricao: '',
    tipoIcone: null as string | null,
    foto: null as string | null,
  })
  const [mostrarForm, setMostrarForm] = useState(false)

  const handleAdicionarRegistro = () => {
    if (!novoRegistro.horario || !novoRegistro.descricao) return
    
    adicionarRegistro(
      novoRegistro.horario,
      novoRegistro.descricao,
      novoRegistro.tipoIcone,
      novoRegistro.foto
    )
    
    setNovoRegistro({
      horario: '',
      descricao: '',
      tipoIcone: null,
      foto: null,
    })
    
    setMostrarForm(false)
  }

  const selecionarTipoIcone = (tipo: string) => {
    setNovoRegistro({
      ...novoRegistro,
      tipoIcone: novoRegistro.tipoIcone === tipo ? null : tipo,
    })
  }

  // Função simplificada para simular upload de foto
  const simularUploadFoto = () => {
    // Em um app real, aqui seria integrado com a câmera ou upload
    const fotoSimulada = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2YzZjRmNiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTQ5NDk0Ij5Gb3RvIGRhIHJlZmVpw6fDo288L3RleHQ+PC9zdmc+'
    setNovoRegistro({
      ...novoRegistro,
      foto: fotoSimulada,
    })
  }

  return (
    <div className="space-y-4">
      <div className="space-y-3">
        {registros.map((registro) => (
          <div
            key={registro.id}
            className="p-3 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
          >
            <div className="flex justify-between items-start">
              <div>
                <div className="flex items-center mb-2">
                  <span className="font-medium text-gray-700 dark:text-gray-300 mr-2">
                    {registro.horario}
                  </span>
                  <span className="text-gray-900 dark:text-white font-medium">
                    {registro.descricao}
                  </span>
                </div>
                
                {registro.tipoIcone && (
                  <div className="mb-2">
                    <span className="text-2xl" aria-label={`Tipo: ${tiposRefeicao.find(t => t.id === registro.tipoIcone)?.nome || ''}`}>
                      {tiposRefeicao.find(t => t.id === registro.tipoIcone)?.emoji}
                    </span>
                  </div>
                )}
              </div>
              
              <button
                onClick={() => removerRegistro(registro.id)}
                className="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                aria-label="Remover registro"
              >
                <X className="h-5 w-5" />
              </button>
            </div>
            
            {registro.foto && (
              <div className="mt-2">
                <Image 
                  src={registro.foto} 
                  alt="Imagem da refeição"
                  width={200}
                  height={200}
                  className="rounded-lg object-cover"
                />
              </div>
            )}
          </div>
        ))}
      </div>

      {mostrarForm ? (
        <div className="mt-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex justify-between items-center mb-3">
            <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Novo Registro
            </h3>
            <button
              onClick={() => setMostrarForm(false)}
              className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
              aria-label="Fechar formulário"
            >
              <X className="h-5 w-5" />
            </button>
          </div>
          
          <div className="space-y-3">
            <div className="flex flex-col sm:flex-row sm:space-x-2 space-y-2 sm:space-y-0">
              <input
                type="time"
                value={novoRegistro.horario}
                onChange={(e) => setNovoRegistro({ ...novoRegistro, horario: e.target.value })}
                className="w-full sm:w-32 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                aria-label="Horário da refeição"
              />
              <input
                type="text"
                value={novoRegistro.descricao}
                onChange={(e) => setNovoRegistro({ ...novoRegistro, descricao: e.target.value })}
                className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                placeholder="Descrição da refeição"
                aria-label="Descrição da refeição"
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Tipo de Refeição
              </label>
              <div className="flex flex-wrap gap-2">
                {tiposRefeicao.map((tipo) => (
                  <button
                    key={tipo.id}
                    onClick={() => selecionarTipoIcone(tipo.id)}
                    className={`w-10 h-10 flex items-center justify-center text-xl rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 ${
                      novoRegistro.tipoIcone === tipo.id
                        ? 'bg-alimentacao-light border-2 border-alimentacao-primary'
                        : 'bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600'
                    }`}
                    aria-label={tipo.nome}
                    aria-pressed={novoRegistro.tipoIcone === tipo.id}
                  >
                    {tipo.emoji}
                  </button>
                ))}
              </div>
            </div>
            
            <div>
              <button
                onClick={simularUploadFoto}
                className="flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                aria-label="Adicionar foto da refeição"
              >
                <Camera className="h-5 w-5 mr-2" />
                <span>Adicionar Foto</span>
              </button>
              
              {novoRegistro.foto && (
                <div className="mt-2 relative">
                  <Image 
                    src={novoRegistro.foto} 
                    alt="Imagem da refeição"
                    width={200}
                    height={200}
                    className="rounded-lg object-cover"
                  />
                  <button
                    onClick={() => setNovoRegistro({ ...novoRegistro, foto: null })}
                    className="absolute top-2 right-2 bg-red-600 text-white rounded-full p-1 hover:bg-red-700"
                    aria-label="Remover foto"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>
              )}
            </div>
            
            <div className="flex justify-end">
              <button
                onClick={handleAdicionarRegistro}
                disabled={!novoRegistro.horario || !novoRegistro.descricao}
                className="px-4 py-2 bg-alimentacao-primary text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
                aria-label="Salvar registro"
              >
                Salvar Registro
              </button>
            </div>
          </div>
        </div>
      ) : (
        <button
          onClick={() => setMostrarForm(true)}
          className="w-full py-2 flex items-center justify-center bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg border border-dashed border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300"
          aria-label="Adicionar novo registro de refeição"
        >
          <Plus className="h-5 w-5 mr-1" />
          <span>Adicionar Registro</span>
        </button>
      )}
    </div>
  )
}
</file>

<file path="app/components/autoconhecimento/EditorNotas.tsx">
'use client'

import { useState, useRef, useEffect } from 'react'
import { useAutoconhecimentoStore } from '@/app/stores/autoconhecimentoStore'
import { Button } from '@/app/components/ui/Button'
import { Textarea } from '@/app/components/ui/Textarea'
import { Input } from '@/app/components/ui/Input'
import { Badge } from '@/app/components/ui/Badge'
import { X, Image as ImageIcon, Save } from 'lucide-react'
import Image from 'next/image'

type EditorNotasProps = {
  id?: string
  secaoAtual: 'quem-sou' | 'meus-porques' | 'meus-padroes'
  onSave?: () => void
}

export function EditorNotas({ id, secaoAtual, onSave }: EditorNotasProps) {
  const { 
    notas, 
    adicionarNota, 
    atualizarNota, 
    adicionarTag, 
    removerTag,
    adicionarImagem,
    removerImagem,
    modoRefugio
  } = useAutoconhecimentoStore()
  
  const nota = id ? notas.find(n => n.id === id) : undefined
  
  const [titulo, setTitulo] = useState(nota?.titulo || '')
  const [conteudo, setConteudo] = useState(nota?.conteudo || '')
  const [tagInput, setTagInput] = useState('')
  const [tags, setTags] = useState<string[]>(nota?.tags || [])
  const [imagemUrl, setImagemUrl] = useState<string | undefined>(nota?.imagemUrl)
  const [mostrarOpcaoImagem, setMostrarOpcaoImagem] = useState(false)
  
  const tagInputRef = useRef<HTMLInputElement>(null)
  
  // Mapeia os títulos das seções para exibição
  const titulosSecoes = {
    'quem-sou': 'Quem sou',
    'meus-porques': 'Meus porquês',
    'meus-padroes': 'Meus padrões'
  }
  
  // Atualiza os estados quando a nota selecionada mudar
  useEffect(() => {
    if (nota) {
      setTitulo(nota.titulo)
      setConteudo(nota.conteudo)
      setTags(nota.tags)
      setImagemUrl(nota.imagemUrl)
    } else {
      setTitulo('')
      setConteudo('')
      setTags([])
      setImagemUrl(undefined)
    }
  }, [nota])
  
  // Função para adicionar uma tag
  const handleAdicionarTag = () => {
    if (tagInput.trim() && !tags.includes(tagInput.trim())) {
      const novaTag = tagInput.trim()
      setTags([...tags, novaTag])
      
      if (id) {
        adicionarTag(id, novaTag)
      }
      
      setTagInput('')
      tagInputRef.current?.focus()
    }
  }
  
  // Função para remover uma tag
  const handleRemoverTag = (tag: string) => {
    setTags(tags.filter(t => t !== tag))
    
    if (id) {
      removerTag(id, tag)
    }
  }
  
  // Função para adicionar/atualizar uma imagem
  const handleAdicionarImagem = () => {
    if (imagemUrl && id) {
      adicionarImagem(id, imagemUrl)
    }
    setMostrarOpcaoImagem(false)
  }
  
  // Função para remover uma imagem
  const handleRemoverImagem = () => {
    setImagemUrl(undefined)
    
    if (id) {
      removerImagem(id)
    }
    
    setMostrarOpcaoImagem(false)
  }
  
  // Função para salvar a nota
  const handleSalvar = () => {
    if (titulo.trim() && conteudo.trim()) {
      if (id) {
        // Atualizar nota existente
        atualizarNota(id, {
          titulo,
          conteudo,
          tags,
          imagemUrl
        })
      } else {
        // Criar nova nota
        adicionarNota(
          titulo,
          conteudo,
          secaoAtual,
          tags,
          imagemUrl
        )
      }
      
      if (onSave) {
        onSave()
      }
    }
  }
  
  // Verifica se estamos no modo refúgio para simplificar a interface
  const interfaceSimplificada = modoRefugio
  
  return (
    <div className={`space-y-4 transition-all duration-300 ${interfaceSimplificada ? 'opacity-90' : ''}`}>
      <div className="mb-4">
        <h3 className="text-lg font-medium text-gray-700 dark:text-gray-300 mb-1">
          {id ? `Editando nota em ${titulosSecoes[secaoAtual]}` : `Nova nota em ${titulosSecoes[secaoAtual]}`}
        </h3>
        <p className="text-sm text-gray-500 dark:text-gray-400">
          {interfaceSimplificada 
            ? 'Modo refúgio ativado - interface simplificada' 
            : 'Registre seus pensamentos, organize com tags e adicione âncoras visuais'}
        </p>
      </div>
      
      <Input
        type="text"
        value={titulo}
        onChange={(e) => setTitulo(e.target.value)}
        placeholder="Título da nota"
        className={`text-lg font-medium ${interfaceSimplificada ? 'border-autoconhecimento-primary' : ''}`}
        aria-label="Título da nota"
      />
      
      <Textarea
        value={conteudo}
        onChange={(e) => setConteudo(e.target.value)}
        placeholder="O que você quer registrar?"
        className={`min-h-[200px] ${interfaceSimplificada ? 'border-autoconhecimento-primary' : ''}`}
        aria-label="Conteúdo da nota"
      />
      
      {!interfaceSimplificada && (
        <>
          {/* Área de tags */}
          <div className="flex flex-wrap items-center gap-2">
            {tags.map((tag) => (
              <Badge 
                key={tag} 
                className="bg-autoconhecimento-light text-autoconhecimento-primary px-3 py-1 flex items-center space-x-1 hover:bg-autoconhecimento-primary hover:text-white transition-colors"
              >
                <span>{tag}</span>
                <button 
                  onClick={() => handleRemoverTag(tag)}
                  className="ml-1 rounded-full p-0.5"
                  aria-label={`Remover tag ${tag}`}
                >
                  <X size={14} />
                </button>
              </Badge>
            ))}
            
            <div className="flex">
              <Input
                ref={tagInputRef}
                type="text"
                value={tagInput}
                onChange={(e) => setTagInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault()
                    handleAdicionarTag()
                  }
                }}
                placeholder="Adicionar tag"
                className="text-sm w-32"
                aria-label="Adicionar nova tag"
              />
              <Button 
                onClick={handleAdicionarTag}
                className="ml-2 px-3 py-1 bg-autoconhecimento-light text-autoconhecimento-primary hover:bg-autoconhecimento-primary hover:text-white transition-colors"
                aria-label="Adicionar tag"
              >
                Adicionar
              </Button>
            </div>
          </div>
          
          {/* Área de imagem âncora */}
          <div className="mt-4">
            {imagemUrl ? (
              <div className="relative">
                <Image 
                  src={imagemUrl} 
                  alt="Imagem âncora" 
                  width={300}
                  height={200}
                  className="max-h-60 object-contain rounded-md border border-autoconhecimento-light"
                />
                <button
                  onClick={handleRemoverImagem}
                  className="absolute top-2 right-2 bg-white dark:bg-gray-800 rounded-full p-1 shadow-md"
                  aria-label="Remover imagem"
                >
                  <X size={18} className="text-red-500" />
                </button>
              </div>
            ) : (
              <>
                {mostrarOpcaoImagem ? (
                  <div className="flex items-center space-x-2">
                    <Input
                      type="text"
                      value={imagemUrl || ''}
                      onChange={(e) => setImagemUrl(e.target.value)}
                      placeholder="URL da imagem âncora"
                      className="text-sm flex-1"
                      aria-label="URL da imagem âncora"
                    />
                    <Button 
                      onClick={handleAdicionarImagem}
                      className="px-3 py-1 bg-autoconhecimento-primary text-white"
                      aria-label="Adicionar imagem"
                    >
                      Adicionar
                    </Button>
                    <Button 
                      onClick={() => setMostrarOpcaoImagem(false)}
                      className="px-3 py-1 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300"
                      aria-label="Cancelar"
                    >
                      Cancelar
                    </Button>
                  </div>
                ) : (
                  <Button 
                    onClick={() => setMostrarOpcaoImagem(true)}
                    className="flex items-center px-3 py-1 bg-autoconhecimento-light text-autoconhecimento-primary hover:bg-autoconhecimento-primary hover:text-white transition-colors"
                    aria-label="Adicionar imagem âncora"
                  >
                    <ImageIcon size={16} className="mr-1" />
                    <span>Adicionar Âncora Visual</span>
                  </Button>
                )}
              </>
            )}
          </div>
        </>
      )}
      
      <div className="flex justify-end">
        <Button 
          onClick={handleSalvar}
          className={`flex items-center px-4 py-2 ${
            interfaceSimplificada 
              ? 'bg-autoconhecimento-primary text-white' 
              : 'bg-autoconhecimento-primary text-white hover:bg-autoconhecimento-hover'
          }`}
          disabled={!titulo.trim() || !conteudo.trim()}
          aria-label="Salvar nota"
        >
          <Save size={16} className="mr-1" />
          <span>Salvar</span>
        </Button>
      </div>
    </div>
  )
}
</file>

<file path="app/components/autoconhecimento/ListaNotas.tsx">
'use client'

import { useState, useMemo } from 'react'
import { useAutoconhecimentoStore } from '@/app/stores/autoconhecimentoStore'
import { Card } from '@/app/components/ui/Card'
import { Badge } from '@/app/components/ui/Badge'
import { Input } from '@/app/components/ui/Input'
import { Search, Edit, Trash2, Image as ImageIcon } from 'lucide-react'

type ListaNotasProps = {
  secaoAtual: 'quem-sou' | 'meus-porques' | 'meus-padroes'
  onSelectNota: (id: string) => void
}

export function ListaNotas({ secaoAtual, onSelectNota }: ListaNotasProps) {
  const { notas, removerNota, buscarNotas, modoRefugio } = useAutoconhecimentoStore()
  const [termoBusca, setTermoBusca] = useState('')
  
  // Filtrar notas da seção atual
  const notasSecao = useMemo(() => {
    const notasFiltradas = termoBusca 
      ? buscarNotas(termoBusca) 
      : notas
    
    return notasFiltradas
      .filter(nota => nota.secao === secaoAtual)
      .sort((a, b) => new Date(b.dataAtualizacao).getTime() - new Date(a.dataAtualizacao).getTime())
  }, [notas, secaoAtual, termoBusca, buscarNotas])
  
  // Função para lidar com a exclusão
  const handleRemoverNota = (id: string, e: React.MouseEvent) => {
    e.stopPropagation()
    
    if (window.confirm('Tem certeza que deseja excluir esta nota?')) {
      removerNota(id)
    }
  }
  
  // Formatação de data
  const formatarData = (dataString: string) => {
    const data = new Date(dataString)
    return data.toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    })
  }
  
  // Verifica se estamos no modo refúgio para simplificar a interface
  const interfaceSimplificada = modoRefugio
  
  return (
    <div className="space-y-4">
      {/* Barra de busca */}
      <div className="relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={16} />
        <Input
          type="text"
          placeholder="Buscar notas..."
          value={termoBusca}
          onChange={(e) => setTermoBusca(e.target.value)}
          className="pl-10"
          aria-label="Buscar notas"
        />
      </div>
      
      {/* Lista de notas */}
      <div className="space-y-3">
        {notasSecao.length === 0 ? (
          <p className="text-center text-gray-500 dark:text-gray-400 py-4">
            {termoBusca 
              ? 'Nenhuma nota encontrada para esta busca' 
              : 'Nenhuma nota registrada nesta seção ainda'}
          </p>
        ) : (
          notasSecao.map((nota) => (
            <Card
              key={nota.id}
              className={`${
                interfaceSimplificada ? 'opacity-90' : ''
              }`}
            >
              <div 
                className="p-4 cursor-pointer hover:shadow-md transition-shadow border-l-4 border-l-autoconhecimento-primary"
                onClick={() => onSelectNota(nota.id)}
              >
                <div className="flex justify-between items-start">
                  <h4 className="text-lg font-medium text-gray-800 dark:text-white line-clamp-1">
                    {nota.titulo}
                  </h4>
                  
                  <div className="flex space-x-1">
                    {!interfaceSimplificada && (
                      <>
                        <button
                          className="p-1 text-gray-500 hover:text-autoconhecimento-primary transition-colors"
                          onClick={(e) => {
                            e.stopPropagation()
                            onSelectNota(nota.id)
                          }}
                          aria-label="Editar nota"
                        >
                          <Edit size={16} />
                        </button>
                        <button
                          className="p-1 text-gray-500 hover:text-red-500 transition-colors"
                          onClick={(e) => handleRemoverNota(nota.id, e)}
                          aria-label="Excluir nota"
                        >
                          <Trash2 size={16} />
                        </button>
                      </>
                    )}
                  </div>
                </div>
                
                <p className="text-gray-600 dark:text-gray-300 text-sm mt-2 line-clamp-2">
                  {nota.conteudo}
                </p>
                
                {!interfaceSimplificada && nota.tags.length > 0 && (
                  <div className="mt-3 flex flex-wrap gap-1">
                    {nota.tags.map((tag) => (
                      <Badge 
                        key={tag}
                        className="bg-autoconhecimento-light text-autoconhecimento-primary px-2 py-0.5 text-xs"
                      >
                        {tag}
                      </Badge>
                    ))}
                  </div>
                )}
                
                <div className="mt-2 flex justify-between items-center text-xs text-gray-500 dark:text-gray-400">
                  <span>Atualizado em {formatarData(nota.dataAtualizacao)}</span>
                  {nota.imagemUrl && (
                    <span className="flex items-center">
                      <ImageIcon size={12} className="mr-1" />
                      <span>Âncora visual</span>
                    </span>
                  )}
                </div>
              </div>
            </Card>
          ))
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/components/autoconhecimento/ModoRefugio.tsx">
'use client'

import { useAutoconhecimentoStore } from '@/app/stores/autoconhecimentoStore'
import { Button } from '@/app/components/ui/Button'
import { ShieldAlert, ShieldCheck } from 'lucide-react'

export function ModoRefugio() {
  const { modoRefugio, alternarModoRefugio } = useAutoconhecimentoStore()
  
  return (
    <div className={`fixed bottom-6 right-6 z-50 ${modoRefugio ? 'scale-110' : ''} transition-all duration-300`}>
      <Button
        onClick={alternarModoRefugio}
        className={`flex items-center p-3 rounded-full shadow-lg ${
          modoRefugio 
            ? 'bg-autoconhecimento-primary text-white' 
            : 'bg-white dark:bg-gray-800 text-autoconhecimento-primary dark:text-autoconhecimento-light'
        }`}
        aria-label={modoRefugio ? 'Desativar modo refúgio' : 'Ativar modo refúgio'}
      >
        {modoRefugio ? (
          <ShieldCheck className="h-6 w-6" />
        ) : (
          <ShieldAlert className="h-6 w-6" />
        )}
      </Button>
      
      {modoRefugio && (
        <div className="absolute -top-12 right-0 bg-autoconhecimento-primary text-white px-3 py-1 rounded text-sm whitespace-nowrap">
          Modo refúgio ativado
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/estudos/RegistroEstudos.tsx">
'use client'

import { useState } from 'react'
import { BookOpen, Plus, X, Edit, Trash, Check, Clock } from 'lucide-react'
import { useRegistroEstudosStore, SessaoEstudo } from '@/app/stores/registroEstudosStore'

export function RegistroEstudos() {
  const { sessoes, adicionarSessao, removerSessao, alternarCompletar, editarSessao } = useRegistroEstudosStore()
  
  const [novaSessao, setNovaSessao] = useState({
    titulo: '',
    descricao: '',
    duracao: 30,
  })
  
  const [editandoId, setEditandoId] = useState<string | null>(null)
  const [mostrarForm, setMostrarForm] = useState(false)

  const handleAdicionarSessao = () => {
    if (!novaSessao.titulo) return

    adicionarSessao(novaSessao)
    
    setNovaSessao({
      titulo: '',
      descricao: '',
      duracao: 30,
    })
    
    setMostrarForm(false)
  }

  const iniciarEdicao = (sessao: SessaoEstudo) => {
    setEditandoId(sessao.id)
    setNovaSessao({
      titulo: sessao.titulo,
      descricao: sessao.descricao,
      duracao: sessao.duracao,
    })
    setMostrarForm(true)
  }

  const salvarEdicao = () => {
    if (!editandoId || !novaSessao.titulo) return

    editarSessao(editandoId, novaSessao)
    
    setNovaSessao({
      titulo: '',
      descricao: '',
      duracao: 30,
    })
    
    setEditandoId(null)
    setMostrarForm(false)
  }

  const cancelarForm = () => {
    setNovaSessao({
      titulo: '',
      descricao: '',
      duracao: 30,
    })
    setEditandoId(null)
    setMostrarForm(false)
  }

  // Calcular estatísticas
  const sessoesCompletas = sessoes.filter((s) => s.completo).length
  const totalMinutos = sessoes.reduce((total, s) => total + (s.completo ? s.duracao : 0), 0)
  const totalHoras = Math.floor(totalMinutos / 60)
  const minutosRestantes = totalMinutos % 60

  return (
    <div className="space-y-4">
      {/* Estatísticas */}
      <div className="grid grid-cols-2 gap-4 mb-4">
        <div className="p-4 bg-estudos-light dark:bg-gray-800 rounded-lg border border-estudos-secondary/20 dark:border-estudos-dark/30">
          <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Sessões Completas
          </h4>
          <div className="flex items-center">
            <Check className="h-5 w-5 text-estudos-primary dark:text-estudos-secondary mr-2" />
            <span className="text-xl font-bold text-estudos-primary dark:text-estudos-secondary">
              {sessoesCompletas} / {sessoes.length}
            </span>
          </div>
        </div>
        
        <div className="p-4 bg-estudos-light dark:bg-gray-800 rounded-lg border border-estudos-secondary/20 dark:border-estudos-dark/30">
          <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Tempo Total
          </h4>
          <div className="flex items-center">
            <Clock className="h-5 w-5 text-estudos-primary dark:text-estudos-secondary mr-2" />
            <span className="text-xl font-bold text-estudos-primary dark:text-estudos-secondary">
              {totalHoras}h {minutosRestantes}min
            </span>
          </div>
        </div>
      </div>

      {/* Lista de Sessões */}
      <div className="space-y-3">
        {sessoes.map((sessao) => (
          <div
            key={sessao.id}
            className={`p-3 bg-white dark:bg-gray-800 rounded-lg border ${
              sessao.completo
                ? 'border-green-200 dark:border-green-900'
                : 'border-gray-200 dark:border-gray-700'
            }`}
          >
            <div className="flex items-start justify-between">
              <div className="flex items-start">
                <button
                  onClick={() => alternarCompletar(sessao.id)}
                  className={`mt-1 mr-3 flex-shrink-0 w-5 h-5 rounded-full border ${
                    sessao.completo
                      ? 'bg-green-500 border-green-500 text-white'
                      : 'border-gray-400 dark:border-gray-500'
                  } flex items-center justify-center`}
                  aria-label={sessao.completo ? 'Marcar como incompleto' : 'Marcar como completo'}
                >
                  {sessao.completo && <Check className="h-3 w-3" />}
                </button>
                
                <div>
                  <h3
                    className={`font-medium ${
                      sessao.completo
                        ? 'text-gray-500 dark:text-gray-400 line-through'
                        : 'text-gray-900 dark:text-white'
                    }`}
                  >
                    {sessao.titulo}
                  </h3>
                  
                  {sessao.descricao && (
                    <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                      {sessao.descricao}
                    </p>
                  )}
                  
                  <div className="flex items-center mt-2 text-xs text-gray-500 dark:text-gray-400">
                    <Clock className="h-3 w-3 mr-1" />
                    <span>{sessao.duracao} minutos</span>
                    <span className="mx-2">•</span>
                    <BookOpen className="h-3 w-3 mr-1" />
                    <span>{new Date(sessao.data).toLocaleDateString()}</span>
                  </div>
                </div>
              </div>
              
              <div className="flex space-x-1">
                <button
                  onClick={() => iniciarEdicao(sessao)}
                  className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                  aria-label="Editar sessão"
                >
                  <Edit className="h-4 w-4" />
                </button>
                
                <button
                  onClick={() => removerSessao(sessao.id)}
                  className="p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                  aria-label="Remover sessão"
                >
                  <Trash className="h-4 w-4" />
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Formulário */}
      {mostrarForm ? (
        <div className="mt-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex justify-between items-center mb-3">
            <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300">
              {editandoId ? 'Editar Sessão' : 'Nova Sessão de Estudo'}
            </h3>
            <button
              onClick={cancelarForm}
              className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
              aria-label="Fechar formulário"
            >
              <X className="h-5 w-5" />
            </button>
          </div>
          
          <div className="space-y-3">
            <div>
              <label htmlFor="titulo" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Título
              </label>
              <input
                type="text"
                id="titulo"
                value={novaSessao.titulo}
                onChange={(e) => setNovaSessao({ ...novaSessao, titulo: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                placeholder="Ex: Matemática - Álgebra"
              />
            </div>
            
            <div>
              <label htmlFor="descricao" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Descrição (opcional)
              </label>
              <textarea
                id="descricao"
                value={novaSessao.descricao}
                onChange={(e) => setNovaSessao({ ...novaSessao, descricao: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                placeholder="Detalhes sobre o que será estudado"
                rows={2}
              />
            </div>
            
            <div>
              <label htmlFor="duracao" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Duração (minutos)
              </label>
              <input
                type="number"
                id="duracao"
                min="5"
                max="240"
                value={novaSessao.duracao}
                onChange={(e) => setNovaSessao({ ...novaSessao, duracao: parseInt(e.target.value) || 30 })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
              />
            </div>
            
            <div className="flex justify-end pt-2">
              <button
                onClick={editandoId ? salvarEdicao : handleAdicionarSessao}
                disabled={!novaSessao.titulo}
                className="px-4 py-2 bg-estudos-primary text-white rounded-lg hover:bg-estudos-primary/90 focus:outline-none focus:ring-2 focus:ring-estudos-primary focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {editandoId ? 'Salvar Alterações' : 'Adicionar Sessão'}
              </button>
            </div>
          </div>
        </div>
      ) : (
        <button
          onClick={() => setMostrarForm(true)}
          className="w-full py-2 flex items-center justify-center bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg border border-dashed border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300"
          aria-label="Adicionar nova sessão de estudo"
        >
          <Plus className="h-5 w-5 mr-1" />
          <span>Adicionar Sessão de Estudo</span>
        </button>
      )}
    </div>
  )
}
</file>

<file path="app/components/estudos/TemporizadorPomodoro.tsx">
'use client'

import { useState, useEffect } from 'react'
import { Play, Pause, RefreshCw, Settings, X } from 'lucide-react'
import { usePomodoroStore } from '@/app/stores/pomodoroStore'

export function TemporizadorPomodoro() {
  const { configuracao, atualizarConfiguracao, ciclosCompletos, incrementarCiclosCompletos, resetarCiclosCompletos } = usePomodoroStore()
  
  const [isActive, setIsActive] = useState(false)
  const [isPaused, setIsPaused] = useState(true)
  const [time, setTime] = useState(configuracao.tempoFoco * 60) // tempo em segundos
  const [ciclo, setCiclo] = useState<'foco' | 'pausa' | 'longapausa'>('foco')
  const [showSettings, setShowSettings] = useState(false)
  const [configTemp, setConfigTemp] = useState(configuracao)

  useEffect(() => {
    // Reset timer quando a configuração mudar e o timer estiver parado
    if (!isActive || isPaused) {
      if (ciclo === 'foco') {
        setTime(configuracao.tempoFoco * 60);
      } else if (ciclo === 'pausa') {
        setTime(configuracao.tempoPausa * 60);
      } else {
        setTime(configuracao.tempoLongapausa * 60);
      }
    }
  }, [configuracao, isActive, isPaused, ciclo]);

  useEffect(() => {
    let interval: NodeJS.Timeout | null = null

    if (isActive && !isPaused) {
      interval = setInterval(() => {
        setTime((time) => {
          if (time <= 1) {
            // Tocar som de notificação
            if (typeof window !== 'undefined') {
              const audio = new Audio('/notification.mp3')
              audio.play().catch(() => {
                // Falha silenciosa se o navegador bloquear o áudio
                console.log('Notificação de áudio bloqueada pelo navegador')
              })
            }

            // Alternar entre ciclos
            if (ciclo === 'foco') {
              incrementarCiclosCompletos()
              
              // Verificar se deve ser uma pausa longa
              if ((ciclosCompletos + 1) % configuracao.ciclosAntesLongapausa === 0) {
                setCiclo('longapausa')
                return configuracao.tempoLongapausa * 60
              } else {
                setCiclo('pausa')
                return configuracao.tempoPausa * 60
              }
            } else {
              setCiclo('foco')
              return configuracao.tempoFoco * 60
            }
          }
          return time - 1
        })
      }, 1000)
    } else {
      interval && clearInterval(interval)
    }

    return () => {
      interval && clearInterval(interval)
    }
  }, [isActive, isPaused, ciclo, ciclosCompletos, configuracao, incrementarCiclosCompletos])

  const formatTime = () => {
    const minutes = Math.floor(time / 60)
    const seconds = time % 60
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
  }

  const handleStart = () => {
    setIsActive(true)
    setIsPaused(false)
  }

  const handlePause = () => {
    setIsPaused(true)
  }

  const handleReset = () => {
    setIsActive(false)
    setIsPaused(true)
    setCiclo('foco')
    setTime(configuracao.tempoFoco * 60)
    resetarCiclosCompletos()
  }

  const handleSettingsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setConfigTemp({
      ...configTemp,
      [name]: parseInt(value),
    })
  }

  const saveSettings = () => {
    atualizarConfiguracao(configTemp)
    setShowSettings(false)
  }

  // Determinar a cor com base no ciclo atual
  const cicloColor = 
    ciclo === 'foco' 
      ? 'text-estudos-primary dark:text-estudos-secondary' 
      : ciclo === 'pausa'
        ? 'text-green-600 dark:text-green-400'
        : 'text-blue-600 dark:text-blue-400'

  // Determinar a mensagem com base no ciclo atual
  const cicloMensagem = 
    ciclo === 'foco'
      ? 'Tempo de foco'
      : ciclo === 'pausa'
        ? 'Pausa curta'
        : 'Pausa longa'

  // Determinar a cor de fundo com base no ciclo atual
  const cicloBgColor = 
    ciclo === 'foco' 
      ? 'bg-estudos-light dark:bg-estudos-dark/30' 
      : ciclo === 'pausa'
        ? 'bg-green-100 dark:bg-green-900/30'
        : 'bg-blue-100 dark:bg-blue-900/30'

  return (
    <div className="flex flex-col items-center">
      <div className="text-center mb-4">
        <h3 className={`text-xl font-bold ${cicloColor}`}>{cicloMensagem}</h3>
        <p className="text-gray-600 dark:text-gray-400 text-sm">
          Ciclos completos: {ciclosCompletos}
        </p>
      </div>

      <div className={`text-4xl font-mono font-bold mb-6 ${cicloBgColor} text-gray-800 dark:text-white px-6 py-3 rounded-xl`}>
        {formatTime()}
      </div>

      <div className="flex space-x-4 mb-6">
        {isPaused ? (
          <button
            onClick={handleStart}
            className="flex items-center px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            aria-label="Iniciar temporizador"
          >
            <Play className="h-5 w-5 mr-1" />
            <span>Iniciar</span>
          </button>
        ) : (
          <button
            onClick={handlePause}
            className="flex items-center px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-amber-500"
            aria-label="Pausar temporizador"
          >
            <Pause className="h-5 w-5 mr-1" />
            <span>Pausar</span>
          </button>
        )}

        <button
          onClick={handleReset}
          className="flex items-center px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
          aria-label="Reiniciar temporizador"
        >
          <RefreshCw className="h-5 w-5 mr-1" />
          <span>Reiniciar</span>
        </button>

        <button
          onClick={() => {
            setConfigTemp(configuracao);
            setShowSettings(true);
          }}
          className="flex items-center px-4 py-2 bg-blue-100 dark:bg-blue-900/20 text-blue-800 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-800/30 focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-label="Configurações do temporizador"
        >
          <Settings className="h-5 w-5 mr-1" />
          <span>Ajustar</span>
        </button>
      </div>

      {/* Explicação do ciclo atual */}
      <div className={`p-3 ${cicloBgColor} rounded-lg text-sm text-gray-800 dark:text-gray-100 max-w-md`}>
        {ciclo === 'foco' ? (
          <p>Concentre-se em uma única tarefa. Evite distrações.</p>
        ) : ciclo === 'pausa' ? (
          <p>Faça uma pausa curta. Alongue-se ou beba água.</p>
        ) : (
          <p>Pausa longa! Levante-se e caminhe um pouco.</p>
        )}
      </div>

      {/* Modal de configurações */}
      {showSettings && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                Configurações do Temporizador
              </h3>
              <button
                onClick={() => setShowSettings(false)}
                className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                aria-label="Fechar configurações"
              >
                <X className="h-5 w-5" />
              </button>
            </div>

            <div className="space-y-4">
              <div>
                <label
                  htmlFor="tempoFoco"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Tempo de Foco (minutos)
                </label>
                <input
                  type="number"
                  id="tempoFoco"
                  name="tempoFoco"
                  min="1"
                  max="60"
                  value={configTemp.tempoFoco}
                  onChange={handleSettingsChange}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                />
              </div>

              <div>
                <label
                  htmlFor="tempoPausa"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Tempo de Pausa Curta (minutos)
                </label>
                <input
                  type="number"
                  id="tempoPausa"
                  name="tempoPausa"
                  min="1"
                  max="30"
                  value={configTemp.tempoPausa}
                  onChange={handleSettingsChange}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                />
              </div>

              <div>
                <label
                  htmlFor="tempoLongapausa"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Tempo de Pausa Longa (minutos)
                </label>
                <input
                  type="number"
                  id="tempoLongapausa"
                  name="tempoLongapausa"
                  min="5"
                  max="60"
                  value={configTemp.tempoLongapausa}
                  onChange={handleSettingsChange}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                />
              </div>

              <div>
                <label
                  htmlFor="ciclosAntesLongapausa"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Ciclos antes da Pausa Longa
                </label>
                <input
                  type="number"
                  id="ciclosAntesLongapausa"
                  name="ciclosAntesLongapausa"
                  min="1"
                  max="10"
                  value={configTemp.ciclosAntesLongapausa}
                  onChange={handleSettingsChange}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                />
              </div>

              <div className="pt-4 flex justify-end">
                <button
                  onClick={saveSettings}
                  className="px-4 py-2 bg-estudos-primary text-white rounded-lg hover:bg-estudos-primary/90 focus:outline-none focus:ring-2 focus:ring-estudos-primary focus:ring-offset-2"
                >
                  Salvar Configurações
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/financas/AdicionarDespesa.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useFinancasStore } from '@/app/stores/financasStore'
import { Check, CreditCard, PlusCircle } from 'lucide-react'

export function AdicionarDespesa() {
  const { categorias, adicionarTransacao } = useFinancasStore()
  
  const [descricao, setDescricao] = useState('')
  const [valor, setValor] = useState('')
  const [categoriaId, setCategoriaId] = useState('')
  const [mostrarFeedback, setMostrarFeedback] = useState(false)
  
  // Inicializar categoria se estiver vazia
  useEffect(() => {
    if (!categoriaId && categorias.length > 0) {
      setCategoriaId(categorias[0].id)
    }
  }, [categorias, categoriaId])
  
  const handleAdicionarDespesa = (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!descricao || !valor || parseFloat(valor) <= 0 || !categoriaId) return
    
    const hoje = new Date().toISOString().split('T')[0]
    
    adicionarTransacao(
      hoje,
      parseFloat(valor),
      descricao,
      categoriaId,
      'despesa'
    )
    
    // Mostrar feedback visual
    setMostrarFeedback(true)
    
    // Limpar formulário
    setDescricao('')
    setValor('')
    
    // Esconder feedback após 1.5 segundos
    setTimeout(() => {
      setMostrarFeedback(false)
    }, 1500)
  }
  
  return (
    <div className="space-y-4">
      {mostrarFeedback ? (
        <div className="text-center p-6 bg-green-50 dark:bg-green-900/20 rounded-lg">
          <div className="inline-flex items-center justify-center w-12 h-12 bg-green-100 dark:bg-green-800 rounded-full text-green-600 dark:text-green-300 mb-4">
            <Check className="h-6 w-6" />
          </div>
          <h3 className="text-lg font-medium text-green-600 dark:text-green-300">
            Despesa Registrada!
          </h3>
          <p className="text-sm text-green-500 dark:text-green-400 mt-1">
            Sua despesa foi adicionada com sucesso.
          </p>
        </div>
      ) : (
        <form onSubmit={handleAdicionarDespesa} className="space-y-4">
          <div>
            <label htmlFor="despesaDescricao" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              Descrição
            </label>
            <input
              id="despesaDescricao"
              type="text"
              value={descricao}
              onChange={e => setDescricao(e.target.value)}
              className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
              placeholder="Ex: Mercado"
              required
            />
          </div>
          
          <div>
            <label htmlFor="despesaValor" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              Valor (R$)
            </label>
            <input
              id="despesaValor"
              type="number"
              value={valor}
              onChange={e => setValor(e.target.value)}
              className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
              placeholder="0,00"
              min="0.01"
              step="0.01"
              required
            />
          </div>
          
          <div>
            <label htmlFor="despesaCategoria" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              Categoria
            </label>
            <div className="grid grid-cols-5 gap-2 mt-2">
              {categorias.map(categoria => (
                <button
                  key={categoria.id}
                  type="button"
                  onClick={() => setCategoriaId(categoria.id)}
                  className={`h-14 p-2 rounded-md flex flex-col items-center justify-center text-xs ${
                    categoriaId === categoria.id
                      ? 'ring-2 ring-offset-2 ring-gray-500'
                      : 'border border-gray-200 dark:border-gray-700'
                  }`}
                  style={{ backgroundColor: `${categoria.cor}20` }}
                  aria-label={`Selecionar categoria ${categoria.nome}`}
                >
                  <div 
                    className="w-6 h-6 rounded-full flex items-center justify-center mb-1"
                    style={{ backgroundColor: categoria.cor }}
                  >
                    <span className="text-white text-xs">
                      {/* Usar a primeira letra como ícone simplificado */}
                      {categoria.nome.charAt(0)}
                    </span>
                  </div>
                  <span className="truncate w-full text-center text-gray-900 dark:text-white">
                    {categoria.nome}
                  </span>
                </button>
              ))}
            </div>
          </div>
          
          <button
            type="submit"
            className="w-full px-4 py-3 mt-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 flex items-center justify-center"
          >
            <PlusCircle className="h-5 w-5 mr-2" />
            Adicionar Despesa
          </button>
        </form>
      )}
      
      {/* Dicas rápidas */}
      <div className="mt-4 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
        <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center mb-2">
          <CreditCard className="h-4 w-4 mr-1" /> 
          Dicas para registrar despesas
        </h3>
        <ul className="text-xs text-gray-500 dark:text-gray-400 space-y-1 ml-5 list-disc">
          <li>Registre despesas logo após realizá-las</li>
          <li>Use descrições curtas e específicas</li>
          <li>Categorize corretamente para melhor visualização</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="app/components/financas/CalendarioPagamentos.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useFinancasStore } from '@/app/stores/financasStore'
import { Calendar, Plus, Check, X, ChevronLeft, ChevronRight } from 'lucide-react'

export function CalendarioPagamentos() {
  const { 
    pagamentosRecorrentes, 
    categorias,
    adicionarPagamentoRecorrente, 
    removerPagamentoRecorrente,
    marcarPagamentoComoPago
  } = useFinancasStore()
  
  const [mostrarFormulario, setMostrarFormulario] = useState(false)
  const [novoPagamento, setNovoPagamento] = useState({
    descricao: '',
    valor: 0,
    dataVencimento: '1', // dia do mês
    categoriaId: ''
  })
  
  const [mesAtual, setMesAtual] = useState(new Date().getMonth())
  const [anoAtual, setAnoAtual] = useState(new Date().getFullYear())
  
  // Formatador para valores monetários
  const formatadorMoeda = new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  })
  
  // Obter os nomes dos meses em português
  const nomesMeses = [
    'Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
    'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
  ]
  
  // Avançar para o próximo mês
  const avancarMes = () => {
    if (mesAtual === 11) {
      setMesAtual(0)
      setAnoAtual(anoAtual + 1)
    } else {
      setMesAtual(mesAtual + 1)
    }
  }
  
  // Retroceder para o mês anterior
  const retrocederMes = () => {
    if (mesAtual === 0) {
      setMesAtual(11)
      setAnoAtual(anoAtual - 1)
    } else {
      setMesAtual(mesAtual - 1)
    }
  }
  
  // Verificar se um pagamento é do mês atual
  const isDoMesAtual = (dataVencimento: string) => {
    const dia = parseInt(dataVencimento)
    const data = new Date(anoAtual, mesAtual, dia)
    return data.getMonth() === mesAtual && data.getFullYear() === anoAtual
  }
  
  // Filtrar pagamentos do mês atual
  const pagamentosDoMes = pagamentosRecorrentes.filter(pagamento => {
    return isDoMesAtual(pagamento.dataVencimento)
  })
  
  // Ordenar pagamentos por dia
  const pagamentosOrdenados = [...pagamentosDoMes].sort((a, b) => {
    return parseInt(a.dataVencimento) - parseInt(b.dataVencimento)
  })
  
  // Adicionar novo pagamento recorrente
  const handleAdicionarPagamento = () => {
    if (
      !novoPagamento.descricao || 
      novoPagamento.valor <= 0 || 
      !novoPagamento.dataVencimento || 
      !novoPagamento.categoriaId
    ) return
    
    adicionarPagamentoRecorrente(
      novoPagamento.descricao,
      novoPagamento.valor,
      novoPagamento.dataVencimento,
      novoPagamento.categoriaId
    )
    
    setNovoPagamento({
      descricao: '',
      valor: 0,
      dataVencimento: '1',
      categoriaId: ''
    })
    
    setMostrarFormulario(false)
  }
  
  // Verificar se um dia já passou no mês atual
  const isDataPassada = (dia: number) => {
    const hoje = new Date()
    const dataPagamento = new Date(anoAtual, mesAtual, dia)
    return dataPagamento < hoje
  }
  
  // Verificar se é o dia atual
  const isHoje = (dia: number) => {
    const hoje = new Date()
    return (
      dia === hoje.getDate() && 
      mesAtual === hoje.getMonth() && 
      anoAtual === hoje.getFullYear()
    )
  }
  
  // Gerar opções para os dias do mês
  const diasDoMes = Array.from({ length: 31 }, (_, i) => i + 1)
  
  useEffect(() => {
    // Inicializar a categoriaId se estiver vazia e houver categorias disponíveis
    if (!novoPagamento.categoriaId && categorias.length > 0) {
      setNovoPagamento(prev => ({ ...prev, categoriaId: categorias[0].id }))
    }
  }, [categorias, novoPagamento.categoriaId])
  
  return (
    <div className="space-y-4">
      {/* Seletor de mês */}
      <div className="flex items-center justify-between mb-4">
        <button
          onClick={retrocederMes}
          className="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"
          aria-label="Mês anterior"
        >
          <ChevronLeft className="h-5 w-5" />
        </button>
        
        <h3 className="text-md font-medium text-gray-700 dark:text-gray-300">
          {nomesMeses[mesAtual]} {anoAtual}
        </h3>
        
        <button
          onClick={avancarMes}
          className="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"
          aria-label="Próximo mês"
        >
          <ChevronRight className="h-5 w-5" />
        </button>
      </div>
      
      {/* Lista de pagamentos do mês */}
      <div className="space-y-2">
        {pagamentosOrdenados.length > 0 ? (
          pagamentosOrdenados.map(pagamento => {
            const categoria = categorias.find(c => c.id === pagamento.categoriaId)
            const diaVencimento = parseInt(pagamento.dataVencimento)
            const dataPassada = isDataPassada(diaVencimento)
            const hoje = isHoje(diaVencimento)
            
            return (
              <div
                key={pagamento.id}
                className={`border rounded-lg overflow-hidden ${
                  pagamento.pago 
                    ? 'border-green-200 dark:border-green-800' 
                    : hoje 
                      ? 'border-yellow-200 dark:border-yellow-800' 
                      : dataPassada 
                        ? 'border-red-200 dark:border-red-800'
                        : 'border-gray-200 dark:border-gray-700'
                }`}
              >
                <div 
                  className={`flex items-center justify-between p-3 ${
                    pagamento.pago 
                      ? 'bg-green-50 dark:bg-green-900/20' 
                      : hoje 
                        ? 'bg-yellow-50 dark:bg-yellow-900/20' 
                        : dataPassada 
                          ? 'bg-red-50 dark:bg-red-900/20'
                          : 'bg-gray-50 dark:bg-gray-800'
                  }`}
                >
                  <div className="flex items-center">
                    <div className="w-8 h-8 flex items-center justify-center bg-white dark:bg-gray-700 rounded-full mr-3 font-medium">
                      {pagamento.dataVencimento}
                    </div>
                    <div>
                      <div className="font-medium text-gray-900 dark:text-white">
                        {pagamento.descricao}
                      </div>
                      <div className="text-sm text-gray-500 dark:text-gray-400">
                        {categoria?.nome || 'Categoria não especificada'}
                      </div>
                    </div>
                  </div>
                  
                  <div className="flex items-center">
                    <div className="font-medium text-gray-900 dark:text-white mr-3">
                      {formatadorMoeda.format(pagamento.valor)}
                    </div>
                    
                    <button
                      onClick={() => marcarPagamentoComoPago(pagamento.id, !pagamento.pago)}
                      className={`p-1 rounded-full ${
                        pagamento.pago 
                          ? 'bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-300' 
                          : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-300'
                      }`}
                      aria-label={pagamento.pago ? 'Marcar como não pago' : 'Marcar como pago'}
                    >
                      {pagamento.pago ? (
                        <Check className="h-5 w-5" />
                      ) : (
                        <X className="h-5 w-5" />
                      )}
                    </button>
                  </div>
                </div>
              </div>
            )
          })
        ) : (
          <div className="text-center py-6 text-gray-500 dark:text-gray-400">
            <Calendar className="h-10 w-10 mx-auto mb-2 opacity-50" />
            <p>Nenhum pagamento agendado para este mês</p>
          </div>
        )}
      </div>
      
      {/* Formulário para adicionar pagamento */}
      {mostrarFormulario ? (
        <div className="border border-gray-200 dark:border-gray-700 rounded-lg p-3 mt-3">
          <div className="space-y-3">
            <div>
              <label htmlFor="pagamentoDescricao" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Descrição
              </label>
              <input
                id="pagamentoDescricao"
                type="text"
                value={novoPagamento.descricao}
                onChange={e => setNovoPagamento({ ...novoPagamento, descricao: e.target.value })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                placeholder="Ex: Aluguel"
              />
            </div>
            
            <div>
              <label htmlFor="pagamentoValor" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Valor
              </label>
              <input
                id="pagamentoValor"
                type="number"
                value={novoPagamento.valor || ''}
                onChange={e => setNovoPagamento({ ...novoPagamento, valor: parseFloat(e.target.value) || 0 })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                placeholder="Valor"
                min="0.01"
                step="0.01"
              />
            </div>
            
            <div>
              <label htmlFor="pagamentoData" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Dia do Vencimento
              </label>
              <select
                id="pagamentoData"
                value={novoPagamento.dataVencimento}
                onChange={e => setNovoPagamento({ ...novoPagamento, dataVencimento: e.target.value })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
              >
                {diasDoMes.map(dia => (
                  <option key={dia} value={dia}>
                    {dia}
                  </option>
                ))}
              </select>
            </div>
            
            <div>
              <label htmlFor="pagamentoCategoria" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Categoria
              </label>
              <select
                id="pagamentoCategoria"
                value={novoPagamento.categoriaId}
                onChange={e => setNovoPagamento({ ...novoPagamento, categoriaId: e.target.value })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
              >
                {categorias.map(categoria => (
                  <option key={categoria.id} value={categoria.id}>
                    {categoria.nome}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex space-x-2 pt-2">
              <button
                onClick={handleAdicionarPagamento}
                className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                aria-label="Adicionar pagamento"
              >
                Adicionar
              </button>
              <button
                onClick={() => setMostrarFormulario(false)}
                className="flex-1 px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded hover:bg-gray-400 dark:hover:bg-gray-500"
                aria-label="Cancelar"
              >
                Cancelar
              </button>
            </div>
          </div>
        </div>
      ) : (
        <button
          onClick={() => setMostrarFormulario(true)}
          className="w-full px-4 py-2 flex items-center justify-center bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-md text-gray-700 dark:text-gray-300"
          aria-label="Adicionar novo pagamento"
        >
          <Plus className="h-5 w-5 mr-1" />
          Novo Pagamento
        </button>
      )}
    </div>
  )
}
</file>

<file path="app/components/financas/EnvelopesVirtuais.tsx">
'use client'

import { useState } from 'react'
import { useFinancasStore } from '@/app/stores/financasStore'
import { Plus, Edit2, Trash2, Save, X } from 'lucide-react'

export function EnvelopesVirtuais() {
  const { envelopes, adicionarEnvelope, atualizarEnvelope, removerEnvelope, registrarGastoEnvelope } = useFinancasStore()
  const [novoEnvelope, setNovoEnvelope] = useState({ nome: '', cor: '#2196F3', valorAlocado: 0 })
  const [valorGasto, setValorGasto] = useState<{id: string, valor: number} | null>(null)
  const [editando, setEditando] = useState<string | null>(null)
  const [mostrarFormulario, setMostrarFormulario] = useState(false)
  
  // Formatador para valores monetários
  const formatadorMoeda = new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  })
  
  // Lista de cores disponíveis para envelopes
  const coresPredefinidas = [
    '#FF5252', // Vermelho
    '#4CAF50', // Verde
    '#2196F3', // Azul
    '#FFC107', // Amarelo
    '#9C27B0', // Roxo
    '#FF9800', // Laranja
    '#00BCD4', // Ciano
  ]
  
  const handleAdicionarEnvelope = () => {
    if (!novoEnvelope.nome || novoEnvelope.valorAlocado <= 0) return
    
    adicionarEnvelope(
      novoEnvelope.nome,
      novoEnvelope.cor,
      novoEnvelope.valorAlocado
    )
    
    setNovoEnvelope({ nome: '', cor: '#2196F3', valorAlocado: 0 })
    setMostrarFormulario(false)
  }
  
  const iniciarEdicao = (id: string) => {
    const envelope = envelopes.find(e => e.id === id)
    if (envelope) {
      setNovoEnvelope({
        nome: envelope.nome,
        cor: envelope.cor,
        valorAlocado: envelope.valorAlocado
      })
      setEditando(id)
      setMostrarFormulario(true)
    }
  }
  
  const salvarEdicao = () => {
    if (!editando || !novoEnvelope.nome || novoEnvelope.valorAlocado <= 0) return
    
    atualizarEnvelope(
      editando,
      novoEnvelope.nome,
      novoEnvelope.cor,
      novoEnvelope.valorAlocado
    )
    
    setNovoEnvelope({ nome: '', cor: '#2196F3', valorAlocado: 0 })
    setEditando(null)
    setMostrarFormulario(false)
  }
  
  const cancelarForm = () => {
    setNovoEnvelope({ nome: '', cor: '#2196F3', valorAlocado: 0 })
    setEditando(null)
    setMostrarFormulario(false)
  }
  
  const handleRegistrarGasto = (id: string) => {
    if (!valorGasto || !valorGasto.valor || valorGasto.valor <= 0) return
    
    registrarGastoEnvelope(id, valorGasto.valor)
    setValorGasto(null)
  }
  
  return (
    <div className="space-y-4">
      {/* Visualização dos envelopes */}
      <div className="space-y-3">
        {envelopes.map(envelope => {
          const percentualUtilizado = envelope.valorAlocado > 0 
            ? (envelope.valorUtilizado / envelope.valorAlocado) * 100 
            : 0
          
          return (
            <div 
              key={envelope.id} 
              className="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden"
            >
              <div className="flex items-center justify-between p-3" style={{ backgroundColor: `${envelope.cor}20` }}>
                <div className="flex items-center">
                  <div 
                    className="w-4 h-4 mr-2 rounded-full" 
                    style={{ backgroundColor: envelope.cor }} 
                  />
                  <span className="font-medium text-gray-900 dark:text-white">
                    {envelope.nome}
                  </span>
                </div>
                <div className="flex space-x-1">
                  <button
                    onClick={() => iniciarEdicao(envelope.id)}
                    className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                    aria-label={`Editar envelope ${envelope.nome}`}
                  >
                    <Edit2 className="h-4 w-4" />
                  </button>
                  <button
                    onClick={() => removerEnvelope(envelope.id)}
                    className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                    aria-label={`Remover envelope ${envelope.nome}`}
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              </div>
              
              <div className="p-3">
                <div className="flex justify-between mb-1 text-sm">
                  <span>Utilizado: {formatadorMoeda.format(envelope.valorUtilizado)}</span>
                  <span>Total: {formatadorMoeda.format(envelope.valorAlocado)}</span>
                </div>
                
                {/* Barra de progresso */}
                <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-3">
                  <div 
                    className="h-2.5 rounded-full" 
                    style={{ 
                      width: `${Math.min(percentualUtilizado, 100)}%`, 
                      backgroundColor: envelope.cor 
                    }} 
                  />
                </div>
                
                {/* Registrar gasto */}
                {valorGasto && valorGasto.id === envelope.id ? (
                  <div className="flex mt-2">
                    <input
                      type="number"
                      value={valorGasto.valor || ''}
                      onChange={e => setValorGasto({ id: envelope.id, valor: parseFloat(e.target.value) || 0 })}
                      placeholder="Valor"
                      className="flex-1 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-l dark:bg-gray-700 dark:text-white text-sm"
                      min="0.01"
                      step="0.01"
                      aria-label="Valor do gasto"
                    />
                    <button
                      onClick={() => handleRegistrarGasto(envelope.id)}
                      className="px-2 py-1 bg-blue-500 text-white rounded-r hover:bg-blue-600 text-sm"
                      aria-label="Confirmar gasto"
                    >
                      <Save className="h-4 w-4" />
                    </button>
                    <button
                      onClick={() => setValorGasto(null)}
                      className="px-2 py-1 ml-1 bg-gray-500 text-white rounded hover:bg-gray-600 text-sm"
                      aria-label="Cancelar"
                    >
                      <X className="h-4 w-4" />
                    </button>
                  </div>
                ) : (
                  <button
                    onClick={() => setValorGasto({ id: envelope.id, valor: 0 })}
                    className="w-full mt-2 px-3 py-1 text-sm bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-md text-gray-600 dark:text-gray-300"
                    aria-label={`Registrar gasto no envelope ${envelope.nome}`}
                  >
                    Registrar Gasto
                  </button>
                )}
              </div>
            </div>
          )
        })}
      </div>
      
      {/* Formulário para adicionar ou editar envelope */}
      {mostrarFormulario ? (
        <div className="border border-gray-200 dark:border-gray-700 rounded-lg p-3">
          <div className="space-y-3">
            <div>
              <label htmlFor="envelopeNome" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Nome do Envelope
              </label>
              <input
                id="envelopeNome"
                type="text"
                value={novoEnvelope.nome}
                onChange={e => setNovoEnvelope({ ...novoEnvelope, nome: e.target.value })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                placeholder="Ex: Emergências"
              />
            </div>
            
            <div>
              <label htmlFor="envelopeValor" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Valor Alocado
              </label>
              <input
                id="envelopeValor"
                type="number"
                value={novoEnvelope.valorAlocado || ''}
                onChange={e => setNovoEnvelope({ ...novoEnvelope, valorAlocado: parseFloat(e.target.value) || 0 })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                placeholder="Valor"
                min="0.01"
                step="0.01"
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Cor do Envelope
              </label>
              <div className="flex flex-wrap gap-2">
                {coresPredefinidas.map(cor => (
                  <button
                    key={cor}
                    type="button"
                    onClick={() => setNovoEnvelope({ ...novoEnvelope, cor })}
                    className={`w-8 h-8 rounded-full ${
                      novoEnvelope.cor === cor ? 'ring-2 ring-offset-2 ring-gray-500' : ''
                    }`}
                    style={{ backgroundColor: cor }}
                    aria-label={`Selecionar cor ${cor}`}
                  />
                ))}
              </div>
            </div>
            
            <div className="flex space-x-2 pt-2">
              {editando ? (
                <>
                  <button
                    onClick={salvarEdicao}
                    className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    aria-label="Salvar alterações no envelope"
                  >
                    Salvar
                  </button>
                  <button
                    onClick={cancelarForm}
                    className="flex-1 px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded hover:bg-gray-400 dark:hover:bg-gray-500"
                    aria-label="Cancelar edição"
                  >
                    Cancelar
                  </button>
                </>
              ) : (
                <>
                  <button
                    onClick={handleAdicionarEnvelope}
                    className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    aria-label="Adicionar envelope"
                  >
                    Adicionar
                  </button>
                  <button
                    onClick={cancelarForm}
                    className="flex-1 px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded hover:bg-gray-400 dark:hover:bg-gray-500"
                    aria-label="Cancelar"
                  >
                    Cancelar
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      ) : (
        <button
          onClick={() => setMostrarFormulario(true)}
          className="w-full px-4 py-2 flex items-center justify-center bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-md text-gray-700 dark:text-gray-300"
          aria-label="Adicionar novo envelope"
        >
          <Plus className="h-5 w-5 mr-1" />
          Novo Envelope
        </button>
      )}
    </div>
  )
}
</file>

<file path="app/components/financas/RastreadorGastos.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useFinancasStore } from '@/app/stores/financasStore'
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts'
import { Home, ShoppingCart, Utensils, Car, Heart, Music } from 'lucide-react'

// Mapeamento de nomes de ícones para componentes Lucide
const iconesMapeados: Record<string, React.ReactNode> = {
  'home': <Home className="h-5 w-5" />,
  'shopping-cart': <ShoppingCart className="h-5 w-5" />,
  'utensils': <Utensils className="h-5 w-5" />,
  'car': <Car className="h-5 w-5" />,
  'heart': <Heart className="h-5 w-5" />,
  'music': <Music className="h-5 w-5" />,
}

export function RastreadorGastos() {
  const { categorias, transacoes } = useFinancasStore()
  const [dadosGrafico, setDadosGrafico] = useState<Array<{ name: string; value: number; cor: string }>>([])
  const [totalGastos, setTotalGastos] = useState(0)
  
  // Calcular os dados do gráfico quando as transações ou categorias mudarem
  useEffect(() => {
    const despesas = transacoes.filter(t => t.tipo === 'despesa')
    const total = despesas.reduce((acc, t) => acc + t.valor, 0)
    setTotalGastos(total)
    
    // Agrupar transações por categoria e calcular o total por categoria
    const gastosPorCategoria: Record<string, number> = {}
    
    despesas.forEach(transacao => {
      if (!gastosPorCategoria[transacao.categoriaId]) {
        gastosPorCategoria[transacao.categoriaId] = 0
      }
      gastosPorCategoria[transacao.categoriaId] += transacao.valor
    })
    
    // Preparar os dados para o gráfico
    const dados = Object.entries(gastosPorCategoria).map(([categoriaId, valor]) => {
      const categoria = categorias.find(c => c.id === categoriaId)
      return {
        name: categoria ? categoria.nome : 'Outros',
        value: valor,
        cor: categoria ? categoria.cor : '#CCCCCC'
      }
    })
    
    setDadosGrafico(dados)
  }, [transacoes, categorias])
  
  // Formatador para valores monetários
  const formatadorMoeda = new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  })
  
  // Formatador para porcentagens
  const formatadorPorcentagem = new Intl.NumberFormat('pt-BR', {
    style: 'percent',
    minimumFractionDigits: 1,
    maximumFractionDigits: 1,
  })
  
  // Custom tooltip para o gráfico
  const CustomTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload
      const percentual = data.value / totalGastos
      
      return (
        <div className="bg-white dark:bg-gray-800 p-2 border border-gray-200 dark:border-gray-700 rounded shadow-md">
          <p className="font-medium">{data.name}</p>
          <p className="text-sm">{formatadorMoeda.format(data.value)}</p>
          <p className="text-xs text-gray-500 dark:text-gray-400">
            {formatadorPorcentagem.format(percentual)}
          </p>
        </div>
      )
    }
    
    return null
  }
  
  return (
    <div className="space-y-4">
      {/* Exibir o gráfico apenas se houver dados */}
      {dadosGrafico.length > 0 ? (
        <div className="w-full h-64">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={dadosGrafico}
                cx="50%"
                cy="50%"
                labelLine={false}
                outerRadius={80}
                fill="#8884d8"
                dataKey="value"
              >
                {dadosGrafico.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.cor} />
                ))}
              </Pie>
              <Tooltip content={<CustomTooltip />} />
            </PieChart>
          </ResponsiveContainer>
        </div>
      ) : (
        <div className="flex flex-col items-center justify-center h-40 text-gray-500 dark:text-gray-400">
          <p>Sem despesas registradas</p>
          <p className="text-sm">Adicione despesas para visualizar o gráfico</p>
        </div>
      )}
      
      {/* Lista de categorias com valores */}
      <div className="space-y-2 mt-4">
        <h3 className="text-sm font-medium text-gray-900 dark:text-white mb-2">
          Total de Gastos: {formatadorMoeda.format(totalGastos)}
        </h3>
        
        {categorias.map(categoria => {
          const dadoCategoria = dadosGrafico.find(d => d.name === categoria.nome)
          const valorCategoria = dadoCategoria ? dadoCategoria.value : 0
          const percentual = totalGastos > 0 ? valorCategoria / totalGastos : 0
          
          return (
            <div 
              key={categoria.id}
              className="flex items-center justify-between p-2 rounded-lg"
              style={{ backgroundColor: `${categoria.cor}20` }}
            >
              <div className="flex items-center">
                <div className="p-1 rounded-full mr-2" style={{ backgroundColor: categoria.cor }}>
                  <span className="text-white">
                    {iconesMapeados[categoria.icone] || <ShoppingCart className="h-5 w-5" />}
                  </span>
                </div>
                <span className="font-medium text-gray-900 dark:text-white">
                  {categoria.nome}
                </span>
              </div>
              <div className="text-right">
                <div className="font-medium text-gray-900 dark:text-white">
                  {formatadorMoeda.format(valorCategoria)}
                </div>
                <div className="text-xs text-gray-500 dark:text-gray-400">
                  {formatadorPorcentagem.format(percentual)}
                </div>
              </div>
            </div>
          )
        })}
      </div>
    </div>
  )
}
</file>

<file path="app/components/hiperfocos/ConversorInteresses.tsx">
'use client'

import { useState, useRef, FormEvent } from 'react'
import { Rocket, CheckCircle, PlusCircle, X, Save } from 'lucide-react'
import { useHiperfocosStore, CORES_HIPERFOCOS } from '../../stores/hiperfocosStore'

export function ConversorInteresses() {
  const { adicionarHiperfoco, adicionarTarefa } = useHiperfocosStore()
  
  const [formData, setFormData] = useState({
    titulo: '',
    descricao: '',
    corSelecionada: CORES_HIPERFOCOS[0],
    tempoLimite: '',
    novasTarefas: [''] // Iniciar com um campo vazio
  })
  
  const [feedback, setFeedback] = useState<{
    tipo: 'sucesso' | 'erro',
    mensagem: string
  } | null>(null)
  
  const formRef = useRef<HTMLFormElement>(null)
  
  // Função para adicionar mais campos de tarefas
  const adicionarCampoTarefa = () => {
    setFormData({
      ...formData,
      novasTarefas: [...formData.novasTarefas, '']
    })
  }
  
  // Função para atualizar uma tarefa específica
  const atualizarTarefa = (index: number, valor: string) => {
    const tarefasAtualizadas = [...formData.novasTarefas]
    tarefasAtualizadas[index] = valor
    
    setFormData({
      ...formData,
      novasTarefas: tarefasAtualizadas
    })
  }
  
  // Função para remover uma tarefa
  const removerTarefa = (index: number) => {
    const tarefasAtualizadas = formData.novasTarefas.filter((_, i) => i !== index)
    
    setFormData({
      ...formData,
      novasTarefas: tarefasAtualizadas
    })
  }
  
  // Função para lidar com o envio do formulário
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    
    // Validação
    if (!formData.titulo) {
      setFeedback({
        tipo: 'erro',
        mensagem: 'O título do hiperfoco é obrigatório'
      })
      return
    }
    
    if (formData.novasTarefas.filter(t => t.trim() !== '').length === 0) {
      setFeedback({
        tipo: 'erro',
        mensagem: 'Adicione pelo menos uma tarefa'
      })
      return
    }
    
    try {
      // Criar um novo hiperfoco
      const tempoLimiteInt = formData.tempoLimite ? parseInt(formData.tempoLimite) : undefined
      const hiperfocoId = adicionarHiperfoco(
        formData.titulo,
        formData.descricao,
        formData.corSelecionada,
        tempoLimiteInt
      )
      
      // Adicionar as tarefas ao hiperfoco
      formData.novasTarefas
        .filter(tarefa => tarefa.trim() !== '')
        .forEach(tarefa => {
          adicionarTarefa(hiperfocoId, tarefa)
        })
      
      // Feedback de sucesso
      setFeedback({
        tipo: 'sucesso',
        mensagem: 'Hiperfoco criado com sucesso!'
      })
      
      // Limpar o formulário
      setFormData({
        titulo: '',
        descricao: '',
        corSelecionada: CORES_HIPERFOCOS[0],
        tempoLimite: '',
        novasTarefas: ['']
      })
      
      // Timer para remover o feedback
      setTimeout(() => {
        setFeedback(null)
      }, 3000)
    } catch (error) {
      setFeedback({
        tipo: 'erro',
        mensagem: 'Ocorreu um erro ao criar o hiperfoco'
      })
    }
  }
  
  return (
    <div>
      <div className="flex items-center mb-4">
        <Rocket className="h-6 w-6 text-hiperfocos-primary mr-2" aria-hidden="true" />
        <h2 className="text-xl font-semibold text-gray-800 dark:text-white">
          Conversor de Interesses
        </h2>
      </div>
      
      <p className="text-gray-600 dark:text-gray-300 mb-6">
        Transforme um interesse intenso em um projeto estruturado com tarefas claras e objetivas.
      </p>
      
      {feedback && (
        <div 
          className={`mb-4 p-3 rounded-md ${
            feedback.tipo === 'sucesso' 
              ? 'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100' 
              : 'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100'
          }`}
          role="alert"
        >
          {feedback.tipo === 'sucesso' ? (
            <CheckCircle className="h-5 w-5 inline mr-2" aria-hidden="true" />
          ) : (
            <X className="h-5 w-5 inline mr-2" aria-hidden="true" />
          )}
          {feedback.mensagem}
        </div>
      )}
      
      <form ref={formRef} onSubmit={handleSubmit} className="space-y-6">
        {/* Informações básicas do hiperfoco */}
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div>
            <label 
              htmlFor="titulo" 
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Título do Interesse/Hiperfoco *
            </label>
            <input
              type="text"
              id="titulo"
              name="titulo"
              value={formData.titulo}
              onChange={(e) => setFormData({ ...formData, titulo: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              aria-required="true"
            />
          </div>
          
          <div>
            <label 
              htmlFor="tempoLimite" 
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Tempo Limite (em minutos, opcional)
            </label>
            <input
              type="number"
              id="tempoLimite"
              name="tempoLimite"
              value={formData.tempoLimite}
              onChange={(e) => setFormData({ ...formData, tempoLimite: e.target.value })}
              min="1"
              placeholder="Ex: 60"
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            />
          </div>
        </div>
        
        <div>
          <label 
            htmlFor="descricao" 
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            Descrição
          </label>
          <textarea
            id="descricao"
            name="descricao"
            value={formData.descricao}
            onChange={(e) => setFormData({ ...formData, descricao: e.target.value })}
            rows={3}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            placeholder="Descreva seu interesse ou hiperfoco"
          />
        </div>
        
        {/* Seleção de cor */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            Cor do Hiperfoco
          </label>
          <div className="flex gap-2 flex-wrap">
            {CORES_HIPERFOCOS.map((cor) => (
              <button
                key={cor}
                type="button"
                onClick={() => setFormData({ ...formData, corSelecionada: cor })}
                className={`w-8 h-8 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary ${
                  formData.corSelecionada === cor ? 'ring-2 ring-offset-2 ring-hiperfocos-primary' : ''
                }`}
                style={{ backgroundColor: cor }}
                aria-label={`Cor ${cor}`}
                aria-pressed={formData.corSelecionada === cor}
              />
            ))}
          </div>
        </div>
        
        {/* Lista de tarefas */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            Decomposição em Tarefas *
          </label>
          
          <div className="space-y-3">
            {formData.novasTarefas.map((tarefa, index) => (
              <div key={index} className="flex gap-2">
                <input
                  type="text"
                  value={tarefa}
                  onChange={(e) => atualizarTarefa(index, e.target.value)}
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  placeholder={`Tarefa ${index + 1}`}
                  aria-label={`Tarefa ${index + 1}`}
                />
                
                <button
                  type="button"
                  onClick={() => removerTarefa(index)}
                  className="p-2 text-gray-500 rounded-md hover:bg-gray-100 hover:text-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
                  aria-label="Remover tarefa"
                  disabled={formData.novasTarefas.length <= 1}
                >
                  <X className="h-5 w-5" aria-hidden="true" />
                </button>
              </div>
            ))}
          </div>
          
          <button
            type="button"
            onClick={adicionarCampoTarefa}
            className="mt-3 flex items-center text-hiperfocos-primary hover:text-hiperfocos-secondary"
            aria-label="Adicionar mais uma tarefa"
          >
            <PlusCircle className="h-5 w-5 mr-1" aria-hidden="true" />
            Adicionar mais uma tarefa
          </button>
        </div>
        
        {/* Botão de envio */}
        <div className="flex justify-end">
          <button
            type="submit"
            className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-hiperfocos-primary hover:bg-hiperfocos-secondary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary"
            aria-label="Converter interesse em hiperfoco"
          >
            <Save className="h-5 w-5 mr-2" aria-hidden="true" />
            Converter em Hiperfoco
          </button>
        </div>
      </form>
    </div>
  )
}
</file>

<file path="app/components/hiperfocos/SistemaAlternancia.tsx">
'use client'

import { useState, FormEvent } from 'react'
import { ArrowRightCircle, Clock, Plus, Check, AlertCircle, RefreshCcw } from 'lucide-react'
import { useHiperfocosStore, type SessaoAlternancia, type Hiperfoco } from '../../stores/hiperfocosStore'
import { format, parseISO, isAfter, addMinutes } from 'date-fns'
import { ptBR } from 'date-fns/locale'

export function SistemaAlternancia() {
  const { 
    hiperfocos, 
    sessoes, 
    adicionarSessao, 
    alternarHiperfoco, 
    concluirSessao, 
    removerSessao 
  } = useHiperfocosStore()
  
  const [novaAlternancia, setNovaAlternancia] = useState({
    titulo: '',
    hiperfocoId: '',
    tempoEstimado: ''
  })
  
  const [mostrarFormulario, setMostrarFormulario] = useState(false)
  const [feedbackMsg, setFeedbackMsg] = useState<string | null>(null)
  
  // Obter sessões ativas (não concluídas)
  const sessoesAtivas = sessoes.filter(sessao => !sessao.concluida)
  
  // Manipular o envio do formulário
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    
    if (!novaAlternancia.titulo || !novaAlternancia.hiperfocoId || !novaAlternancia.tempoEstimado) {
      setFeedbackMsg('Por favor, preencha todos os campos')
      return
    }
    
    const tempoEstimadoInt = parseInt(novaAlternancia.tempoEstimado)
    if (isNaN(tempoEstimadoInt) || tempoEstimadoInt <= 0) {
      setFeedbackMsg('Tempo estimado inválido')
      return
    }
    
    try {
      adicionarSessao(
        novaAlternancia.titulo,
        novaAlternancia.hiperfocoId,
        tempoEstimadoInt
      )
      
      // Limpar o formulário
      setNovaAlternancia({
        titulo: '',
        hiperfocoId: '',
        tempoEstimado: ''
      })
      
      setMostrarFormulario(false)
      setFeedbackMsg(null)
    } catch (error) {
      setFeedbackMsg('Erro ao criar a sessão')
    }
  }
  
  // Obter o nome de um hiperfoco pelo ID
  const getHiperfocoNome = (id: string | null): string => {
    if (!id) return 'Nenhum'
    
    const hiperfoco = hiperfocos.find(h => h.id === id)
    return hiperfoco ? hiperfoco.titulo : 'Desconhecido'
  }
  
  // Verificar se uma sessão está atrasada
  const isSessionOverdue = (sessao: SessaoAlternancia): boolean => {
    const inicioDate = parseISO(sessao.tempoInicio)
    const limiteDate = addMinutes(inicioDate, sessao.duracaoEstimada)
    return isAfter(new Date(), limiteDate)
  }
  
  // Alternar para um novo hiperfoco
  const handleAlternarHiperfoco = (sessaoId: string, hiperfocoId: string) => {
    alternarHiperfoco(sessaoId, hiperfocoId)
  }
  
  return (
    <div>
      <div className="flex items-center mb-4">
        <RefreshCcw className="h-6 w-6 text-hiperfocos-primary mr-2" aria-hidden="true" />
        <h2 className="text-xl font-semibold text-gray-800 dark:text-white">
          Sistema de Alternância
        </h2>
      </div>
      
      <p className="text-gray-600 dark:text-gray-300 mb-6">
        Gerencie transições entre diferentes hiperfocos para reduzir o impacto das mudanças de contexto.
      </p>
      
      {/* Mostrar feedback se houver */}
      {feedbackMsg && (
        <div className="bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100 p-3 rounded-md mb-4">
          <AlertCircle className="h-5 w-5 inline mr-2" aria-hidden="true" />
          {feedbackMsg}
        </div>
      )}
      
      {/* Sessões ativas */}
      {sessoesAtivas.length > 0 ? (
        <div className="space-y-4 mb-6">
          <h3 className="text-lg font-medium text-gray-800 dark:text-white">
            Sessões de Alternância Ativas
          </h3>
          
          {sessoesAtivas.map((sessao) => {
            const isOverdue = isSessionOverdue(sessao)
            const hiperfocoAtual = hiperfocos.find(h => h.id === sessao.hiperfocoAtual)
            
            return (
              <div 
                key={sessao.id} 
                className={`bg-white dark:bg-gray-700 rounded-lg shadow-sm p-4 border-l-4 ${
                  isOverdue ? 'border-amber-500' : 'border-hiperfocos-primary'
                }`}
              >
                <div className="flex justify-between items-start mb-3">
                  <div>
                    <h4 className="font-medium text-gray-800 dark:text-white">
                      {sessao.titulo}
                    </h4>
                    <p className="text-sm text-gray-500 dark:text-gray-400">
                      <Clock className="h-4 w-4 inline mr-1" aria-hidden="true" />
                      Iniciado: {format(parseISO(sessao.tempoInicio), "dd 'de' MMMM', às' HH:mm", { locale: ptBR })}
                    </p>
                  </div>
                  
                  <div className="flex space-x-2">
                    <button
                      onClick={() => concluirSessao(sessao.id)}
                      className="p-1.5 text-green-600 hover:bg-green-50 rounded-md dark:text-green-400 dark:hover:bg-gray-600"
                      aria-label="Marcar como concluída"
                    >
                      <Check className="h-5 w-5" aria-hidden="true" />
                    </button>
                  </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Hiperfoco atual */}
                  <div className="bg-gray-50 dark:bg-gray-800 p-3 rounded-md">
                    <span className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">
                      Hiperfoco Atual
                    </span>
                    <div 
                      className="px-3 py-1.5 rounded-md text-sm font-medium"
                      style={{ 
                        backgroundColor: hiperfocoAtual ? `${hiperfocoAtual.cor}20` : 'transparent',
                        color: hiperfocoAtual ? hiperfocoAtual.cor : 'inherit' 
                      }}
                    >
                      {getHiperfocoNome(sessao.hiperfocoAtual)}
                    </div>
                  </div>
                  
                  {/* Alternância */}
                  <div className="bg-gray-50 dark:bg-gray-800 p-3 rounded-md">
                    <span className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">
                      Alternar para
                    </span>
                    <select
                      className="w-full px-3 py-1.5 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white text-sm"
                      value=""
                      onChange={(e) => handleAlternarHiperfoco(sessao.id, e.target.value)}
                      aria-label="Selecionar novo hiperfoco"
                    >
                      <option value="" disabled>Escolha um hiperfoco</option>
                      {hiperfocos
                        .filter(h => h.id !== sessao.hiperfocoAtual)
                        .map(hiperfoco => (
                          <option key={hiperfoco.id} value={hiperfoco.id}>
                            {hiperfoco.titulo}
                          </option>
                        ))
                      }
                    </select>
                  </div>
                </div>
                
                {/* Hiperfoco anterior (se houver) */}
                {sessao.hiperfocoAnterior && (
                  <div className="mt-3 text-sm text-gray-500 dark:text-gray-400">
                    <ArrowRightCircle className="h-4 w-4 inline mr-1" aria-hidden="true" />
                    Alternou de: {getHiperfocoNome(sessao.hiperfocoAnterior)}
                  </div>
                )}
                
                {/* Mostrar alerta se estiver atrasado */}
                {isOverdue && (
                  <div className="mt-3 text-sm text-amber-500 dark:text-amber-400">
                    <AlertCircle className="h-4 w-4 inline mr-1" aria-hidden="true" />
                    Tempo estimado excedido! ({sessao.duracaoEstimada} minutos)
                  </div>
                )}
              </div>
            )
          })}
        </div>
      ) : (
        <div className="text-center py-8 text-gray-500 dark:text-gray-400 mb-6">
          <p>Nenhuma sessão de alternância ativa no momento.</p>
        </div>
      )}
      
      {/* Formulário para adicionar nova sessão */}
      {mostrarFormulario ? (
        <form onSubmit={handleSubmit} className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg mb-6">
          <h3 className="text-lg font-medium text-gray-800 dark:text-white mb-4">
            Nova Sessão de Alternância
          </h3>
          
          <div className="space-y-4">
            <div>
              <label 
                htmlFor="titulo" 
                className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
              >
                Título da Sessão
              </label>
              <input
                type="text"
                id="titulo"
                value={novaAlternancia.titulo}
                onChange={(e) => setNovaAlternancia({ ...novaAlternancia, titulo: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                placeholder="Ex: Sessão de estudo"
              />
            </div>
            
            <div>
              <label 
                htmlFor="hiperfoco" 
                className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
              >
                Hiperfoco Inicial
              </label>
              <select
                id="hiperfoco"
                value={novaAlternancia.hiperfocoId}
                onChange={(e) => setNovaAlternancia({ ...novaAlternancia, hiperfocoId: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              >
                <option value="">Selecione um hiperfoco</option>
                {hiperfocos.map(hiperfoco => (
                  <option key={hiperfoco.id} value={hiperfoco.id}>
                    {hiperfoco.titulo}
                  </option>
                ))}
              </select>
            </div>
            
            <div>
              <label 
                htmlFor="tempoEstimado" 
                className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
              >
                Tempo Estimado (minutos)
              </label>
              <input
                type="number"
                id="tempoEstimado"
                value={novaAlternancia.tempoEstimado}
                onChange={(e) => setNovaAlternancia({ ...novaAlternancia, tempoEstimado: e.target.value })}
                min="1"
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                placeholder="Ex: 30"
              />
            </div>
          </div>
          
          <div className="mt-4 flex justify-end space-x-3">
            <button
              type="button"
              onClick={() => setMostrarFormulario(false)}
              className="px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary dark:bg-gray-600 dark:text-white dark:border-gray-700 dark:hover:bg-gray-700"
            >
              Cancelar
            </button>
            <button
              type="submit"
              className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-hiperfocos-primary hover:bg-hiperfocos-secondary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary"
            >
              Iniciar Sessão
            </button>
          </div>
        </form>
      ) : (
        <button
          onClick={() => setMostrarFormulario(true)}
          className="flex items-center px-4 py-2 mb-6 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-hiperfocos-primary hover:bg-hiperfocos-secondary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary"
          disabled={hiperfocos.length === 0}
        >
          <Plus className="h-5 w-5 mr-2" aria-hidden="true" />
          Nova Sessão de Alternância
        </button>
      )}
      
      {hiperfocos.length === 0 && (
        <div className="text-center py-4 text-gray-500 dark:text-gray-400 border border-dashed border-gray-300 dark:border-gray-600 rounded-md">
          <p>
            Para criar uma sessão de alternância, primeiro crie hiperfocos
            <br />na guia &quot;Conversor de Interesses&quot;.
          </p>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/hiperfocos/VisualizadorProjetos.tsx">
'use client'

import { useState } from 'react'
import { useHiperfocosStore, type Hiperfoco, type Tarefa } from '../../stores/hiperfocosStore'
import { ChevronDown, ChevronRight, Plus, Edit, Trash2, Check } from 'lucide-react'

export function VisualizadorProjetos() {
  const { 
    hiperfocos, 
    adicionarSubTarefa, 
    toggleTarefaConcluida, 
    toggleSubTarefaConcluida, 
    atualizarTarefa,
    atualizarSubTarefa,
    removerTarefa,
    removerSubTarefa
  } = useHiperfocosStore()
  
  const [hiperfocoAtivo, setHiperfocoAtivo] = useState<string | null>(
    hiperfocos.length > 0 ? hiperfocos[0].id : null
  )
  
  const [expandidas, setExpandidas] = useState<Record<string, boolean>>({})
  const [novaTarefaTexto, setNovaTarefaTexto] = useState<Record<string, string>>({})
  const [editando, setEditando] = useState<Record<string, boolean>>({})
  const [textoEdicao, setTextoEdicao] = useState<Record<string, string>>({})
  
  // Alterna a expansão de uma tarefa
  const toggleExpand = (tarefaId: string) => {
    setExpandidas(prev => ({
      ...prev,
      [tarefaId]: !prev[tarefaId]
    }))
  }
  
  // Inicia a edição de uma tarefa
  const iniciarEdicao = (id: string, texto: string) => {
    setEditando(prev => ({ ...prev, [id]: true }))
    setTextoEdicao(prev => ({ ...prev, [id]: texto }))
  }
  
  // Salva a edição de uma tarefa
  const salvarEdicao = (hiperfocoId: string, tarefaId: string, tipo: 'tarefa' | 'subtarefa', tarefaPaiId?: string) => {
    if (!textoEdicao[tarefaId] || textoEdicao[tarefaId].trim() === '') return
    
    if (tipo === 'tarefa') {
      atualizarTarefa(hiperfocoId, tarefaId, textoEdicao[tarefaId])
    } else if (tipo === 'subtarefa' && tarefaPaiId) {
      atualizarSubTarefa(hiperfocoId, tarefaPaiId, tarefaId, textoEdicao[tarefaId])
    }
    
    setEditando(prev => ({ ...prev, [tarefaId]: false }))
  }
  
  // Adiciona uma nova subtarefa
  const handleAddSubtarefa = (hiperfocoId: string, tarefaId: string) => {
    const texto = novaTarefaTexto[tarefaId]
    if (!texto || texto.trim() === '') return
    
    adicionarSubTarefa(hiperfocoId, tarefaId, texto)
    
    // Limpar o input e expandir a tarefa pai
    setNovaTarefaTexto(prev => ({ ...prev, [tarefaId]: '' }))
    setExpandidas(prev => ({ ...prev, [tarefaId]: true }))
  }
  
  // Renderiza uma tarefa com suas subtarefas
  const renderizarTarefa = (hiperfoco: Hiperfoco, tarefa: Tarefa) => {
    const isExpanded = expandidas[tarefa.id] || false
    const temSubtarefas = hiperfoco.subTarefas[tarefa.id]?.length > 0
    const isEditing = editando[tarefa.id] || false
    
    return (
      <div 
        key={tarefa.id}
        className="border-l-2 pl-3 my-2"
        style={{ borderColor: hiperfoco.cor }}
      >
        <div className="flex items-center">
          {/* Expandir/Colapsar */}
          <button
            onClick={() => toggleExpand(tarefa.id)}
            className={`p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-white ${!temSubtarefas && 'invisible'}`}
            aria-label={isExpanded ? 'Colapsar' : 'Expandir'}
          >
            {isExpanded ? 
              <ChevronDown className="h-4 w-4" aria-hidden="true" /> : 
              <ChevronRight className="h-4 w-4" aria-hidden="true" />
            }
          </button>
          
          {/* Checkbox */}
          <button
            onClick={() => toggleTarefaConcluida(hiperfoco.id, tarefa.id)}
            className={`p-1 rounded-md mr-2 ${
              tarefa.concluida 
                ? 'bg-green-100 text-green-600 dark:bg-green-800 dark:text-green-200' 
                : 'bg-gray-100 text-gray-400 dark:bg-gray-700 dark:text-gray-400'
            }`}
            aria-label={tarefa.concluida ? 'Marcar como não concluída' : 'Marcar como concluída'}
            aria-pressed={tarefa.concluida}
          >
            <Check className="h-4 w-4" aria-hidden="true" />
          </button>
          
          {/* Conteúdo da tarefa */}
          {isEditing ? (
            <input
              type="text"
              value={textoEdicao[tarefa.id] || ''}
              onChange={(e) => setTextoEdicao({ ...textoEdicao, [tarefa.id]: e.target.value })}
              onBlur={() => salvarEdicao(hiperfoco.id, tarefa.id, 'tarefa')}
              onKeyDown={(e) => e.key === 'Enter' && salvarEdicao(hiperfoco.id, tarefa.id, 'tarefa')}
              className="flex-1 px-2 py-1 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              autoFocus
            />
          ) : (
            <span className={`flex-1 text-sm ${tarefa.concluida ? 'line-through text-gray-500 dark:text-gray-400' : 'text-gray-700 dark:text-gray-200'}`}>
              {tarefa.texto}
            </span>
          )}
          
          {/* Ações */}
          <div className="flex space-x-1 ml-2">
            <button
              onClick={() => iniciarEdicao(tarefa.id, tarefa.texto)}
              className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-white"
              aria-label="Editar tarefa"
            >
              <Edit className="h-4 w-4" aria-hidden="true" />
            </button>
            <button
              onClick={() => removerTarefa(hiperfoco.id, tarefa.id)}
              className="p-1 text-gray-500 hover:text-red-500 dark:text-gray-400 dark:hover:text-red-400"
              aria-label="Remover tarefa"
            >
              <Trash2 className="h-4 w-4" aria-hidden="true" />
            </button>
          </div>
        </div>
        
        {/* Sub-tarefas */}
        {isExpanded && (
          <div className="ml-6 mt-2">
            {/* Lista de subtarefas */}
            {(hiperfoco.subTarefas[tarefa.id] || []).map((subTarefa) => {
              const isSubEditing = editando[subTarefa.id] || false
              
              return (
                <div key={subTarefa.id} className="flex items-center mb-2">
                  <button
                    onClick={() => toggleSubTarefaConcluida(hiperfoco.id, tarefa.id, subTarefa.id)}
                    className={`p-1 rounded-md mr-2 ${
                      subTarefa.concluida 
                        ? 'bg-green-100 text-green-600 dark:bg-green-800 dark:text-green-200' 
                        : 'bg-gray-100 text-gray-400 dark:bg-gray-700 dark:text-gray-400'
                    }`}
                    aria-label={subTarefa.concluida ? 'Marcar como não concluída' : 'Marcar como concluída'}
                    aria-pressed={subTarefa.concluida}
                  >
                    <Check className="h-3 w-3" aria-hidden="true" />
                  </button>
                  
                  {isSubEditing ? (
                    <input
                      type="text"
                      value={textoEdicao[subTarefa.id] || ''}
                      onChange={(e) => setTextoEdicao({ ...textoEdicao, [subTarefa.id]: e.target.value })}
                      onBlur={() => salvarEdicao(hiperfoco.id, subTarefa.id, 'subtarefa', tarefa.id)}
                      onKeyDown={(e) => e.key === 'Enter' && salvarEdicao(hiperfoco.id, subTarefa.id, 'subtarefa', tarefa.id)}
                      className="flex-1 px-2 py-1 text-sm border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      autoFocus
                    />
                  ) : (
                    <span className={`flex-1 text-xs ${subTarefa.concluida ? 'line-through text-gray-500 dark:text-gray-400' : 'text-gray-600 dark:text-gray-300'}`}>
                      {subTarefa.texto}
                    </span>
                  )}
                  
                  <div className="flex space-x-1 ml-2">
                    <button
                      onClick={() => iniciarEdicao(subTarefa.id, subTarefa.texto)}
                      className="p-0.5 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-white"
                      aria-label="Editar subtarefa"
                    >
                      <Edit className="h-3 w-3" aria-hidden="true" />
                    </button>
                    <button
                      onClick={() => removerSubTarefa(hiperfoco.id, tarefa.id, subTarefa.id)}
                      className="p-0.5 text-gray-500 hover:text-red-500 dark:text-gray-400 dark:hover:text-red-400"
                      aria-label="Remover subtarefa"
                    >
                      <Trash2 className="h-3 w-3" aria-hidden="true" />
                    </button>
                  </div>
                </div>
              )
            })}
            
            {/* Campo para adicionar nova subtarefa */}
            <div className="flex items-center mt-2">
              <input
                type="text"
                value={novaTarefaTexto[tarefa.id] || ''}
                onChange={(e) => setNovaTarefaTexto({ ...novaTarefaTexto, [tarefa.id]: e.target.value })}
                onKeyDown={(e) => e.key === 'Enter' && handleAddSubtarefa(hiperfoco.id, tarefa.id)}
                placeholder="Nova sub-tarefa..."
                className="flex-1 px-2 py-1 text-xs border border-gray-300 rounded-l-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                aria-label="Nova sub-tarefa"
              />
              <button
                onClick={() => handleAddSubtarefa(hiperfoco.id, tarefa.id)}
                className="px-2 py-1 bg-hiperfocos-primary text-white rounded-r-md hover:bg-hiperfocos-secondary"
                aria-label="Adicionar sub-tarefa"
              >
                <Plus className="h-3 w-3" aria-hidden="true" />
              </button>
            </div>
          </div>
        )}
      </div>
    )
  }
  
  // Obter o hiperfoco ativo
  const hiperfocoSelecionado = hiperfocos.find(h => h.id === hiperfocoAtivo) || null
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-4">
        Visualização em Árvore de Projetos
      </h2>
      
      {hiperfocos.length > 0 ? (
        <div>
          {/* Seletor de hiperfoco */}
          <div className="mb-6">
            <label htmlFor="hiperfoco-select" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Selecione um Hiperfoco
            </label>
            <select
              id="hiperfoco-select"
              value={hiperfocoAtivo || ''}
              onChange={(e) => setHiperfocoAtivo(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            >
              {hiperfocos.map((hiperfoco) => (
                <option key={hiperfoco.id} value={hiperfoco.id}>
                  {hiperfoco.titulo}
                </option>
              ))}
            </select>
          </div>
          
          {hiperfocoSelecionado && (
            <div>
              {/* Cabeçalho do hiperfoco */}
              <div 
                className="mb-4 p-3 rounded-md"
                style={{ backgroundColor: `${hiperfocoSelecionado.cor}20` }}
              >
                <h3 
                  className="text-lg font-medium mb-1"
                  style={{ color: hiperfocoSelecionado.cor }}
                >
                  {hiperfocoSelecionado.titulo}
                </h3>
                {hiperfocoSelecionado.descricao && (
                  <p className="text-sm text-gray-600 dark:text-gray-300">
                    {hiperfocoSelecionado.descricao}
                  </p>
                )}
                
                <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                  {hiperfocoSelecionado.tarefas.filter(t => t.concluida).length} de {hiperfocoSelecionado.tarefas.length} tarefas concluídas
                </div>
              </div>
              
              {/* Árvore de tarefas */}
              <div className="bg-white dark:bg-gray-700 rounded-lg shadow-sm p-4">
                {hiperfocoSelecionado.tarefas.length > 0 ? (
                  <div>
                    {hiperfocoSelecionado.tarefas.map((tarefa) => renderizarTarefa(hiperfocoSelecionado, tarefa))}
                  </div>
                ) : (
                  <p className="text-center py-4 text-gray-500 dark:text-gray-400">
                    Este hiperfoco não possui tarefas.
                  </p>
                )}
              </div>
            </div>
          )}
        </div>
      ) : (
        <div className="text-center py-8 text-gray-500 dark:text-gray-400 border border-dashed border-gray-300 dark:border-gray-600 rounded-md">
          <p>
            Nenhum hiperfoco encontrado. Crie seu primeiro hiperfoco na guia &quot;Conversor de Interesses&quot;.
          </p>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/humor/MoodDataMigration.tsx">
import { useState, useEffect } from 'react';
import { useHumor } from '@/app/hooks/useHumor';
import { useToast } from '@/app/hooks/useToast';

interface MoodDataMigrationProps {
  onMigrationComplete?: () => void;
}

export default function MoodDataMigration({ onMigrationComplete }: MoodDataMigrationProps) {
  const { migrateFromLocalStorage, isLoading, error } = useHumor();
  const { showToast } = useToast();
  
  const [hasLocalData, setHasLocalData] = useState(false);
  const [shouldClearLocal, setShouldClearLocal] = useState(true);
  const [isMigrating, setIsMigrating] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [migrationCount, setMigrationCount] = useState(0);
  const [duplicateCount, setDuplicateCount] = useState(0);
  
  // Verificar se há dados locais para migrar
  useEffect(() => {
    const localData = localStorage.getItem('zustand');
    if (localData) {
      try {
        const parsedData = JSON.parse(localData);
        if (parsedData?.state?.registrosHumor && parsedData.state.registrosHumor.length > 0) {
          setHasLocalData(true);
        }
      } catch (e) {
        console.error('Erro ao analisar dados locais:', e);
      }
    }
  }, []);
  
  // Limpar dados locais após migração bem-sucedida
  const clearLocalData = () => {
    try {
      const localData = localStorage.getItem('zustand');
      if (localData) {
        const parsedData = JSON.parse(localData);
        
        if (parsedData?.state?.registrosHumor) {
          parsedData.state.registrosHumor = [];
          localStorage.setItem('zustand', JSON.stringify(parsedData));
          showToast('Dados locais de humor removidos com sucesso', 'success');
        }
      }
    } catch (e) {
      console.error('Erro ao limpar dados locais:', e);
      showToast('Erro ao limpar dados locais', 'error');
    }
  };
  
  // Iniciar o processo de migração
  const startMigration = async () => {
    setIsMigrating(true);
    
    try {
      const result = await migrateFromLocalStorage();
      
      if (result.success) {
        setShowSuccess(true);
        setMigrationCount(result.count);
        setDuplicateCount(result.duplicates);
        
        let message = `${result.count} registros de humor migrados com sucesso`;
        if (result.duplicates > 0) {
          message += ` (${result.duplicates} duplicados ignorados)`;
        }
        
        showToast(message, 'success');
        
        if (shouldClearLocal && result.count > 0) {
          clearLocalData();
        }
        
        if (onMigrationComplete) {
          onMigrationComplete();
        }
      } else {
        showToast(`Erro na migração: ${result.error}`, 'error');
      }
    } catch (err) {
      showToast('Erro ao migrar dados', 'error');
    } finally {
      setIsMigrating(false);
    }
  };
  
  // Se não houver dados para migrar, não renderize nada
  if (!hasLocalData && !showSuccess) {
    return null;
  }
  
  return (
    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
      <h3 className="text-lg font-medium mb-2">
        {showSuccess ? 'Migração Concluída!' : 'Migrar Dados de Humor'}
      </h3>
      
      {!showSuccess ? (
        <>
          <p className="text-gray-600 dark:text-gray-300 mb-4">
            Encontramos registros de humor armazenados localmente neste dispositivo.
            Você deseja migrá-los para a nuvem?
          </p>
          
          <div className="flex items-center mb-4">
            <input
              type="checkbox"
              id="clearLocal"
              checked={shouldClearLocal}
              onChange={(e) => setShouldClearLocal(e.target.checked)}
              className="mr-2"
            />
            <label htmlFor="clearLocal" className="text-sm">
              Remover dados locais após migração bem-sucedida
            </label>
          </div>
          
          <div className="flex justify-end space-x-2">
            <button
              onClick={startMigration}
              disabled={isMigrating}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
            >
              {isMigrating ? 'Migrando...' : 'Migrar Dados'}
            </button>
          </div>
          
          {error && (
            <p className="text-red-500 mt-2 text-sm">{error.message}</p>
          )}
        </>
      ) : (
        <>
          <p className="text-gray-600 dark:text-gray-300 mb-2">
            {migrationCount > 0 
              ? `${migrationCount} registros de humor foram migrados com sucesso para a nuvem.` 
              : 'Nenhum novo registro precisou ser migrado.'}
          </p>
          
          {duplicateCount > 0 && (
            <p className="text-yellow-600 dark:text-yellow-400 mb-2 text-sm">
              {duplicateCount} registros foram ignorados por já existirem no banco de dados.
            </p>
          )}
          
          {shouldClearLocal && migrationCount > 0 && (
            <p className="text-green-600 dark:text-green-400 text-sm">
              Os dados locais foram removidos com sucesso.
            </p>
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="app/components/humor/MoodForm.tsx">
import { useState, useEffect } from 'react';
import { useHumor } from '@/app/hooks/useHumor';
import { useToast } from '@/app/hooks/useToast';
import { MoodRecord, NewMoodRecord } from '@/app/types/supabase';

// Lista de fatores comuns que podem afetar o humor
const COMMON_FACTORS = [
  'Estresse', 'Sono', 'Exercício', 'Alimentação', 'Socialização',
  'Medicação', 'Trabalho', 'Estudo', 'Lazer', 'Família', 
  'Saúde', 'Finanças', 'Clima', 'Sensorial'
];

interface MoodFormProps {
  onSuccess?: () => void;
  initialData?: MoodRecord;
}

export default function MoodForm({ onSuccess, initialData }: MoodFormProps) {
  const { addMoodRecord, updateMoodRecord, isLoading, error, resetError } = useHumor();
  const { showToast } = useToast();
  
  // Estado do formulário
  const [moodLevel, setMoodLevel] = useState(initialData?.mood_level || 5);
  const [date, setDate] = useState(initialData?.record_date || new Date().toISOString().split('T')[0]);
  const [notes, setNotes] = useState(initialData?.notes || '');
  const [selectedFactors, setSelectedFactors] = useState<string[]>(initialData?.factors || []);
  const [customFactor, setCustomFactor] = useState('');
  
  // Resetar erro quando mudar os campos do formulário
  useEffect(() => {
    if (error) resetError();
  }, [moodLevel, date, notes, selectedFactors, error, resetError]);
  
  // Adicionar fator personalizado
  const handleAddCustomFactor = () => {
    if (customFactor.trim() && !selectedFactors.includes(customFactor.trim())) {
      setSelectedFactors([...selectedFactors, customFactor.trim()]);
      setCustomFactor('');
    }
  };
  
  // Alternar fator comum
  const toggleFactor = (factor: string) => {
    if (selectedFactors.includes(factor)) {
      setSelectedFactors(selectedFactors.filter(f => f !== factor));
    } else {
      setSelectedFactors([...selectedFactors, factor]);
    }
  };
  
  // Remover fator selecionado
  const removeFactor = (factor: string) => {
    setSelectedFactors(selectedFactors.filter(f => f !== factor));
  };
  
  // Enviar formulário
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    const moodData: NewMoodRecord = {
      record_date: date,
      mood_level: moodLevel,
      factors: selectedFactors,
      notes: notes || null
    };
    
    let success;
    
    if (initialData) {
      // Atualizar registro existente
      const updated = await updateMoodRecord(initialData.id, moodData);
      success = !!updated;
      
      if (success) {
        showToast('Registro de humor atualizado com sucesso', 'success');
      }
    } else {
      // Adicionar novo registro
      const created = await addMoodRecord(moodData);
      success = !!created;
      
      if (success) {
        showToast('Registro de humor adicionado com sucesso', 'success');
        // Resetar formulário se for um novo registro
        setMoodLevel(5);
        setDate(new Date().toISOString().split('T')[0]);
        setNotes('');
        setSelectedFactors([]);
      }
    }
    
    if (!success) {
      showToast('Erro ao salvar registro de humor', 'error');
    } else if (onSuccess) {
      onSuccess();
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
      <h3 className="text-lg font-medium mb-4">
        {initialData ? 'Editar Registro de Humor' : 'Novo Registro de Humor'}
      </h3>
      
      {/* Data do registro */}
      <div className="mb-4">
        <label htmlFor="date" className="block text-sm font-medium mb-1">
          Data
        </label>
        <input
          type="date"
          id="date"
          value={date}
          onChange={(e) => setDate(e.target.value)}
          className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
          required
        />
      </div>
      
      {/* Nível de humor */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">
          Como está seu humor hoje? ({moodLevel}/10)
        </label>
        <input
          type="range"
          min="1"
          max="10"
          step="1"
          value={moodLevel}
          onChange={(e) => setMoodLevel(parseInt(e.target.value))}
          className="w-full"
        />
        <div className="flex justify-between text-xs text-gray-500">
          <span>Muito ruim</span>
          <span>Neutro</span>
          <span>Excelente</span>
        </div>
      </div>
      
      {/* Fatores */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">
          Fatores que influenciaram seu humor
        </label>
        
        {/* Fatores selecionados */}
        {selectedFactors.length > 0 && (
          <div className="flex flex-wrap gap-1 mb-2">
            {selectedFactors.map((factor, index) => (
              <span 
                key={index}
                className="text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded flex items-center"
              >
                {factor}
                <button 
                  type="button"
                  onClick={() => removeFactor(factor)}
                  className="ml-1 text-blue-600 dark:text-blue-300 hover:text-blue-800"
                >
                  &times;
                </button>
              </span>
            ))}
          </div>
        )}
        
        {/* Fatores comuns */}
        <div className="grid grid-cols-2 sm:grid-cols-3 gap-1 mb-2">
          {COMMON_FACTORS.map((factor) => (
            <button
              key={factor}
              type="button"
              onClick={() => toggleFactor(factor)}
              className={`text-xs px-2 py-1 rounded text-left ${
                selectedFactors.includes(factor)
                  ? 'bg-blue-500 text-white'
                  : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'
              }`}
            >
              {factor}
            </button>
          ))}
        </div>
        
        {/* Fator personalizado */}
        <div className="flex gap-2">
          <input
            type="text"
            value={customFactor}
            onChange={(e) => setCustomFactor(e.target.value)}
            placeholder="Adicionar outro fator..."
            className="flex-1 p-2 text-sm border rounded dark:bg-gray-700 dark:border-gray-600"
          />
          <button
            type="button"
            onClick={handleAddCustomFactor}
            disabled={!customFactor.trim()}
            className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
          >
            +
          </button>
        </div>
      </div>
      
      {/* Notas */}
      <div className="mb-4">
        <label htmlFor="notes" className="block text-sm font-medium mb-1">
          Notas (opcional)
        </label>
        <textarea
          id="notes"
          value={notes || ''}
          onChange={(e) => setNotes(e.target.value)}
          placeholder="Descreva mais sobre como você se sente..."
          className="w-full p-2 border rounded min-h-[100px] dark:bg-gray-700 dark:border-gray-600"
        />
      </div>
      
      {/* Mensagem de erro */}
      {error && (
        <p className="text-red-500 mb-4 text-sm">{error.message}</p>
      )}
      
      {/* Botões de ação */}
      <div className="flex justify-end">
        <button
          type="submit"
          disabled={isLoading}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {isLoading 
            ? 'Salvando...' 
            : initialData 
              ? 'Atualizar Registro' 
              : 'Salvar Registro'
          }
        </button>
      </div>
    </form>
  );
}
</file>

<file path="app/components/humor/MoodRecordItem.tsx">
import { useState } from 'react';
import { MoodRecord } from '@/app/types/supabase';
import { useHumor } from '@/app/hooks/useHumor';
import { useToast } from '@/app/hooks/useToast';

interface MoodRecordItemProps {
  record: MoodRecord;
  onUpdate?: () => void;
}

export default function MoodRecordItem({ record, onUpdate }: MoodRecordItemProps) {
  const { deleteMoodRecord, isLoading } = useHumor();
  const { showToast } = useToast();
  const [confirmDelete, setConfirmDelete] = useState(false);
  
  // Formatar data para exibição
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('pt-BR', { 
      day: '2-digit', 
      month: '2-digit', 
      year: 'numeric' 
    });
  };
  
  // Mapear nível de humor para texto descritivo
  const getMoodText = (level: number) => {
    if (level <= 2) return 'Muito ruim';
    if (level <= 4) return 'Ruim';
    if (level <= 6) return 'Neutro';
    if (level <= 8) return 'Bom';
    return 'Excelente';
  };
  
  // Mapear nível de humor para classe de cor
  const getMoodColor = (level: number) => {
    if (level <= 2) return 'bg-red-500';
    if (level <= 4) return 'bg-orange-500';
    if (level <= 6) return 'bg-yellow-500';
    if (level <= 8) return 'bg-green-500';
    return 'bg-green-600';
  };
  
  // Excluir registro
  const handleDelete = async () => {
    if (!confirmDelete) {
      setConfirmDelete(true);
      return;
    }
    
    const success = await deleteMoodRecord(record.id);
    
    if (success) {
      showToast('Registro de humor excluído com sucesso', 'success');
      if (onUpdate) onUpdate();
    } else {
      showToast('Erro ao excluir registro de humor', 'error');
    }
    
    setConfirmDelete(false);
  };
  
  return (
    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-3">
      <div className="flex justify-between items-center mb-2">
        <h3 className="text-md font-medium">
          {formatDate(record.record_date)}
        </h3>
        <div className="flex items-center">
          <span className="text-sm mr-2">
            {getMoodText(record.mood_level)}
          </span>
          <div 
            className={`w-8 h-8 rounded-full flex items-center justify-center text-white ${getMoodColor(record.mood_level)}`}
          >
            {record.mood_level}
          </div>
        </div>
      </div>
      
      {record.factors && record.factors.length > 0 && (
        <div className="mb-2">
          <p className="text-xs text-gray-500 dark:text-gray-400 mb-1">Fatores:</p>
          <div className="flex flex-wrap gap-1">
            {record.factors.map((factor: string, index: number) => (
              <span 
                key={index}
                className="text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded"
              >
                {factor}
              </span>
            ))}
          </div>
        </div>
      )}
      
      {record.notes && (
        <div className="mt-2">
          <p className="text-xs text-gray-500 dark:text-gray-400 mb-1">Notas:</p>
          <p className="text-sm text-gray-700 dark:text-gray-300">
            {record.notes}
          </p>
        </div>
      )}
      
      <div className="mt-3 flex justify-end">
        <button
          onClick={handleDelete}
          disabled={isLoading}
          className={`text-xs px-2 py-1 rounded ${
            confirmDelete 
              ? 'bg-red-600 text-white' 
              : 'text-red-600 bg-transparent hover:bg-red-100 dark:hover:bg-red-900'
          }`}
        >
          {confirmDelete ? 'Confirmar exclusão' : 'Excluir'}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="app/components/humor/MoodRecordList.tsx">
import { useState, useEffect } from 'react';
import { useHumor } from '@/app/hooks/useHumor';
import MoodRecordItem from './MoodRecordItem';
import MoodForm from './MoodForm';
import MoodDataMigration from './MoodDataMigration';
import { MoodRecord } from '@/app/types/supabase';

export default function MoodRecordList() {
  const { getMoodRecords, isLoading, error } = useHumor();
  const [records, setRecords] = useState<MoodRecord[]>([]);
  const [showForm, setShowForm] = useState(false);
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  
  useEffect(() => {
    const loadRecords = async () => {
      const data = await getMoodRecords();
      setRecords(data);
    };
    
    loadRecords();
  }, [getMoodRecords, refreshTrigger]);
  
  const refreshRecords = () => {
    setRefreshTrigger(prev => prev + 1);
  };
  
  const handleToggleForm = () => {
    setShowForm(prev => !prev);
  };
  
  const handleFormSuccess = () => {
    refreshRecords();
    setShowForm(false);
  };
  
  const handleMigrationComplete = () => {
    refreshRecords();
  };
  
  return (
    <div className="container mx-auto max-w-md p-4">
      <h2 className="text-xl font-bold mb-4">Rastreador de Humor</h2>
      
      {/* Componente de migração de dados */}
      <MoodDataMigration onMigrationComplete={handleMigrationComplete} />
      
      {/* Botão para mostrar/ocultar formulário */}
      <div className="mb-4">
        <button
          onClick={handleToggleForm}
          className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        >
          {showForm ? 'Cancelar' : 'Registrar Humor'}
        </button>
      </div>
      
      {/* Formulário para adicionar novo registro */}
      {showForm && (
        <div className="mb-6">
          <MoodForm onSuccess={handleFormSuccess} />
        </div>
      )}
      
      {/* Estado de carregamento */}
      {isLoading && !records.length && (
        <div className="text-center py-4">
          <p>Carregando registros...</p>
        </div>
      )}
      
      {/* Mensagem de erro */}
      {error && (
        <div className="text-red-500 mb-4">
          <p>Erro ao carregar registros: {error.message}</p>
        </div>
      )}
      
      {/* Lista de registros */}
      {!isLoading && !records.length ? (
        <div className="text-center py-4 bg-gray-100 dark:bg-gray-800 rounded-lg">
          <p>Você ainda não possui registros de humor.</p>
          {!showForm && (
            <button
              onClick={handleToggleForm}
              className="mt-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Registrar Agora
            </button>
          )}
        </div>
      ) : (
        <div>
          <h3 className="font-medium mb-2">Seus Registros</h3>
          {records.map(record => (
            <MoodRecordItem 
              key={record.id} 
              record={record} 
              onUpdate={refreshRecords} 
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/components/inicio/ChecklistMedicamentos.tsx">
'use client'

import { useMemo } from 'react'
import { Pill, CheckCircle2, Circle } from 'lucide-react'
import { useAppStore } from '@/app/store'
import { Medicamento } from '@/app/store'

export function ChecklistMedicamentos() {
  const { medicamentos, registrarTomadaMedicamento } = useAppStore(
    (state) => ({
      medicamentos: state.medicamentos || [],
      registrarTomadaMedicamento: state.registrarTomadaMedicamento
    })
  )
  
  // Filtrar apenas medicamentos diários
  const medicamentosDiarios = useMemo(() => {
    return medicamentos
      .filter((med: Medicamento) => med.frequencia === 'Diária')
      .sort((a: Medicamento, b: Medicamento) => a.nome.localeCompare(b.nome))
  }, [medicamentos])
  
  // Verificar se o medicamento foi tomado hoje
  const foiTomadoHoje = (medicamento: Medicamento): boolean => {
    if (!medicamento.ultimaTomada) return false
    
    const hoje = new Date().toISOString().split('T')[0]
    return medicamento.ultimaTomada.includes(hoje)
  }
  
  // Agrupar medicamentos por tipo
  const medicamentosPorTipo = useMemo(() => {
    const grupos: Record<string, Medicamento[]> = {
      'Anfetaminas': [],
      'Antidepressivos': [],
      'Suplementos': [],
      'Outros': []
    }
    
    medicamentosDiarios.forEach((med: Medicamento) => {
      // Lógica simplificada para categorização baseada no nome ou observações
      const nome = med.nome.toLowerCase()
      const obs = (med.observacoes || '').toLowerCase()
      
      if (nome.includes('venvanse') || nome.includes('ritalina') || 
          nome.includes('concerta') || nome.includes('adderall') || 
          obs.includes('anfetamina')) {
        grupos['Anfetaminas'].push(med)
      } 
      else if (nome.includes('prozac') || nome.includes('fluoxetina') || 
               nome.includes('sertralina') || nome.includes('escitalopram') ||
               nome.includes('paroxetina') || obs.includes('antidepressivo')) {
        grupos['Antidepressivos'].push(med)
      }
      else if (nome.includes('vitamina') || nome.includes('mineral') || 
               nome.includes('omega') || nome.includes('ômega') || 
               nome.includes('suplemento') || obs.includes('suplemento')) {
        grupos['Suplementos'].push(med)
      }
      else {
        grupos['Outros'].push(med)
      }
    })
    
    // Remover categorias vazias
    return Object.fromEntries(
      Object.entries(grupos).filter(([_, meds]) => meds.length > 0)
    )
  }, [medicamentosDiarios])
  
  // Registrar tomada de medicamento
  const handleToggleTomado = (id: string) => {
    const dataHora = new Date().toISOString()
    registrarTomadaMedicamento(id, dataHora)
  }
  
  // Se não houver medicamentos diários
  if (medicamentosDiarios.length === 0) {
    return (
      <div className="text-center text-gray-500 dark:text-gray-400 py-2">
        Nenhum medicamento diário cadastrado
      </div>
    )
  }
  
  return (
    <div className="space-y-3">
      <div className="flex items-center text-sm text-gray-600 dark:text-gray-300 mb-1">
        <Pill className="h-4 w-4 mr-1" />
        <h3 className="font-medium">Checklist de Medicamentos</h3>
      </div>
      
      <div className="space-y-4">
        {Object.entries(medicamentosPorTipo).map(([tipo, meds]) => (
          <div key={tipo} className="space-y-1">
            {Object.keys(medicamentosPorTipo).length > 1 && (
              <h4 className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">
                {tipo}
              </h4>
            )}
            
            <div className="space-y-1">
              {meds.map((medicamento: Medicamento) => {
                const tomadoHoje = foiTomadoHoje(medicamento)
                
                return (
                  <div 
                    key={medicamento.id}
                    className={`flex items-center p-2 rounded-md transition-colors ${
                      tomadoHoje 
                        ? 'bg-green-50 dark:bg-green-900/20' 
                        : 'bg-white dark:bg-gray-800'
                    }`}
                  >
                    <button
                      onClick={() => handleToggleTomado(medicamento.id)}
                      className="mr-2 text-green-600 dark:text-green-400 focus:outline-none"
                      aria-label={tomadoHoje ? 'Marcar como não tomado' : 'Marcar como tomado'}
                    >
                      {tomadoHoje ? (
                        <CheckCircle2 className="h-5 w-5" />
                      ) : (
                        <Circle className="h-5 w-5" />
                      )}
                    </button>
                    
                    <div className="flex-1">
                      <span className={`text-sm ${
                        tomadoHoje 
                          ? 'text-gray-500 dark:text-gray-400 line-through' 
                          : 'text-gray-800 dark:text-white'
                      }`}>
                        {medicamento.nome}
                      </span>
                      
                      {medicamento.dosagem && (
                        <span className="ml-1 text-xs text-gray-500 dark:text-gray-400">
                          ({medicamento.dosagem})
                        </span>
                      )}
                    </div>
                  </div>
                )
              })}
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="app/components/inicio/LembretePausas.tsx">
'use client'

import { useState, useEffect } from 'react'
import { Play, Pause, RefreshCw } from 'lucide-react'

export function LembretePausas() {
  const [isActive, setIsActive] = useState(false)
  const [isPaused, setIsPaused] = useState(true)
  const [time, setTime] = useState(25 * 60) // 25 minutos em segundos
  const [ciclo, setCiclo] = useState('foco')

  useEffect(() => {
    let interval: NodeJS.Timeout | null = null

    if (isActive && !isPaused) {
      interval = setInterval(() => {
        setTime((time) => {
          if (time <= 1) {
            // Alternar entre ciclos de foco e pausa
            if (ciclo === 'foco') {
              setCiclo('pausa')
              return 5 * 60 // 5 minutos de pausa
            } else {
              setCiclo('foco')
              return 25 * 60 // 25 minutos de foco
            }
          }
          return time - 1
        })
      }, 1000)
    } else {
      interval && clearInterval(interval)
    }

    return () => {
      interval && clearInterval(interval)
    }
  }, [isActive, isPaused, ciclo])

  const formatTime = () => {
    const minutes = Math.floor(time / 60)
    const seconds = time % 60
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
  }

  const handleStart = () => {
    setIsActive(true)
    setIsPaused(false)
  }

  const handlePause = () => {
    setIsPaused(true)
  }

  const handleReset = () => {
    setIsActive(false)
    setIsPaused(true)
    setCiclo('foco')
    setTime(25 * 60)
  }

  // Determinar a cor com base no ciclo atual
  const cicloColor = ciclo === 'foco' 
    ? 'text-estudos-primary' 
    : 'text-lazer-primary'

  // Determinar a mensagem com base no ciclo atual
  const cicloMensagem = ciclo === 'foco'
    ? 'Tempo de foco'
    : 'Tempo de pausa'

  return (
    <div className="flex flex-col items-center">
      <div className="text-center mb-4">
        <h3 className={`text-xl font-bold ${cicloColor}`}>{cicloMensagem}</h3>
        <p className="text-gray-600 dark:text-gray-400 text-sm">
          Alterne entre períodos de foco e pausas curtas
        </p>
      </div>

      <div className="text-4xl font-mono font-bold mb-6 bg-gray-100 dark:bg-gray-700 px-6 py-3 rounded-xl">
        {formatTime()}
      </div>

      <div className="flex space-x-4">
        {isPaused ? (
          <button
            onClick={handleStart}
            className="flex items-center px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            aria-label="Iniciar temporizador"
          >
            <Play className="h-5 w-5 mr-1" />
            <span>Iniciar</span>
          </button>
        ) : (
          <button
            onClick={handlePause}
            className="flex items-center px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 focus:outline-none focus:ring-2 focus:ring-yellow-500"
            aria-label="Pausar temporizador"
          >
            <Pause className="h-5 w-5 mr-1" />
            <span>Pausar</span>
          </button>
        )}

        <button
          onClick={handleReset}
          className="flex items-center px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
          aria-label="Reiniciar temporizador"
        >
          <RefreshCw className="h-5 w-5 mr-1" />
          <span>Reiniciar</span>
        </button>
      </div>

      <div className="mt-6 text-sm text-gray-600 dark:text-gray-400">
        <p>Dicas:</p>
        <ul className="list-disc pl-5 mt-1">
          <li>Durante o foco, concentre-se em uma única tarefa</li>
          <li>Use as pausas para alongar-se ou beber água</li>
          <li>Ajuste os tempos conforme sua necessidade</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="app/components/inicio/ListaPrioridades.tsx">
'use client'

import { useState, useEffect } from 'react'
import { CheckCircle2, Circle, PlusCircle, Edit2, Calendar, ChevronLeft, ChevronRight, X } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Input } from '@/app/components/ui/Input'
import { Modal } from '@/app/components/ui/Modal'
import { Badge } from '@/app/components/ui/Badge'
import { usePrioridadesStore, Prioridade } from '@/app/stores/prioridadesStore'

export function ListaPrioridades() {
  const { 
    prioridades, 
    adicionarPrioridade, 
    editarPrioridade, 
    removerPrioridade, 
    toggleConcluida, 
    getHistoricoPorData,
    getDatasPrioridades
  } = usePrioridadesStore()
  
  const [novoTexto, setNovoTexto] = useState('')
  const [prioridadeEditando, setPrioridadeEditando] = useState<Prioridade | null>(null)
  const [textoEditando, setTextoEditando] = useState('')
  const [showHistory, setShowHistory] = useState(false)
  const [dataAtual, setDataAtual] = useState(new Date().toISOString().split('T')[0])
  const [prioridadesExibidas, setPrioridadesExibidas] = useState<Prioridade[]>([])
  const [datasHistorico, setDatasHistorico] = useState<string[]>([])

  // Carregar prioridades do dia atual
  useEffect(() => {
    const prioridadesDoDia = getHistoricoPorData(dataAtual)
    setPrioridadesExibidas(prioridadesDoDia)
  }, [prioridades, dataAtual, getHistoricoPorData])

  // Carregar datas disponíveis no histórico
  useEffect(() => {
    const datas = getDatasPrioridades()
    setDatasHistorico(datas)
  }, [prioridades, getDatasPrioridades])

  // Verifica se estamos vendo o dia atual
  const isToday = () => {
    const hoje = new Date().toISOString().split('T')[0]
    return dataAtual === hoje
  }

  // Funções para navegação no histórico
  const irParaDataAnterior = () => {
    const indexAtual = datasHistorico.indexOf(dataAtual)
    if (indexAtual < datasHistorico.length - 1) {
      setDataAtual(datasHistorico[indexAtual + 1])
    }
  }

  const irParaDataProxima = () => {
    const indexAtual = datasHistorico.indexOf(dataAtual)
    if (indexAtual > 0) {
      setDataAtual(datasHistorico[indexAtual - 1])
    }
  }

  const voltarParaHoje = () => {
    setDataAtual(new Date().toISOString().split('T')[0])
  }

  // Função para adicionar nova prioridade
  const handleAdicionarPrioridade = () => {
    if (!novoTexto.trim() || prioridadesExibidas.length >= 3) return
    
    adicionarPrioridade({
      texto: novoTexto,
      concluida: false
    })
    
    setNovoTexto('')
  }

  // Função para iniciar edição
  const iniciarEdicao = (prioridade: Prioridade) => {
    setPrioridadeEditando(prioridade)
    setTextoEditando(prioridade.texto)
  }

  // Função para salvar edição
  const salvarEdicao = () => {
    if (prioridadeEditando && textoEditando.trim()) {
      editarPrioridade(prioridadeEditando.id, textoEditando)
      setPrioridadeEditando(null)
    }
  }

  // Função para cancelar edição
  const cancelarEdicao = () => {
    setPrioridadeEditando(null)
  }

  // Formatar data para exibição (DD/MM/YYYY)
  const formatarData = (dataISO: string) => {
    const partes = dataISO.split('-')
    return `${partes[2]}/${partes[1]}/${partes[0]}`
  }

  return (
    <div className="space-y-4">
      {/* Cabeçalho com controles de histórico */}
      <div className="flex justify-between items-center mb-2">
        <Button 
          variant="ghost" 
          size="sm" 
          onClick={() => setShowHistory(!showHistory)}
          aria-label={showHistory ? "Esconder histórico" : "Mostrar histórico"}
        >
          <Calendar className="h-4 w-4 mr-1" />
          {showHistory ? 'Esconder Histórico' : 'Ver Histórico'}
        </Button>
        
        {isToday() ? (
          <Badge>Hoje</Badge>
        ) : (
          <Badge variant="secondary">{formatarData(dataAtual)}</Badge>
        )}
      </div>

      {/* Controles de navegação no histórico */}
      {showHistory && (
        <div className="flex items-center justify-between bg-gray-50 dark:bg-gray-800 p-2 rounded-lg mb-3">
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={irParaDataAnterior}
            disabled={datasHistorico.indexOf(dataAtual) >= datasHistorico.length - 1}
            aria-label="Data anterior"
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
          
          <div className="text-sm font-medium">
            {formatarData(dataAtual)}
            {!isToday() && (
              <Button 
                variant="link" 
                size="sm" 
                className="ml-2 underline text-blue-600 dark:text-blue-400"
                onClick={voltarParaHoje}
              >
                Voltar para hoje
              </Button>
            )}
          </div>
          
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={irParaDataProxima}
            disabled={datasHistorico.indexOf(dataAtual) <= 0}
            aria-label="Próxima data"
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      )}

      {/* Lista de prioridades */}
      <div className="space-y-2">
        {prioridadesExibidas.length === 0 ? (
          <div className="text-center py-6 text-gray-500 dark:text-gray-400">
            {isToday() ? (
              <p>Nenhuma prioridade definida para hoje.</p>
            ) : (
              <p>Nenhuma prioridade registrada para esta data.</p>
            )}
          </div>
        ) : (
          prioridadesExibidas.map((prioridade) => (
            <div
              key={prioridade.id}
              className={`flex items-center p-3 rounded-lg transition-colors duration-200 ${
                prioridade.concluida
                  ? 'bg-green-50 dark:bg-green-900/20'
                  : 'bg-white dark:bg-gray-800'
              }`}
            >
              {isToday() && (
                <button
                  onClick={() => toggleConcluida(prioridade.id)}
                  className="mr-3 text-green-600 dark:text-green-400 focus:outline-none"
                  aria-label={prioridade.concluida ? 'Marcar como não concluída' : 'Marcar como concluída'}
                >
                  {prioridade.concluida ? (
                    <CheckCircle2 className="h-6 w-6" />
                  ) : (
                    <Circle className="h-6 w-6" />
                  )}
                </button>
              )}
              
              <span
                className={`flex-1 ${
                  prioridade.concluida
                    ? 'text-gray-500 dark:text-gray-400 line-through'
                    : 'text-gray-900 dark:text-white'
                }`}
              >
                {prioridade.texto}
              </span>
              
              {isToday() && (
                <button
                  onClick={() => iniciarEdicao(prioridade)}
                  className="ml-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 focus:outline-none"
                  aria-label="Editar prioridade"
                >
                  <Edit2 className="h-4 w-4" />
                </button>
              )}
            </div>
          ))
        )}
      </div>

      {/* Input para adicionar nova prioridade (apenas no dia atual) */}
      {isToday() && prioridadesExibidas.length < 3 && (
        <div className="flex items-center mt-4">
          <Input
            type="text"
            value={novoTexto}
            onChange={(e) => setNovoTexto(e.target.value)}
            placeholder="Nova prioridade..."
            className="flex-1"
            maxLength={50}
          />
          <Button
            onClick={handleAdicionarPrioridade}
            className="ml-2"
            aria-label="Adicionar prioridade"
          >
            <PlusCircle className="h-5 w-5" />
          </Button>
        </div>
      )}

      {/* Mensagem quando atingir o limite de prioridades */}
      {isToday() && prioridadesExibidas.length >= 3 && (
        <p className="text-sm text-gray-500 dark:text-gray-400 italic">
          Máximo de 3 prioridades para manter o foco.
        </p>
      )}

      {/* Modal de edição */}
      {prioridadeEditando && (
        <Modal
          isOpen={!!prioridadeEditando}
          title="Editar Prioridade"
          onClose={cancelarEdicao}
        >
          <div className="space-y-4">
            <Input
              value={textoEditando}
              onChange={(e) => setTextoEditando(e.target.value)}
              placeholder="Texto da prioridade"
              maxLength={50}
            />
            
            <div className="flex justify-end space-x-2">
              <Button variant="outline" onClick={cancelarEdicao}>
                Cancelar
              </Button>
              <Button onClick={salvarEdicao} disabled={!textoEditando.trim()}>
                Salvar
              </Button>
            </div>
          </div>
        </Modal>
      )}
    </div>
  )
}
</file>

<file path="app/components/inicio/PainelDia.tsx">
'use client'

import { useState } from 'react'
import { Edit2, Check, X, Trash2, Plus } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Input } from '@/app/components/ui/Input'
import { usePainelDiaStore, BlocoTempo } from '@/app/stores/painelDiaStore'

export function PainelDia() {
  const { blocos, editarAtividade, editarCategoria, adicionarBloco, removerBloco } = usePainelDiaStore()
  const [blocoEditando, setBlocoEditando] = useState<string | null>(null)
  const [atividadeEditando, setAtividadeEditando] = useState('')
  const [novoBloco, setNovoBloco] = useState(false)
  const [novaHora, setNovaHora] = useState('')
  const [novaAtividade, setNovaAtividade] = useState('')
  
  // Função para obter a cor de fundo baseada na categoria
  const getBgColor = (categoria: BlocoTempo['categoria']) => {
    switch (categoria) {
      case 'inicio':
        return 'bg-opacity-40 bg-inicio-light border-inicio-primary'
      case 'alimentacao':
        return 'bg-opacity-40 bg-alimentacao-light border-alimentacao-primary'
      case 'estudos':
        return 'bg-opacity-40 bg-estudos-light border-estudos-primary'
      case 'saude':
        return 'bg-opacity-40 bg-saude-light border-saude-primary'
      case 'lazer':
        return 'bg-opacity-40 bg-lazer-light border-lazer-primary'
      default:
        return 'bg-gray-100 bg-opacity-40 border-gray-300 dark:bg-gray-700 dark:border-gray-600'
    }
  }

  // Iniciar edição de um bloco
  const iniciarEdicao = (bloco: BlocoTempo) => {
    setBlocoEditando(bloco.id)
    setAtividadeEditando(bloco.atividade)
  }

  // Salvar a edição de um bloco
  const salvarEdicao = () => {
    if (blocoEditando) {
      editarAtividade(blocoEditando, atividadeEditando)
      cancelarEdicao()
    }
  }

  // Cancelar a edição
  const cancelarEdicao = () => {
    setBlocoEditando(null)
    setAtividadeEditando('')
  }

  // Função para mostrar o formulário de novo bloco
  const mostrarNovoBloco = () => {
    setNovoBloco(true)
    setNovaHora('')
    setNovaAtividade('')
  }

  // Função para adicionar um novo bloco
  const adicionarNovoBloco = () => {
    if (novaHora && novaAtividade) {
      const id = `${Date.now()}`
      adicionarBloco({
        id,
        hora: novaHora,
        atividade: novaAtividade,
        categoria: 'nenhuma'
      })
      setNovoBloco(false)
      setNovaHora('')
      setNovaAtividade('')
    }
  }

  // Função para cancelar a adição de novo bloco
  const cancelarNovoBloco = () => {
    setNovoBloco(false)
    setNovaHora('')
    setNovaAtividade('')
  }

  // Ordenar blocos por hora
  const blocosOrdenados = [...blocos].sort((a, b) => {
    const horaA = a.hora.split(':').map(Number);
    const horaB = b.hora.split(':').map(Number);
    
    if (horaA[0] !== horaB[0]) {
      return horaA[0] - horaB[0];
    }
    return horaA[1] - horaB[1];
  });

  return (
    <div className="space-y-3">
      <div className="flex justify-end">
        <Button 
          size="sm" 
          variant="outline" 
          onClick={mostrarNovoBloco}
          className="flex items-center gap-1"
          aria-label="Adicionar novo horário"
        >
          <Plus className="h-4 w-4" /> Adicionar Horário
        </Button>
      </div>

      {novoBloco && (
        <div className="p-3 rounded-lg border border-gray-200 dark:border-gray-700 mb-3">
          <div className="flex flex-col gap-3">
            <div className="flex gap-2 items-center">
              <Input
                type="time"
                value={novaHora}
                onChange={(e) => setNovaHora(e.target.value)}
                className="w-24"
                placeholder="Hora"
                aria-label="Nova hora"
              />
              <Input
                value={novaAtividade}
                onChange={(e) => setNovaAtividade(e.target.value)}
                className="flex-1"
                placeholder="O que você planeja fazer neste horário?"
                aria-label="Nova atividade"
              />
            </div>
            <div className="flex justify-end gap-2">
              <Button
                size="sm"
                variant="outline"
                onClick={cancelarNovoBloco}
              >
                Cancelar
              </Button>
              <Button
                size="sm"
                onClick={adicionarNovoBloco}
                disabled={!novaHora || !novaAtividade}
              >
                Adicionar
              </Button>
            </div>
          </div>
        </div>
      )}

      <div className="grid grid-cols-1 gap-2">
        {blocosOrdenados.map((bloco) => (
          <div
            key={bloco.id}
            className={`p-3 rounded-lg border-l-4 ${getBgColor(bloco.categoria)} transition-all duration-200 backdrop-blur-sm group`}
          >
            <div className="flex items-center">
              <span className="font-medium text-gray-700 dark:text-gray-300 w-16">
                {bloco.hora}
              </span>
              
              {blocoEditando === bloco.id ? (
                <div className="flex-1 flex items-center gap-2">
                  <Input
                    value={atividadeEditando}
                    onChange={(e) => setAtividadeEditando(e.target.value)}
                    className="flex-1"
                    placeholder="O que você planeja fazer neste horário?"
                    aria-label="Editar atividade"
                    autoFocus
                  />
                  <div className="flex gap-1">
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={salvarEdicao}
                      aria-label="Salvar edição"
                    >
                      <Check className="h-4 w-4 text-green-500" />
                    </Button>
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={cancelarEdicao}
                      aria-label="Cancelar edição"
                    >
                      <X className="h-4 w-4 text-red-500" />
                    </Button>
                  </div>
                </div>
              ) : (
                <>
                  <span className="flex-1 text-gray-900 dark:text-white">
                    {bloco.atividade}
                  </span>
                  <div className="flex gap-1 opacity-0 group-hover:opacity-100">
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={() => iniciarEdicao(bloco)}
                      aria-label="Editar este horário"
                    >
                      <Edit2 className="h-4 w-4 text-gray-500" />
                    </Button>
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={() => removerBloco(bloco.id)}
                      aria-label="Remover este horário"
                    >
                      <Trash2 className="h-4 w-4 text-red-500" />
                    </Button>
                  </div>
                </>
              )}
            </div>
            
            {blocoEditando === bloco.id && (
              <div className="mt-2 flex flex-wrap gap-1">
                <span className="text-xs text-gray-500 dark:text-gray-400 mr-2">
                  Categoria:
                </span>
                <div className="flex flex-wrap gap-1">
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'alimentacao' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs bg-alimentacao-light text-alimentacao-primary border-alimentacao-primary"
                    onClick={() => editarCategoria(bloco.id, 'alimentacao')}
                  >
                    Alimentação
                  </Button>
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'estudos' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs bg-estudos-light text-estudos-primary border-estudos-primary"
                    onClick={() => editarCategoria(bloco.id, 'estudos')}
                  >
                    Estudos
                  </Button>
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'saude' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs bg-saude-light text-saude-primary border-saude-primary"
                    onClick={() => editarCategoria(bloco.id, 'saude')}
                  >
                    Saúde
                  </Button>
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'lazer' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs bg-lazer-light text-lazer-primary border-lazer-primary"
                    onClick={() => editarCategoria(bloco.id, 'lazer')}
                  >
                    Lazer
                  </Button>
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'nenhuma' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs"
                    onClick={() => editarCategoria(bloco.id, 'nenhuma')}
                  >
                    Nenhuma
                  </Button>
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="app/components/layout/AuthControl.tsx">
'use client'

import { useAuth } from '@/app/hooks/useAuth'
import Link from 'next/link'
import { LogIn } from 'lucide-react'
import { UserMenu } from './UserMenu'

export function AuthControl() {
  const { user, loading } = useAuth()

  // Se estiver carregando, mostrar um indicador de carregamento
  if (loading) {
    return (
      <div className="h-8 w-8 rounded-full bg-gray-200 dark:bg-gray-700 animate-pulse flex items-center justify-center">
        <span className="sr-only">Carregando...</span>
      </div>
    )
  }

  // Se o usuário estiver autenticado, mostrar o menu do usuário
  if (user) {
    return <UserMenu />
  }

  // Se não estiver autenticado, mostrar opção de login
  return (
    <Link href="/auth/login">
      <button 
        className="flex items-center justify-center gap-1 px-3 py-1.5 rounded-md bg-blue-500 hover:bg-blue-600 text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
        aria-label="Fazer login"
      >
        <LogIn className="h-4 w-4" />
        <span>Entrar</span>
      </button>
    </Link>
  )
}
</file>

<file path="app/components/layout/Footer.tsx">
'use client'

import Link from 'next/link'
import Image from 'next/image'

export function Footer() {
  return (
    <footer className="border-t border-gray-200 dark:border-gray-700 py-4 mt-8">
      <div className="container mx-auto px-4">
        <div className="flex flex-col items-center space-y-4">
          <div className="text-center text-sm text-gray-600 dark:text-gray-400 max-w-3xl">
            <p className="italic">
              "Whāia te iti kahurangi, ki te tuohu koe, me he maunga teitei" - 
              <span className="block sm:inline"> Provérbio da língua Māori</span>
            </p>
            <p className="mt-1 text-xs">
              Tradução: "Busque o tesouro que você mais valoriza, se você inclinar a cabeça, que seja para uma montanha elevada."
            </p>
          </div>
          
          <Link 
            href="https://github.com/cvaraujo12/stayfocus"
            target="_blank"
            rel="noopener noreferrer"
            className="text-gray-700 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
            aria-label="GitHub repository"
          >
            <div className="flex items-center space-x-2">
              <Image
                src="/images/cat-icon.svg"
                alt="GitHub"
                width={24}
                height={24}
                className="text-current"
              />
              <span className="text-xs">StayFocus GitHub</span>
            </div>
          </Link>
        </div>
      </div>
    </footer>
  )
}
</file>

<file path="app/components/layout/Header.tsx">
'use client'

import { useState } from 'react'
import { Menu, X, Sun, Moon, HelpCircle, Anchor } from 'lucide-react'
import { useTheme } from 'next-themes'
import { Sidebar } from './Sidebar'
import Link from 'next/link'
import { AuthControl } from './AuthControl'
import { ThemeToggle } from './ThemeToggle'
import { SyncStatus } from '../SyncStatus'
import { useAuthContext } from '@/app/context/AuthContext'

export function Header() {
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const { theme, setTheme } = useTheme()
  const { user } = useAuthContext()
  
  const toggleTheme = () => {
    setTheme(theme === 'dark' ? 'light' : 'dark')
  }

  // Função para abrir o sidebar
  const openSidebar = () => {
    setSidebarOpen(true)
  }

  // Função para fechar o sidebar
  const closeSidebar = () => {
    setSidebarOpen(false)
  }

  return (
    <>
      {/* Sidebar controlável */}
      {sidebarOpen && (
        <Sidebar onClose={closeSidebar} />
      )}
      
      {/* Header fixo no topo */}
      <header className="sticky top-0 z-50 w-full border-b border-border/40 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="container flex h-14 max-w-screen-2xl items-center">
          <div className="mr-4 flex">
            <a className="mr-6 flex items-center space-x-2" href="/">
              <span className="font-bold sm:inline-block">
                MyNeuroApp
              </span>
            </a>
          </div>
          <div className="flex flex-1 items-center justify-between space-x-2 md:justify-end">
            <div className="w-full flex-1 md:w-auto md:flex-none">
              {/* Logo e menu button */}
              <div className="flex items-center">
                <button
                  type="button"
                  className="inline-flex items-center justify-center p-2 rounded-md text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  onClick={openSidebar}
                  aria-label="Abrir menu"
                >
                  <Menu className="h-6 w-6" aria-hidden="true" />
                </button>
                <div className="ml-3 flex items-center">
                  <span className="sr-only">StayFocus</span>
                </div>
              </div>
            </div>
            <div className="flex items-center gap-2">
              {user && <SyncStatus />}
              <ThemeToggle />
              <AuthControl />
            </div>
          </div>
        </div>
      </header>
    </>
  )
}
</file>

<file path="app/components/layout/MainNav.tsx">
import { Bot } from "lucide-react";

// Adicionar o novo item de menu para o Assistente de IA
const mainNavItems = [
  // ... existing items ...
  {
    title: "Assistente IA",
    href: "/assistente-ia",
    icon: <Bot className="h-5 w-5" />,
  },
  // ... existing items ...
];
</file>

<file path="app/components/layout/Sidebar.tsx">
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { Home, Utensils, BookOpen, Heart, Smile, DollarSign, Rocket, X, Brain } from 'lucide-react'

type NavItem = {
  name: string
  href: string
  icon: React.ElementType
  color: string
  activeColor: string
  iconClasses?: string
}

const navItems: NavItem[] = [
  {
    name: 'Início',
    href: '/',
    icon: Home,
    color: 'text-inicio-primary',
    activeColor: 'bg-inicio-light',
  },
  {
    name: 'Alimentação',
    href: '/alimentacao',
    icon: Utensils,
    color: 'text-alimentacao-primary',
    activeColor: 'bg-alimentacao-light',
  },
  {
    name: 'Estudos',
    href: '/estudos',
    icon: BookOpen,
    color: 'text-estudos-primary',
    activeColor: 'bg-estudos-light',
  },
  {
    name: 'Saúde',
    href: '/saude',
    icon: Heart,
    color: 'text-saude-primary',
    activeColor: 'bg-saude-light',
  },
  {
    name: 'Lazer',
    href: '/lazer',
    icon: Smile,
    color: 'text-lazer-primary',
    activeColor: 'bg-lazer-light',
  },
  {
    name: 'Finanças',
    href: '/financas',
    icon: DollarSign,
    color: 'text-financas-primary',
    activeColor: 'bg-financas-light',
  },
  {
    name: 'Hiperfocos',
    href: '/hiperfocos',
    icon: Rocket,
    color: 'text-hiperfocos-primary',
    activeColor: 'bg-hiperfocos-light',
  },
  {
    name: 'Assistente IA',
    href: '/assistente-ia',
    icon: Brain,
    color: 'text-purple-600',
    activeColor: 'bg-purple-100',
  },
]

type SidebarProps = {
  onClose: () => void
}

export function Sidebar({ onClose }: SidebarProps) {
  const pathname = usePathname()

  return (
    <div className="fixed inset-0 z-50 flex">
      {/* Overlay escuro */}
      <div 
        className="fixed inset-0 bg-gray-900/60" 
        onClick={onClose}
        aria-hidden="true"
      />
      
      {/* Sidebar */}
      <div className="relative flex-1 flex flex-col w-64 max-w-xs bg-white dark:bg-gray-800 shadow-xl">
        <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-xl font-bold text-gray-900 dark:text-white">Menu</h2>
          <button
            className="p-2 rounded-md text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            onClick={onClose}
            aria-label="Fechar menu"
          >
            <X className="h-5 w-5" />
          </button>
        </div>
        
        <nav className="flex-1 p-4 overflow-y-auto">
          <div className="space-y-2">
            {navItems.map((item) => {
              const isActive = pathname === item.href || pathname.startsWith(`${item.href}/`)
              
              return (
                <Link
                  key={item.name}
                  href={item.href}
                  className={`
                    flex items-center px-4 py-3 rounded-lg text-base font-medium transition-colors
                    ${isActive 
                      ? `${item.activeColor} ${item.color}` 
                      : 'text-gray-700 hover:bg-gray-100 dark:text-gray-200 dark:hover:bg-gray-700'}
                  `}
                  onClick={onClose}
                  aria-current={isActive ? 'page' : undefined}
                >
                  <item.icon className={`mr-3 h-5 w-5 ${item.iconClasses || ''}`} aria-hidden="true" />
                  {item.name}
                </Link>
              )
            })}
          </div>
        </nav>
      </div>
    </div>
  )
}
</file>

<file path="app/components/layout/ThemeToggle.tsx">
'use client'

import { Moon, Sun } from 'lucide-react'
import { useTheme } from 'next-themes'

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()

  return (
    <button
      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
      className="p-2 rounded-full text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
      aria-label={theme === 'dark' ? 'Mudar para tema claro' : 'Mudar para tema escuro'}
    >
      {theme === 'dark' ? (
        <Sun className="h-5 w-5" aria-hidden="true" />
      ) : (
        <Moon className="h-5 w-5" aria-hidden="true" />
      )}
    </button>
  )
}
</file>

<file path="app/components/layout/UserMenu.tsx">
'use client'

import { useState, useRef, useEffect } from 'react'
import Link from 'next/link'
import { LogOut, User, Settings } from 'lucide-react'
import { useAuth } from '@/app/hooks/useAuth'

export function UserMenu() {
  const { user, signOut } = useAuth()
  const [isOpen, setIsOpen] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)

  // Definir a inicial do nome do usuário ou email para exibir no avatar
  const userInitial = user?.user_metadata?.full_name 
    ? user.user_metadata.full_name.charAt(0).toUpperCase() 
    : user?.email?.charAt(0).toUpperCase() || 'U'

  // Fecha o menu quando clicar fora dele
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [])

  // Função para fazer logout
  const handleSignOut = async () => {
    await signOut()
    setIsOpen(false)
  }

  return (
    <div className="relative" ref={menuRef}>
      <button 
        className="h-8 w-8 rounded-full bg-perfil-primary hover:bg-perfil-secondary text-white flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-perfil-primary"
        onClick={() => setIsOpen(!isOpen)}
        aria-label="Menu do usuário"
        aria-expanded={isOpen}
      >
        <span className="text-sm font-medium">{userInitial}</span>
      </button>

      {/* Menu dropdown */}
      {isOpen && (
        <div className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-md shadow-lg py-1 z-50 border border-gray-200 dark:border-gray-700">
          <div className="px-4 py-2 border-b border-gray-200 dark:border-gray-700">
            <p className="text-sm font-medium text-gray-700 dark:text-gray-300 truncate">
              {user?.email}
            </p>
          </div>
          
          <Link href="/perfil">
            <div className="px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center">
              <User className="h-4 w-4 mr-2" />
              <span>Perfil</span>
            </div>
          </Link>
          
          <Link href="/configuracoes">
            <div className="px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center">
              <Settings className="h-4 w-4 mr-2" />
              <span>Configurações</span>
            </div>
          </Link>
          
          <button 
            onClick={handleSignOut}
            className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center"
          >
            <LogOut className="h-4 w-4 mr-2" />
            <span>Sair</span>
          </button>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/lazer/AtividadesLazer.tsx">
'use client'

import { useState, useMemo } from 'react'
import { Plus, Trash, Clock, Calendar, Bookmark } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Input } from '@/app/components/ui/Input'
import { Textarea } from '@/app/components/ui/Textarea'
import { Badge } from '@/app/components/ui/Badge'
import { Select } from '@/app/components/ui/Select'
import { StatCard } from '@/app/components/ui/StatCard'
import { Alert } from '@/app/components/ui/Alert'
import { useAtividadesStore } from '@/app/stores/atividadesStore'

type Atividade = {
  id: string
  nome: string
  categoria: string
  duracao: number // em minutos
  observacoes: string
  data: string
  concluida: boolean
}

export function AtividadesLazer() {
  const { atividades, adicionarAtividade, removerAtividade, marcarConcluida } = useAtividadesStore()
  
  const [novaAtividade, setNovaAtividade] = useState<Omit<Atividade, 'id' | 'concluida'>>({
    nome: '',
    categoria: 'Criativa',
    duracao: 30,
    observacoes: '',
    data: new Date().toISOString().split('T')[0]
  })

  const [erro, setErro] = useState('')
  const [showForm, setShowForm] = useState(false)

  // Categorias de atividades de lazer
  const categorias = [
    { value: 'Criativa', label: 'Criativa' },
    { value: 'Física', label: 'Física' },
    { value: 'Social', label: 'Social' },
    { value: 'Relaxante', label: 'Relaxante' },
    { value: 'Intelectual', label: 'Intelectual' },
    { value: 'Outra', label: 'Outra' }
  ]

  // Estatísticas
  const estatisticas = useMemo(() => {
    const atividadesConcluidas = atividades.filter(a => a.concluida).length
    const totalMinutosLazer = atividades
      .filter(a => a.concluida)
      .reduce((acc, curr) => acc + curr.duracao, 0)
    
    // Categoria mais comum
    const contagem = atividades
      .filter(a => a.concluida)
      .reduce((acc, curr) => {
        acc[curr.categoria] = (acc[curr.categoria] || 0) + 1
        return acc
      }, {} as Record<string, number>)
    
    const categoriaMaisComum = Object.entries(contagem).sort((a, b) => b[1] - a[1])[0]?.[0] || 'N/A'
    
    return {
      atividadesConcluidas,
      totalMinutosLazer,
      categoriaMaisComum
    }
  }, [atividades])

  // Handler para adicionar atividade
  const handleAdicionarAtividade = () => {
    if (!novaAtividade.nome.trim()) {
      setErro('O nome da atividade é obrigatório')
      return
    }
    
    adicionarAtividade({
      ...novaAtividade,
      id: crypto.randomUUID(),
      concluida: false
    })
    
    // Resetar o formulário
    setNovaAtividade({
      nome: '',
      categoria: 'Criativa',
      duracao: 30,
      observacoes: '',
      data: new Date().toISOString().split('T')[0]
    })
    
    setErro('')
    setShowForm(false)
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-4">
        <Button 
          onClick={() => setShowForm(!showForm)}
          aria-label={showForm ? "Cancelar adição" : "Adicionar nova atividade de lazer"}
        >
          {showForm ? 'Cancelar' : 'Nova Atividade'}
        </Button>
      </div>

      {/* Estatísticas */}
      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
        <StatCard
          title="Atividades Realizadas"
          value={estatisticas.atividadesConcluidas.toString()}
          icon={<Bookmark className="h-5 w-5" />}
          description="Total concluído"
        />
        
        <StatCard
          title="Tempo de Lazer"
          value={`${Math.floor(estatisticas.totalMinutosLazer / 60)}h ${estatisticas.totalMinutosLazer % 60}m`}
          icon={<Clock className="h-5 w-5" />}
          description="Tempo acumulado"
        />
        
        <StatCard
          title="Categoria Favorita"
          value={estatisticas.categoriaMaisComum}
          icon={<Bookmark className="h-5 w-5" />}
          description="Mais frequente"
        />
      </div>

      {/* Formulário para adicionar nova atividade */}
      {showForm && (
        <div className="mb-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
            Nova Atividade de Lazer
          </h3>
          
          {erro && <Alert variant="error" className="mb-3">{erro}</Alert>}
          
          <div className="space-y-4">
            <div>
              <label htmlFor="nome" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Nome da atividade
              </label>
              <Input
                id="nome"
                value={novaAtividade.nome}
                onChange={e => setNovaAtividade({...novaAtividade, nome: e.target.value})}
                placeholder="Ex: Ler um livro"
                aria-required="true"
              />
            </div>
            
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label htmlFor="categoria" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Categoria
                </label>
                <Select
                  id="categoria"
                  value={novaAtividade.categoria}
                  onChange={e => setNovaAtividade({...novaAtividade, categoria: e.target.value})}
                  options={categorias}
                />
              </div>
              
              <div>
                <label htmlFor="duracao" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Duração (minutos)
                </label>
                <Input
                  id="duracao"
                  type="number"
                  min="5"
                  max="240"
                  value={novaAtividade.duracao}
                  onChange={e => setNovaAtividade({...novaAtividade, duracao: parseInt(e.target.value) || 30})}
                />
              </div>
            </div>
            
            <div>
              <label htmlFor="data" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Data
              </label>
              <Input
                id="data"
                type="date"
                value={novaAtividade.data}
                onChange={e => setNovaAtividade({...novaAtividade, data: e.target.value})}
              />
            </div>
            
            <div>
              <label htmlFor="observacoes" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Observações (opcional)
              </label>
              <Textarea
                id="observacoes"
                value={novaAtividade.observacoes}
                onChange={e => setNovaAtividade({...novaAtividade, observacoes: e.target.value})}
                placeholder="Detalhes adicionais sobre a atividade..."
              />
            </div>
            
            <Button onClick={handleAdicionarAtividade} className="w-full">
              Adicionar Atividade
            </Button>
          </div>
        </div>
      )}

      {/* Lista de atividades */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
          Suas Atividades
        </h3>
        
        {atividades.length === 0 ? (
          <div className="text-center py-8 text-gray-500 dark:text-gray-400">
            <Calendar className="h-12 w-12 mx-auto mb-2 opacity-50" />
            <p>Você ainda não tem nenhuma atividade de lazer registrada.</p>
            <p className="mt-1">Adicione uma atividade para começar a acompanhar.</p>
          </div>
        ) : (
          <div className="space-y-3">
            {atividades.map(atividade => (
              <div 
                key={atividade.id}
                className={`p-4 rounded-lg border ${
                  atividade.concluida 
                    ? 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700' 
                    : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700'
                }`}
              >
                <div className="flex justify-between items-start">
                  <div>
                    <div className="flex items-center">
                      <h4 className={`font-medium ${
                        atividade.concluida 
                          ? 'text-gray-500 dark:text-gray-400' 
                          : 'text-gray-900 dark:text-white'
                      }`}>
                        {atividade.nome}
                      </h4>
                      <Badge className="ml-2" variant={atividade.concluida ? "secondary" : "default"}>
                        {atividade.categoria}
                      </Badge>
                    </div>
                    
                    <div className="mt-1 text-sm text-gray-500 dark:text-gray-400 flex flex-wrap gap-3">
                      <span className="flex items-center">
                        <Clock className="h-4 w-4 mr-1" />
                        {atividade.duracao} min
                      </span>
                      <span className="flex items-center">
                        <Calendar className="h-4 w-4 mr-1" />
                        {new Date(atividade.data).toLocaleDateString('pt-BR')}
                      </span>
                    </div>
                    
                    {atividade.observacoes && (
                      <p className="mt-2 text-sm text-gray-600 dark:text-gray-300">
                        {atividade.observacoes}
                      </p>
                    )}
                  </div>
                  
                  <div className="flex space-x-2">
                    {!atividade.concluida && (
                      <Button 
                        variant="outline" 
                        size="sm"
                        onClick={() => marcarConcluida(atividade.id)}
                        aria-label="Marcar como concluída"
                      >
                        Concluir
                      </Button>
                    )}
                    <Button 
                      variant="destructive" 
                      size="sm"
                      onClick={() => removerAtividade(atividade.id)}
                      aria-label="Remover atividade"
                    >
                      <Trash className="h-4 w-4" />
                    </Button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/components/lazer/SugestoesDescanso.tsx">
'use client'

import { useState, useEffect } from 'react'
import { RefreshCw, Heart, ThumbsUp, ThumbsDown } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Badge } from '@/app/components/ui/Badge'
import { useSugestoesStore } from '@/app/stores/sugestoesStore'

// Lista de atividades de descanso por categoria
const atividadesDescanso = {
  rapidas: [
    "Faça uma pausa para respirar profundamente por 2 minutos",
    "Tome um copo de água e observe o ambiente ao redor",
    "Realize alongamentos simples para o pescoço e ombros",
    "Olhe pela janela e observe 5 coisas diferentes",
    "Faça uma pequena caminhada dentro de casa",
    "Pratique a técnica 5-4-3-2-1 (observe 5 coisas que você vê, 4 que você sente, etc)",
    "Faça um pequeno desenho abstrato em um papel",
    "Escute uma música que você goste",
  ],
  criativas: [
    "Colorir um pequeno desenho ou mandala",
    "Fazer um origami simples",
    "Escrever um haiku (poema de 3 linhas)",
    "Fazer um esboço rápido do que você vê",
    "Criar uma pequena colagem com materiais disponíveis",
    "Inventar uma história curta sobre um objeto aleatório",
    "Escrever três coisas pelas quais você é grato hoje",
    "Tocar um instrumento musical por alguns minutos (se disponível)",
  ],
  físicas: [
    "Dançar ao som de uma música animada",
    "Fazer 10 agachamentos",
    "Caminhar ao ar livre por 10 minutos",
    "Praticar yoga por 5-10 minutos",
    "Fazer um jogo rápido de arremesso com uma bolinha",
    "Pular corda por 2 minutos",
    "Subir e descer escadas algumas vezes",
    "Fazer alongamentos para todas as partes do corpo",
  ],
  relaxantes: [
    "Praticar meditação guiada de 5 minutos",
    "Fazer uma massagem nas próprias mãos",
    "Preparar e desfrutar de uma xícara de chá",
    "Observar a natureza pela janela ou ao ar livre",
    "Ouvir sons da natureza (chuva, pássaros, ondas)",
    "Fazer exercícios de respiração profunda",
    "Aplicar aromaterapia com óleos essenciais",
    "Deitar-se e relaxar todos os músculos por 5 minutos",
  ]
}

export function SugestoesDescanso() {
  const { sugestoesFavoritas, adicionarFavorita, removerFavorita } = useSugestoesStore()
  const [sugestaoAtual, setSugestaoAtual] = useState('')
  const [categoriaAtual, setCategoriaAtual] = useState<keyof typeof atividadesDescanso>('rapidas')
  
  // Função para gerar uma sugestão aleatória
  const gerarSugestaoAleatoria = () => {
    const categorias = Object.keys(atividadesDescanso) as Array<keyof typeof atividadesDescanso>
    const categoriaAleatoria = categorias[Math.floor(Math.random() * categorias.length)]
    
    const atividadesCategoria = atividadesDescanso[categoriaAleatoria]
    const sugestaoAleatoria = atividadesCategoria[Math.floor(Math.random() * atividadesCategoria.length)]
    
    setSugestaoAtual(sugestaoAleatoria)
    setCategoriaAtual(categoriaAleatoria)
  }

  // Gerar sugestão inicial ao montar o componente
  useEffect(() => {
    gerarSugestaoAleatoria()
  }, [])

  // Verificar se a sugestão atual está nos favoritos
  const estaNasFavoritas = sugestoesFavoritas.includes(sugestaoAtual)

  // Função para alternar favorito
  const toggleFavorita = () => {
    if (estaNasFavoritas) {
      removerFavorita(sugestaoAtual)
    } else {
      adicionarFavorita(sugestaoAtual)
    }
  }

  // Função para obter o nome exibido da categoria
  const getNomeCategoria = (categoria: keyof typeof atividadesDescanso) => {
    const nomes = {
      rapidas: 'Rápidas',
      criativas: 'Criativas',
      físicas: 'Físicas',
      relaxantes: 'Relaxantes'
    }
    return nomes[categoria]
  }

  // Função para obter a cor da categoria
  const getCorCategoria = (categoria: keyof typeof atividadesDescanso) => {
    const cores = {
      rapidas: 'bg-blue-100 text-blue-800 dark:bg-blue-700 dark:text-blue-100',
      criativas: 'bg-purple-100 text-purple-800 dark:bg-purple-700 dark:text-purple-100',
      físicas: 'bg-green-100 text-green-800 dark:bg-green-700 dark:text-green-100',
      relaxantes: 'bg-amber-100 text-amber-800 dark:bg-amber-700 dark:text-amber-100'
    }
    return cores[categoria]
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-4">
        <Button 
          onClick={gerarSugestaoAleatoria}
          size="sm"
          aria-label="Gerar nova sugestão"
        >
          <RefreshCw className="h-4 w-4 mr-2" />
          Nova Sugestão
        </Button>
      </div>

      {/* Sugestão atual */}
      <div className="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg mb-6 text-center relative">
        {sugestaoAtual && (
          <>
            <Badge 
              className={`absolute top-3 left-3 ${getCorCategoria(categoriaAtual)}`}
            >
              {getNomeCategoria(categoriaAtual)}
            </Badge>
            
            <p className="text-xl text-gray-900 dark:text-white font-medium mt-4">
              {sugestaoAtual}
            </p>
            
            <div className="flex justify-center mt-6 space-x-3">
              <Button
                variant={estaNasFavoritas ? "default" : "outline"}
                size="sm"
                onClick={toggleFavorita}
                aria-label={estaNasFavoritas ? "Remover dos favoritos" : "Adicionar aos favoritos"}
              >
                <Heart className={`h-4 w-4 mr-2 ${estaNasFavoritas ? 'fill-white' : ''}`} />
                {estaNasFavoritas ? 'Favorita' : 'Favoritar'}
              </Button>
              
              <Button
                variant="outline"
                size="sm"
                onClick={gerarSugestaoAleatoria}
                aria-label="Próxima sugestão"
              >
                <ThumbsDown className="h-4 w-4 mr-2" />
                Próxima
              </Button>
            </div>
          </>
        )}
      </div>

      {/* Sugestões Favoritas */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
          Sugestões Favoritas
        </h3>
        
        {sugestoesFavoritas.length === 0 ? (
          <div className="text-center py-4 text-gray-500 dark:text-gray-400">
            <Heart className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>Você ainda não tem sugestões favoritas.</p>
            <p className="mt-1">Adicione suas favoritas para acessá-las facilmente.</p>
          </div>
        ) : (
          <div className="space-y-2">
            {sugestoesFavoritas.map((sugestao, index) => (
              <div 
                key={index}
                className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg flex justify-between items-center"
              >
                <p className="text-gray-700 dark:text-gray-300">{sugestao}</p>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => removerFavorita(sugestao)}
                  aria-label="Remover dos favoritos"
                >
                  <Heart className="h-4 w-4 fill-red-500 text-red-500" />
                </Button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/components/lazer/TemporizadorLazer.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { Play, Pause, RotateCcw, Bell, Volume2, VolumeX } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Slider } from '@/app/components/ui/Slider'
import { Select } from '@/app/components/ui/Select'
import { Badge } from '@/app/components/ui/Badge'

export function TemporizadorLazer() {
  // Estados
  const [duracaoTotal, setDuracaoTotal] = useState(30) // em minutos
  const [tempoRestante, setTempoRestante] = useState(duracaoTotal * 60) // em segundos
  const [ativo, setAtivo] = useState(false)
  const [presetSelecionado, setPresetSelecionado] = useState('personalizado')
  const [somAtivado, setSomAtivado] = useState(true)
  
  // Refs
  const timerRef = useRef<NodeJS.Timeout | null>(null)
  const audioRef = useRef<HTMLAudioElement | null>(null)
  
  // Presets de tempo
  const presets = [
    { value: 'curto', label: 'Curto (15 min)', duracao: 15 },
    { value: 'medio', label: 'Médio (30 min)', duracao: 30 },
    { value: 'longo', label: 'Longo (45 min)', duracao: 45 },
    { value: 'extenso', label: 'Extenso (60 min)', duracao: 60 },
    { value: 'personalizado', label: 'Personalizado', duracao: duracaoTotal }
  ]

  // Inicializar áudio
  useEffect(() => {
    if (typeof window !== 'undefined') {
      audioRef.current = new Audio('/sounds/bell.mp3') // Certifique-se de ter este arquivo
    }
    
    return () => {
      // Limpar timer ao desmontar
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [])

  // Atualizar tempo restante quando duracaoTotal mudar
  useEffect(() => {
    setTempoRestante(duracaoTotal * 60)
  }, [duracaoTotal])

  // Iniciar/parar timer
  useEffect(() => {
    if (ativo) {
      timerRef.current = setInterval(() => {
        setTempoRestante(prev => {
          if (prev <= 1) {
            // Timer acabou
            if (somAtivado && audioRef.current) {
              audioRef.current.play().catch(e => console.error('Erro ao tocar som:', e))
            }
            clearInterval(timerRef.current!)
            setAtivo(false)
            return 0
          }
          return prev - 1
        })
      }, 1000)
    } else if (timerRef.current) {
      clearInterval(timerRef.current)
    }
    
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [ativo, somAtivado])

  // Formatar tempo para exibição (MM:SS)
  const formatarTempo = (segundos: number) => {
    const minutos = Math.floor(segundos / 60)
    const segundosRestantes = segundos % 60
    return `${minutos.toString().padStart(2, '0')}:${segundosRestantes.toString().padStart(2, '0')}`
  }

  // Calcular porcentagem de progresso
  const calcularProgresso = () => {
    const total = duracaoTotal * 60
    const progresso = ((total - tempoRestante) / total) * 100
    return progresso
  }

  // Lidar com mudança de preset
  const handleChangePreset = (valor: string) => {
    setPresetSelecionado(valor)
    
    if (valor !== 'personalizado') {
      const preset = presets.find(p => p.value === valor)
      if (preset) {
        setDuracaoTotal(preset.duracao)
      }
    }
  }

  // Resetar temporizador
  const resetarTemporizador = () => {
    setAtivo(false)
    if (timerRef.current) {
      clearInterval(timerRef.current)
    }
    setTempoRestante(duracaoTotal * 60)
  }

  // Alternar entre iniciar e pausar
  const toggleTimer = () => {
    setAtivo(!ativo)
  }

  return (
    <div className="flex flex-col space-y-4">
      <div className="flex justify-between items-center">
        <Button
          variant="outline"
          size="sm"
          onClick={() => setSomAtivado(!somAtivado)}
          aria-label={somAtivado ? 'Desativar som' : 'Ativar som'}
        >
          {somAtivado ? <Volume2 className="h-4 w-4" /> : <VolumeX className="h-4 w-4" />}
        </Button>
      </div>

      {/* Display do temporizador */}
      <div className="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg mb-6 text-center relative">
        <div className="absolute top-3 left-3 flex gap-2">
          {ativo && (
            <Badge variant="primary" className="animate-pulse">
              Em andamento
            </Badge>
          )}
        </div>
        
        {/* Tempo em formato grande */}
        <div className="text-6xl font-bold text-gray-900 dark:text-white py-8">
          {formatarTempo(tempoRestante)}
        </div>
        
        {/* Barra de progresso */}
        <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-6">
          <div 
            className="bg-lazer-primary h-2.5 rounded-full transition-all duration-1000"
            style={{ width: `${calcularProgresso()}%` }}
          />
        </div>
        
        {/* Controles */}
        <div className="flex justify-center space-x-4">
          <Button
            onClick={toggleTimer}
            size="lg"
            aria-label={ativo ? 'Pausar temporizador' : 'Iniciar temporizador'}
            className="w-32"
          >
            {ativo ? (
              <>
                <Pause className="h-5 w-5 mr-2" />
                Pausar
              </>
            ) : (
              <>
                <Play className="h-5 w-5 mr-2" />
                Iniciar
              </>
            )}
          </Button>
          
          <Button
            onClick={resetarTemporizador}
            variant="outline"
            size="lg"
            aria-label="Resetar temporizador"
            className="w-32"
          >
            <RotateCcw className="h-5 w-5 mr-2" />
            Resetar
          </Button>
        </div>
      </div>

      {/* Configurações do temporizador */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium text-gray-900 dark:text-white">
          Configurações
        </h3>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Presets de Tempo
          </label>
          <Select
            value={presetSelecionado}
            onChange={e => handleChangePreset(e.target.value)}
            options={presets}
            disabled={ativo}
          />
        </div>
        
        {presetSelecionado === 'personalizado' && (
          <div>
            <div className="flex justify-between items-center mb-1">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Duração (minutos): {duracaoTotal}
              </label>
            </div>
            <Slider
              min={5}
              max={120}
              step={5}
              value={duracaoTotal}
              onChange={setDuracaoTotal}
              disabled={ativo}
            />
          </div>
        )}
        
        <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg mt-4">
          <div className="flex items-start">
            <Bell className="h-5 w-5 text-yellow-500 dark:text-yellow-400 mr-3 mt-0.5" />
            <div>
              <h4 className="text-sm font-medium text-yellow-800 dark:text-yellow-300">
                Dica
              </h4>
              <p className="text-sm text-yellow-700 dark:text-yellow-400 mt-1">
                Use este temporizador para evitar o hiperfoco em atividades de lazer.
                Intervalos regulares ajudam a manter o equilíbrio em suas atividades diárias.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/perfil/DataMigration.tsx">
'use client'

import { useState, useCallback } from 'react'
import { usePriorities } from '../../hooks/usePriorities'
import { useToast } from '../../context/ToastContext'
import { LoadingIndicator } from '../ui/LoadingIndicator'

export function DataMigration() {
  const [isMigrating, setIsMigrating] = useState(false)
  const [showSuccess, setShowSuccess] = useState(false)
  const [migrationCount, setMigrationCount] = useState(0)
  const [duplicateCount, setDuplicateCount] = useState(0)
  const [shouldClearLocal, setShouldClearLocal] = useState(false)
  
  const { migrateFromLocalStorage, isLoading } = usePriorities()
  const { showToast } = useToast()
  
  // Verificar se existem dados no localStorage para prioridades
  const hasPrioritiesData = useCallback(() => {
    const localData = localStorage.getItem('prioridades-diarias')
    if (!localData) return false
    
    try {
      const parsedData = JSON.parse(localData)
      return parsedData?.state?.prioridades && Array.isArray(parsedData.state.prioridades) && parsedData.state.prioridades.length > 0
    } catch (e) {
      return false
    }
  }, [])
  
  // Função para limpar dados locais após migração
  const clearLocalData = useCallback(() => {
    localStorage.removeItem('prioridades-diarias')
    showToast('Dados locais removidos com sucesso', 'success')
  }, [showToast])
  
  // Iniciar o processo de migração
  const startMigration = async () => {
    setIsMigrating(true)
    
    try {
      const result = await migrateFromLocalStorage()
      
      if (result.success) {
        setShowSuccess(true)
        setMigrationCount(result.count)
        setDuplicateCount(result.duplicates)
        
        // Mensagem de sucesso personalizada com informações sobre duplicatas
        let mensagem = `${result.count} prioridades migradas com sucesso`
        if (result.duplicates > 0) {
          mensagem += ` (${result.duplicates} itens ignorados por já existirem)`
        }
        showToast(mensagem, 'success')
        
        if (shouldClearLocal && (result.count > 0 || result.duplicates > 0)) {
          clearLocalData()
        }
      } else {
        showToast(`Erro na migração: ${result.error}`, 'error')
      }
    } catch (error) {
      showToast('Erro ao migrar dados', 'error')
    } finally {
      setIsMigrating(false)
    }
  }
  
  // Reset do estado para permitir nova tentativa
  const resetState = () => {
    setShowSuccess(false)
    setMigrationCount(0)
    setDuplicateCount(0)
  }

  // Se não houver dados para migrar, mostrar mensagem
  if (!hasPrioritiesData()) {
    return (
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
        <h2 className="text-xl font-semibold mb-4">Migração de Dados</h2>
        <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-md text-blue-800 dark:text-blue-200">
          <p>Não foram encontrados dados locais para migrar.</p>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
      <h2 className="text-xl font-semibold mb-4">Migração de Dados</h2>
      
      {showSuccess ? (
        <div className="mb-4 p-4 bg-green-50 dark:bg-green-900/20 rounded-md text-green-800 dark:text-green-200">
          <p className="font-medium">Migração concluída com sucesso!</p>
          <p>{migrationCount} prioridades foram migradas para a nuvem.</p>
          {duplicateCount > 0 && (
            <p className="mt-1 text-amber-600 dark:text-amber-400">
              {duplicateCount} {duplicateCount === 1 ? 'item foi ignorado' : 'itens foram ignorados'} por já {duplicateCount === 1 ? 'existir' : 'existirem'} no banco de dados.
            </p>
          )}
          <button 
            onClick={resetState}
            className="mt-3 px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-green-500"
          >
            Entendi
          </button>
        </div>
      ) : (
        <>
          <div className="mb-6 p-4 bg-yellow-50 dark:bg-yellow-900/20 rounded-md text-yellow-800 dark:text-yellow-200">
            <p className="font-medium">Importante</p>
            <p>Esta ação irá migrar suas prioridades do armazenamento local para a nuvem. Isso permitirá que você acesse seus dados em qualquer dispositivo.</p>
            <p className="mt-2 text-sm">Itens idênticos já existentes no banco de dados serão ignorados para evitar duplicação.</p>
          </div>
          
          <div className="mb-6">
            <label className="flex items-center">
              <input
                type="checkbox"
                checked={shouldClearLocal}
                onChange={(e) => setShouldClearLocal(e.target.checked)}
                className="mr-2 h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
              <span>Remover dados locais após a migração</span>
            </label>
          </div>
          
          <button
            onClick={startMigration}
            disabled={isMigrating || isLoading}
            className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
          >
            {(isMigrating || isLoading) ? (
              <>
                <LoadingIndicator size="small" text="" />
                <span className="ml-2">Migrando dados...</span>
              </>
            ) : (
              <span>Iniciar Migração</span>
            )}
          </button>
        </>
      )}
    </div>
  )
}
</file>

<file path="app/components/perfil/InformacoesPessoais.tsx">
'use client'

import { useState } from 'react'
import { usePerfilStore } from '../../stores/perfilStore'
import { Save, User, Edit } from 'lucide-react'

export function InformacoesPessoais() {
  const { nome, atualizarNome } = usePerfilStore()
  const [novoNome, setNovoNome] = useState(nome)
  const [editando, setEditando] = useState(false)
  
  const iniciarEdicao = () => {
    setNovoNome(nome)
    setEditando(true)
  }
  
  const salvarAlteracoes = () => {
    if (novoNome.trim()) {
      atualizarNome(novoNome.trim())
    }
    setEditando(false)
  }
  
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6 mb-6">
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-4 flex items-center">
        <User className="h-5 w-5 mr-2 text-perfil-primary" />
        Informações Básicas
      </h2>
      
      <div className="space-y-4">
        {/* Nome do usuário */}
        <div>
          <label htmlFor="nome" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Nome
          </label>
          
          {editando ? (
            <div className="flex items-center">
              <input
                type="text"
                id="nome"
                value={novoNome}
                onChange={(e) => setNovoNome(e.target.value)}
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                placeholder="Seu nome"
                maxLength={30}
                required
              />
              
              <button
                onClick={salvarAlteracoes}
                className="ml-2 p-2 text-white bg-perfil-primary rounded-md hover:bg-perfil-secondary focus:outline-none focus:ring-2 focus:ring-perfil-primary"
                aria-label="Salvar nome"
              >
                <Save className="h-4 w-4" />
              </button>
            </div>
          ) : (
            <div className="flex items-center justify-between">
              <p className="text-gray-800 dark:text-white text-lg">{nome}</p>
              
              <button
                onClick={iniciarEdicao}
                className="p-2 text-gray-500 hover:text-perfil-primary focus:outline-none focus:ring-2 focus:ring-perfil-primary rounded-md"
                aria-label="Editar nome"
              >
                <Edit className="h-4 w-4" />
              </button>
            </div>
          )}
        </div>
        
        <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Seu nome é usado para personalizar a experiência no Painel ND. 
            As informações pessoais são armazenadas apenas no seu navegador.
          </p>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/perfil/MetasDiarias.tsx">
'use client'

import { useState } from 'react'
import { usePerfilStore } from '../../stores/perfilStore'
import { Save, Target, Clock, Droplet, Coffee } from 'lucide-react'

export function MetasDiarias() {
  const { metasDiarias, atualizarMetasDiarias } = usePerfilStore()
  const [editando, setEditando] = useState(false)
  const [metas, setMetas] = useState(metasDiarias)
  
  const iniciarEdicao = () => {
    setMetas({...metasDiarias})
    setEditando(true)
  }
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    const valorNumerico = parseInt(value)
    
    // Verificar se é um número válido
    if (!isNaN(valorNumerico)) {
      setMetas({
        ...metas,
        [name]: valorNumerico
      })
    }
  }
  
  const salvarAlteracoes = () => {
    atualizarMetasDiarias(metas)
    setEditando(false)
  }
  
  const cancelarEdicao = () => {
    setMetas({...metasDiarias})
    setEditando(false)
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6 mb-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-semibold text-gray-800 dark:text-white flex items-center">
          <Target className="h-5 w-5 mr-2 text-perfil-primary" />
          Metas Diárias
        </h2>
        
        {!editando ? (
          <button
            onClick={iniciarEdicao}
            className="px-3 py-2 text-sm text-white bg-perfil-primary rounded-md hover:bg-perfil-secondary focus:outline-none focus:ring-2 focus:ring-perfil-primary"
            aria-label="Editar metas"
          >
            Personalizar
          </button>
        ) : (
          <div className="flex gap-2">
            <button
              onClick={cancelarEdicao}
              className="px-3 py-2 text-sm text-gray-600 bg-gray-200 dark:text-gray-300 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none"
              aria-label="Cancelar edição"
            >
              Cancelar
            </button>
            <button
              onClick={salvarAlteracoes}
              className="px-3 py-2 text-sm text-white bg-perfil-primary rounded-md hover:bg-perfil-secondary focus:outline-none focus:ring-2 focus:ring-perfil-primary"
              aria-label="Salvar metas"
            >
              Salvar
            </button>
          </div>
        )}
      </div>
      
      <div className="space-y-5">
        {/* Horas de sono */}
        <div className={`flex items-center ${editando ? 'bg-perfil-light dark:bg-gray-700 p-3 rounded-md' : ''}`}>
          <div className="w-8 h-8 rounded-full bg-sono-primary flex items-center justify-center mr-3">
            <Clock className="w-4 h-4 text-white" />
          </div>
          
          <div className="flex-1">
            <div className="text-sm font-medium text-gray-500 dark:text-gray-400">
              Horas de sono
            </div>
            
            {editando ? (
              <div className="flex items-center mt-1">
                <input
                  type="number"
                  name="horasSono"
                  value={metas.horasSono}
                  onChange={handleChange}
                  min="4"
                  max="12"
                  className="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-800 dark:border-gray-600 dark:text-white"
                />
                <span className="ml-2 text-gray-700 dark:text-gray-300">horas</span>
              </div>
            ) : (
              <div className="text-lg font-medium text-gray-800 dark:text-white">
                {metasDiarias.horasSono} horas
              </div>
            )}
          </div>
        </div>
        
        {/* Tarefas prioritárias */}
        <div className={`flex items-center ${editando ? 'bg-perfil-light dark:bg-gray-700 p-3 rounded-md' : ''}`}>
          <div className="w-8 h-8 rounded-full bg-hiperfocos-primary flex items-center justify-center mr-3">
            <Target className="w-4 h-4 text-white" />
          </div>
          
          <div className="flex-1">
            <div className="text-sm font-medium text-gray-500 dark:text-gray-400">
              Tarefas prioritárias
            </div>
            
            {editando ? (
              <div className="flex items-center mt-1">
                <input
                  type="number"
                  name="tarefasPrioritarias"
                  value={metas.tarefasPrioritarias}
                  onChange={handleChange}
                  min="1"
                  max="7"
                  className="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-800 dark:border-gray-600 dark:text-white"
                />
                <span className="ml-2 text-gray-700 dark:text-gray-300">por dia</span>
              </div>
            ) : (
              <div className="text-lg font-medium text-gray-800 dark:text-white">
                {metasDiarias.tarefasPrioritarias} por dia
              </div>
            )}
          </div>
        </div>
        
        {/* Copos de água */}
        <div className={`flex items-center ${editando ? 'bg-perfil-light dark:bg-gray-700 p-3 rounded-md' : ''}`}>
          <div className="w-8 h-8 rounded-full bg-alimentacao-primary flex items-center justify-center mr-3">
            <Droplet className="w-4 h-4 text-white" />
          </div>
          
          <div className="flex-1">
            <div className="text-sm font-medium text-gray-500 dark:text-gray-400">
              Copos de água
            </div>
            
            {editando ? (
              <div className="flex items-center mt-1">
                <input
                  type="number"
                  name="coposAgua"
                  value={metas.coposAgua}
                  onChange={handleChange}
                  min="2"
                  max="15"
                  className="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-800 dark:border-gray-600 dark:text-white"
                />
                <span className="ml-2 text-gray-700 dark:text-gray-300">por dia</span>
              </div>
            ) : (
              <div className="text-lg font-medium text-gray-800 dark:text-white">
                {metasDiarias.coposAgua} por dia
              </div>
            )}
          </div>
        </div>
        
        {/* Pausas programadas */}
        <div className={`flex items-center ${editando ? 'bg-perfil-light dark:bg-gray-700 p-3 rounded-md' : ''}`}>
          <div className="w-8 h-8 rounded-full bg-lazer-primary flex items-center justify-center mr-3">
            <Coffee className="w-4 h-4 text-white" />
          </div>
          
          <div className="flex-1">
            <div className="text-sm font-medium text-gray-500 dark:text-gray-400">
              Pausas programadas
            </div>
            
            {editando ? (
              <div className="flex items-center mt-1">
                <input
                  type="number"
                  name="pausasProgramadas"
                  value={metas.pausasProgramadas}
                  onChange={handleChange}
                  min="2"
                  max="10"
                  className="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-800 dark:border-gray-600 dark:text-white"
                />
                <span className="ml-2 text-gray-700 dark:text-gray-300">por dia</span>
              </div>
            ) : (
              <div className="text-lg font-medium text-gray-800 dark:text-white">
                {metasDiarias.pausasProgramadas} por dia
              </div>
            )}
          </div>
        </div>
      </div>
      
      <div className="mt-5 pt-4 border-t border-gray-200 dark:border-gray-700">
        <p className="text-sm text-gray-500 dark:text-gray-400">
          Suas metas diárias são usadas para personalizar recomendações e lembretes em todo o painel.
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/components/perfil/PreferenciasVisuais.tsx">
'use client'

import { usePerfilStore } from '../../stores/perfilStore'
import { Eye, BarChart2, Type, Bell, Coffee, Moon } from 'lucide-react'

export function PreferenciasVisuais() {
  const { 
    preferenciasVisuais, 
    atualizarPreferenciasVisuais, 
    notificacoesAtivas, 
    pausasAtivas,
    alternarNotificacoes,
    alternarPausas
  } = usePerfilStore()
  
  const toggleAltoContraste = () => {
    atualizarPreferenciasVisuais({ altoContraste: !preferenciasVisuais.altoContraste })
    
    // Aplicar classes ao documento para alto contraste
    if (!preferenciasVisuais.altoContraste) {
      document.documentElement.classList.add('alto-contraste')
    } else {
      document.documentElement.classList.remove('alto-contraste')
    }
  }
  
  const toggleReducaoEstimulos = () => {
    atualizarPreferenciasVisuais({ reducaoEstimulos: !preferenciasVisuais.reducaoEstimulos })
    
    // Aplicar classes ao documento para redução de estímulos
    if (!preferenciasVisuais.reducaoEstimulos) {
      document.documentElement.classList.add('reducao-estimulos')
    } else {
      document.documentElement.classList.remove('reducao-estimulos')
    }
  }
  
  const toggleTextoGrande = () => {
    atualizarPreferenciasVisuais({ textoGrande: !preferenciasVisuais.textoGrande })
    
    // Aplicar classes ao documento para texto grande
    if (!preferenciasVisuais.textoGrande) {
      document.documentElement.classList.add('texto-grande')
    } else {
      document.documentElement.classList.remove('texto-grande')
    }
  }
  
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6">
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-4 flex items-center">
        <Eye className="h-5 w-5 mr-2 text-perfil-primary" />
        Preferências de Acessibilidade
      </h2>
      
      <div className="space-y-5">
        {/* Modos visuais */}
        <div>
          <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
            Modos Visuais
          </h3>
          
          <div className="space-y-3">
            {/* Alto contraste */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-gray-900 flex items-center justify-center mr-3">
                  <BarChart2 className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Alto Contraste
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Aumenta o contraste para melhor legibilidade
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={preferenciasVisuais.altoContraste}
                onClick={toggleAltoContraste}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  preferenciasVisuais.altoContraste ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar alto contraste</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    preferenciasVisuais.altoContraste ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
            
            {/* Redução de estímulos */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-gray-500 flex items-center justify-center mr-3">
                  <Moon className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Redução de Estímulos
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Remove animações e reduz cores intensas
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={preferenciasVisuais.reducaoEstimulos}
                onClick={toggleReducaoEstimulos}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  preferenciasVisuais.reducaoEstimulos ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar redução de estímulos</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    preferenciasVisuais.reducaoEstimulos ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
            
            {/* Texto grande */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center mr-3">
                  <Type className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Texto Grande
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Aumenta o tamanho do texto em toda a aplicação
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={preferenciasVisuais.textoGrande}
                onClick={toggleTextoGrande}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  preferenciasVisuais.textoGrande ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar texto grande</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    preferenciasVisuais.textoGrande ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
          </div>
        </div>
        
        {/* Preferências gerais */}
        <div className="pt-5 border-t border-gray-200 dark:border-gray-700">
          <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
            Preferências Gerais
          </h3>
          
          <div className="space-y-3">
            {/* Notificações */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center mr-3">
                  <Bell className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Lembretes
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Exibir lembretes visuais no painel
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={notificacoesAtivas}
                onClick={alternarNotificacoes}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  notificacoesAtivas ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar notificações</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    notificacoesAtivas ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
            
            {/* Pausas */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center mr-3">
                  <Coffee className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Pausas Programadas
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Exibir lembretes para fazer pausas
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={pausasAtivas}
                onClick={alternarPausas}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  pausasAtivas ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar pausas programadas</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    pausasAtivas ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <div className="mt-5 pt-4 border-t border-gray-200 dark:border-gray-700">
        <p className="text-sm text-gray-500 dark:text-gray-400">
          As preferências visuais são aplicadas imediatamente e salvas automaticamente para uso futuro.
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/components/providers/supabase-provider.tsx">
import { createContext, useContext, useState, useEffect, useRef } from 'react'
import { SupabaseClient } from '@supabase/supabase-js'
import { createClient } from '@/app/lib/supabase'
import { Database } from '@/app/types/supabase'

interface SupabaseContextType {
  supabase: SupabaseClient<Database>
}

const SupabaseContext = createContext<SupabaseContextType | undefined>(undefined)

export function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const [supabase] = useState(() => createClient())
  
  // Ref para armazenar a subscription
  const authSubscriptionRef = useRef<{ unsubscribe: () => void } | null>(null);

  useEffect(() => {
    // Verificar e limpar subscription anterior se existir
    if (authSubscriptionRef.current) {
      authSubscriptionRef.current.unsubscribe();
    }
    
    // Criar nova subscription e armazenar referência
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      if (event === 'SIGNED_OUT') {
        // Delete all data from local storage
        for (const key in localStorage) {
          if (key.startsWith('app-storage')) {
            localStorage.removeItem(key)
          }
        }
      }
    })
    
    // Armazenar referência para limpeza posterior
    authSubscriptionRef.current = subscription;

    return () => {
      // Garantir que a subscription seja cancelada na desmontagem
      if (authSubscriptionRef.current) {
        authSubscriptionRef.current.unsubscribe();
        authSubscriptionRef.current = null;
      }
    }
  }, [supabase])

  return (
    <SupabaseContext.Provider value={{ supabase }}>
      {children}
    </SupabaseContext.Provider>
  )
}

export function useSupabase() {
  const context = useContext(SupabaseContext)
  if (context === undefined) {
    throw new Error('useSupabase must be used within a SupabaseProvider')
  }
  return context
}
</file>

<file path="app/components/saude/DataExportForm.tsx">
import { useState } from 'react';
import { useAuthContext } from '@/app/context/AuthContext';
import { useToast } from '@/app/hooks/useToast';
import { ExportFormat, ModuleType, exportSupabaseData } from '@/app/lib/supabaseExport';

/**
 * Componente de formulário para exportação de dados do Supabase
 * Permite que o usuário selecione quais módulos exportar e o formato desejado
 */
export default function DataExportForm() {
  const { user } = useAuthContext();
  const { showToast } = useToast();
  
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');
  const [format, setFormat] = useState<ExportFormat>('pdf');
  const [isExporting, setIsExporting] = useState(false);
  
  // Módulos selecionados para exportação
  const [selectedModules, setSelectedModules] = useState<{
    priorities: boolean;
    sleep_records: boolean;
    mood_records: boolean;
    medications: boolean;
  }>({
    priorities: true,
    sleep_records: true,
    mood_records: true,
    medications: true,
  });
  
  /**
   * Atualiza o estado dos módulos selecionados
   */
  const handleModuleChange = (module: keyof typeof selectedModules) => {
    setSelectedModules(prev => ({
      ...prev,
      [module]: !prev[module]
    }));
  };
  
  /**
   * Atualiza o formato de exportação
   */
  const handleFormatChange = (newFormat: ExportFormat) => {
    setFormat(newFormat);
  };
  
  /**
   * Inicia o processo de exportação de dados
   */
  const handleExport = async () => {
    // Verificar se pelo menos um módulo está selecionado
    const modules = Object.entries(selectedModules)
      .filter(([_, selected]) => selected)
      .map(([module]) => module as ModuleType);
      
    if (modules.length === 0) {
      showToast('Selecione pelo menos um módulo para exportar', 'error');
      return;
    }
    
    setIsExporting(true);
    
    try {
      // Converter datas de string para Date se fornecidas
      const startDateObj = startDate ? new Date(startDate) : undefined;
      const endDateObj = endDate ? new Date(endDate) : undefined;
      
      // Chamar função de exportação
      const result = await exportSupabaseData(user, {
        modules,
        format,
        startDate: startDateObj,
        endDate: endDateObj,
      });
      
      if (result.success) {
        showToast(result.message || 'Dados exportados com sucesso', 'success');
      } else {
        showToast(result.error || 'Erro ao exportar dados', 'error');
      }
    } catch (error) {
      console.error('Erro ao exportar dados:', error);
      showToast('Ocorreu um erro ao exportar dados', 'error');
    } finally {
      setIsExporting(false);
    }
  };
  
  return (
    <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md">
      <h2 className="text-xl font-semibold mb-4">Exportar Dados</h2>
      
      <div className="space-y-6">
        {/* Seleção de módulos */}
        <div>
          <h3 className="text-md font-medium mb-2">Dados para exportar:</h3>
          <div className="space-y-2">
            <div className="flex items-center">
              <input
                type="checkbox"
                id="priorities"
                checked={selectedModules.priorities}
                onChange={() => handleModuleChange('priorities')}
                className="mr-2"
              />
              <label htmlFor="priorities">Prioridades</label>
            </div>
            <div className="flex items-center">
              <input
                type="checkbox"
                id="sleep_records"
                checked={selectedModules.sleep_records}
                onChange={() => handleModuleChange('sleep_records')}
                className="mr-2"
              />
              <label htmlFor="sleep_records">Registros de Sono</label>
            </div>
            <div className="flex items-center">
              <input
                type="checkbox"
                id="mood_records"
                checked={selectedModules.mood_records}
                onChange={() => handleModuleChange('mood_records')}
                className="mr-2"
              />
              <label htmlFor="mood_records">Registros de Humor</label>
            </div>
            <div className="flex items-center">
              <input
                type="checkbox"
                id="medications"
                checked={selectedModules.medications}
                onChange={() => handleModuleChange('medications')}
                className="mr-2"
              />
              <label htmlFor="medications">Medicamentos</label>
            </div>
          </div>
        </div>
        
        {/* Filtro de período */}
        <div>
          <h3 className="text-md font-medium mb-2">Período (opcional):</h3>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label htmlFor="startDate" className="block text-sm mb-1">Data inicial:</label>
              <input
                type="date"
                id="startDate"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
              />
            </div>
            <div>
              <label htmlFor="endDate" className="block text-sm mb-1">Data final:</label>
              <input
                type="date"
                id="endDate"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
              />
            </div>
          </div>
        </div>
        
        {/* Seleção de formato */}
        <div>
          <h3 className="text-md font-medium mb-2">Formato:</h3>
          <div className="flex space-x-4">
            <div className="flex items-center">
              <input
                type="radio"
                id="formatPdf"
                checked={format === 'pdf'}
                onChange={() => handleFormatChange('pdf')}
                className="mr-2"
              />
              <label htmlFor="formatPdf">PDF</label>
            </div>
            <div className="flex items-center">
              <input
                type="radio"
                id="formatCsv"
                checked={format === 'csv'}
                onChange={() => handleFormatChange('csv')}
                className="mr-2"
              />
              <label htmlFor="formatCsv">CSV</label>
            </div>
          </div>
          <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
            {format === 'pdf' 
              ? 'PDF é ideal para compartilhar com profissionais de saúde.' 
              : 'CSV é ideal para análise em planilhas eletrônicas.'}
          </p>
        </div>
        
        {/* Botão de exportação */}
        <div>
          <button
            onClick={handleExport}
            disabled={isExporting}
            className="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isExporting ? 'Exportando...' : 'Exportar Dados'}
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/components/saude/FatoresHumor.tsx">
'use client'

import { useMemo } from 'react'
import { RegistroHumor } from '@/app/store'
import { Card } from '../ui/Card'
import { Badge } from '../ui/Badge'

interface FatoresHumorProps {
  registros: RegistroHumor[]
  limite?: number
}

export function FatoresHumor({ registros, limite = 5 }: FatoresHumorProps) {
  // Calcula os fatores mais comuns
  const fatoresMaisComuns = useMemo(() => {
    const contagem: Record<string, number> = {}
    
    // Conta a ocorrência de cada fator
    registros.forEach(registro => {
      registro.fatores.forEach(fator => {
        contagem[fator] = (contagem[fator] || 0) + 1
      })
    })
    
    // Converte para array e ordena
    return Object.entries(contagem)
      .sort((a, b) => b[1] - a[1])
      .slice(0, limite)
      .map(([fator, count]) => ({
        fator,
        count,
        percentual: Math.round((count / registros.length) * 100)
      }))
  }, [registros, limite])
  
  if (registros.length === 0) {
    return (
      <Card className="p-4 text-center text-gray-500 dark:text-gray-400">
        Nenhum registro de humor encontrado
      </Card>
    )
  }
  
  return (
    <Card>
      <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
        Fatores Mais Comuns
      </h3>
      
      {fatoresMaisComuns.length === 0 ? (
        <p className="text-sm text-gray-500 dark:text-gray-400">
          Nenhum fator registrado ainda
        </p>
      ) : (
        <div className="space-y-2">
          {fatoresMaisComuns.map(({ fator, count, percentual }) => (
            <div key={fator} className="flex items-center justify-between">
              <div className="flex items-center">
                <Badge variant="secondary" className="mr-2">
                  {percentual}%
                </Badge>
                <span className="text-sm text-gray-700 dark:text-gray-300">
                  {fator}
                </span>
              </div>
              <span className="text-xs text-gray-500 dark:text-gray-400">
                {count} {count === 1 ? 'ocorrência' : 'ocorrências'}
              </span>
            </div>
          ))}
        </div>
      )}
    </Card>
  )
}
</file>

<file path="app/components/saude/HumorCalendar.tsx">
'use client'

import { useMemo } from 'react'
import { RegistroHumor } from '@/app/store'
import { cn } from '@/app/lib/utils'

interface HumorCalendarProps {
  registros: RegistroHumor[]
  mes: number
  ano: number
  onSelectDay: (data: string) => void
}

export function HumorCalendar({ registros, mes, ano, onSelectDay }: HumorCalendarProps) {
  // Gera os dias do mês selecionado
  const diasDoMes = useMemo(() => {
    const resultado = []
    const primeiroDia = new Date(ano, mes, 1)
    const ultimoDia = new Date(ano, mes + 1, 0)
    const diasNoMes = ultimoDia.getDate()
    
    // Preenche com dias vazios até o primeiro dia do mês
    const diaDaSemanaInicial = primeiroDia.getDay()
    for (let i = 0; i < diaDaSemanaInicial; i++) {
      resultado.push({ dia: 0, data: '' })
    }
    
    // Adiciona os dias do mês
    for (let dia = 1; dia <= diasNoMes; dia++) {
      const data = `${ano}-${String(mes + 1).padStart(2, '0')}-${String(dia).padStart(2, '0')}`
      resultado.push({ dia, data })
    }
    
    return resultado
  }, [mes, ano])
  
  // Mapeia os registros por data para fácil acesso
  const registrosPorData = useMemo(() => {
    const mapa: Record<string, RegistroHumor> = {}
    registros.forEach(registro => {
      mapa[registro.data] = registro
    })
    return mapa
  }, [registros])
  
  // Cores para os diferentes níveis de humor
  const coresHumor = {
    1: 'bg-red-500',
    2: 'bg-orange-400',
    3: 'bg-yellow-300',
    4: 'bg-green-300',
    5: 'bg-green-500',
  }
  
  // Nomes dos dias da semana
  const diasDaSemana = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb']
  
  return (
    <div className="w-full">
      <div className="grid grid-cols-7 gap-1 mb-1">
        {diasDaSemana.map((dia) => (
          <div 
            key={dia} 
            className="text-xs text-center font-medium text-gray-500 dark:text-gray-400"
          >
            {dia}
          </div>
        ))}
      </div>
      
      <div className="grid grid-cols-7 gap-1">
        {diasDoMes.map((item, index) => {
          if (item.dia === 0) {
            return <div key={`empty-${index}`} className="h-8 rounded-md" />
          }
          
          const registro = registrosPorData[item.data]
          const nivelHumor = registro?.nivel
          
          return (
            <button
              key={item.data}
              onClick={() => onSelectDay(item.data)}
              className={cn(
                "h-8 rounded-md flex items-center justify-center text-xs relative",
                nivelHumor 
                  ? coresHumor[nivelHumor as keyof typeof coresHumor] 
                  : "bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700",
                nivelHumor && "hover:opacity-80"
              )}
              aria-label={`Dia ${item.dia}, nível de humor ${nivelHumor || 'não registrado'}`}
            >
              {item.dia}
            </button>
          )
        })}
      </div>
    </div>
  )
}
</file>

<file path="app/components/saude/MedicamentosList.tsx">
'use client'

import { useMemo } from 'react'
import { Medicamento } from '@/app/store'
import { Card } from '../ui/Card'
import { Badge } from '../ui/Badge'
import { Pill, Clock, Edit, Trash2 } from 'lucide-react'
import { Button } from '../ui/Button'
import { format } from 'date-fns'
import { ptBR } from 'date-fns/locale'
import { Check, X, AlertCircle } from 'lucide-react'
import { Tooltip } from '../ui/Tooltip'

interface MedicamentosListProps {
  medicamentos: Medicamento[]
  onEdit: (id: string) => void
  onDelete: (id: string) => void
  onRegistrarTomada: (id: string) => void
}

export function MedicamentosList({
  medicamentos,
  onEdit,
  onDelete,
  onRegistrarTomada,
}: MedicamentosListProps) {
  // Ordena medicamentos por nome
  const medicamentosOrdenados = useMemo(() => {
    return [...medicamentos].sort((a, b) => a.nome.localeCompare(b.nome))
  }, [medicamentos])
  
  // Verifica se um medicamento foi tomado hoje
  const foiTomadoHoje = (medicamento: Medicamento) => {
    if (!medicamento.ultimaTomada) return false
    
    const hoje = new Date().toISOString().split('T')[0]
    return medicamento.ultimaTomada.includes(hoje)
  }
  
  // Função auxiliar para calcular se já pode tomar outra dose
  const podeTomar = (medicamento: Medicamento) => {
    if (!medicamento.ultimaTomada || !medicamento.intervalo) return true;
    
    const ultimaTomada = new Date(medicamento.ultimaTomada);
    const agora = new Date();
    const intervaloEmMinutos = medicamento.intervalo;
    
    // Calcula a diferença em minutos
    const diffEmMinutos = Math.floor((agora.getTime() - ultimaTomada.getTime()) / (1000 * 60));
    
    return diffEmMinutos >= intervaloEmMinutos;
  };
  
  // Formatar o tempo restante para próxima dose
  const formatarTempoRestante = (medicamento: Medicamento) => {
    if (!medicamento.ultimaTomada || !medicamento.intervalo) return "";
    
    const ultimaTomada = new Date(medicamento.ultimaTomada);
    const agora = new Date();
    const intervaloEmMinutos = medicamento.intervalo;
    
    // Calcula a diferença em minutos
    const diffEmMinutos = Math.floor((agora.getTime() - ultimaTomada.getTime()) / (1000 * 60));
    const minutosRestantes = intervaloEmMinutos - diffEmMinutos;
    
    if (minutosRestantes <= 0) return "";
    
    const horasRestantes = Math.floor(minutosRestantes / 60);
    const minRestantes = minutosRestantes % 60;
    
    if (horasRestantes > 0) {
      return `${horasRestantes}h${minRestantes > 0 ? ` ${minRestantes}min` : ''}`;
    }
    return `${minRestantes}min`;
  };

  if (medicamentosOrdenados.length === 0) {
    return (
      <div className="text-center py-8 border border-dashed border-gray-300 dark:border-gray-600 rounded-lg">
        <Pill className="mx-auto h-10 w-10 text-gray-400 mb-2" />
        <p className="text-gray-500 dark:text-gray-400">
          Você ainda não tem medicamentos cadastrados.
        </p>
        <p className="text-gray-400 dark:text-gray-500 text-sm mt-1">
          Adicione seu primeiro medicamento clicando no botão acima.
        </p>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {medicamentosOrdenados.map((medicamento) => {
        const tomadoHoje = medicamento.ultimaTomada
          ? new Date(medicamento.ultimaTomada).toISOString().split('T')[0] === new Date().toISOString().split('T')[0]
          : false;
          
        const tempoRestante = formatarTempoRestante(medicamento);
        const liberadoParaTomar = podeTomar(medicamento);

        return (
          <div
            key={medicamento.id}
            className={`p-4 bg-white dark:bg-gray-800 border rounded-lg ${
              tomadoHoje
                ? 'border-green-200 dark:border-green-900'
                : 'border-gray-200 dark:border-gray-700'
            }`}
          >
            <div className="flex items-start justify-between">
              <div className="flex-1">
                <div className="flex items-center mb-1">
                  <h3 className="font-medium text-gray-900 dark:text-white">
                    {medicamento.nome}
                  </h3>
                  {medicamento.dosagem && (
                    <Badge className="ml-2" variant="outline">
                      {medicamento.dosagem}
                    </Badge>
                  )}
                </div>

                <div className="flex flex-wrap gap-1 mt-2">
                  {medicamento.horarios.map((horario) => (
                    <Badge key={horario} variant="secondary" className="flex items-center">
                      <Clock className="h-3 w-3 mr-1" />
                      {horario}
                    </Badge>
                  ))}
                </div>
                
                {medicamento.frequencia && (
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">
                    Frequência: {medicamento.frequencia}
                  </p>
                )}
                
                {medicamento.intervalo && (
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                    Intervalo: {medicamento.intervalo >= 60 
                      ? `${Math.floor(medicamento.intervalo / 60)} hora${medicamento.intervalo >= 120 ? 's' : ''}` 
                      : `${medicamento.intervalo} minutos`}
                  </p>
                )}
                
                {medicamento.ultimaTomada && (
                  <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">
                    Última dose: {format(new Date(medicamento.ultimaTomada), "dd/MM/yyyy 'às' HH:mm", { locale: ptBR })}
                    {tempoRestante && (
                      <span className="ml-2 text-yellow-600 dark:text-yellow-400">
                        <AlertCircle className="inline h-3 w-3 mr-1" />
                        Próxima dose em {tempoRestante}
                      </span>
                    )}
                  </p>
                )}
              </div>

              <div className="flex flex-col gap-2 ml-4">
                <Tooltip content={liberadoParaTomar ? "Registrar dose tomada" : "Aguarde o intervalo entre doses"}>
                  <Button
                    size="icon"
                    variant={tomadoHoje ? "success" : "primary"}
                    onClick={() => onRegistrarTomada(medicamento.id)}
                    disabled={!liberadoParaTomar}
                    aria-label="Registrar dose tomada"
                  >
                    {tomadoHoje ? <Check className="h-4 w-4" /> : <Pill className="h-4 w-4" />}
                  </Button>
                </Tooltip>
                
                <Button
                  size="icon"
                  variant="outline"
                  onClick={() => onEdit(medicamento.id)}
                  aria-label="Editar medicamento"
                >
                  <Edit className="h-4 w-4" />
                </Button>
                
                <Button
                  size="icon"
                  variant="outline"
                  color="danger"
                  onClick={() => onDelete(medicamento.id)}
                  aria-label="Excluir medicamento"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        )
      })}
    </div>
  )
}

// Importando o utilitário cn
import { cn } from '@/app/lib/utils'
</file>

<file path="app/components/saude/MedicationDataMigration.tsx">
import { useState, useEffect } from 'react';
import { useMedications } from '@/app/hooks/useMedications';
import { useToast } from '@/app/hooks/useToast';

interface MedicationDataMigrationProps {
  onMigrationComplete?: () => void;
}

export default function MedicationDataMigration({ onMigrationComplete }: MedicationDataMigrationProps) {
  const { migrateFromLocalStorage, isLoading, error } = useMedications();
  const { showToast } = useToast();
  
  const [hasLocalData, setHasLocalData] = useState(false);
  const [shouldClearLocal, setShouldClearLocal] = useState(true);
  const [isMigrating, setIsMigrating] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [migrationCount, setMigrationCount] = useState(0);
  const [duplicateCount, setDuplicateCount] = useState(0);
  
  // Verificar se há dados locais para migrar
  useEffect(() => {
    const localData = localStorage.getItem('zustand');
    if (localData) {
      try {
        const parsedData = JSON.parse(localData);
        if (parsedData?.state?.medicamentos && parsedData.state.medicamentos.length > 0) {
          setHasLocalData(true);
        }
      } catch (e) {
        console.error('Erro ao analisar dados locais:', e);
      }
    }
  }, []);
  
  // Limpar dados locais após migração bem-sucedida
  const clearLocalData = () => {
    try {
      const localData = localStorage.getItem('zustand');
      if (localData) {
        const parsedData = JSON.parse(localData);
        
        if (parsedData?.state?.medicamentos) {
          parsedData.state.medicamentos = [];
          localStorage.setItem('zustand', JSON.stringify(parsedData));
          showToast('Dados locais de medicamentos removidos com sucesso', 'success');
        }
      }
    } catch (e) {
      console.error('Erro ao limpar dados locais:', e);
      showToast('Erro ao limpar dados locais', 'error');
    }
  };
  
  // Iniciar o processo de migração
  const startMigration = async () => {
    setIsMigrating(true);
    
    try {
      const result = await migrateFromLocalStorage();
      
      if (result.success) {
        setShowSuccess(true);
        setMigrationCount(result.count);
        setDuplicateCount(result.duplicates);
        
        let message = `${result.count} medicamentos migrados com sucesso`;
        if (result.duplicates > 0) {
          message += ` (${result.duplicates} duplicados ignorados)`;
        }
        
        showToast(message, 'success');
        
        if (shouldClearLocal && result.count > 0) {
          clearLocalData();
        }
        
        if (onMigrationComplete) {
          onMigrationComplete();
        }
      } else {
        showToast(`Erro na migração: ${result.error}`, 'error');
      }
    } catch (err) {
      showToast('Erro ao migrar dados', 'error');
    } finally {
      setIsMigrating(false);
    }
  };
  
  // Se não houver dados para migrar, não renderize nada
  if (!hasLocalData && !showSuccess) {
    return null;
  }
  
  return (
    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
      <h3 className="text-lg font-medium mb-2">
        {showSuccess ? 'Migração Concluída!' : 'Migrar Dados de Medicamentos'}
      </h3>
      
      {!showSuccess ? (
        <>
          <p className="text-gray-600 dark:text-gray-300 mb-4">
            Encontramos medicamentos armazenados localmente neste dispositivo.
            Você deseja migrá-los para a nuvem?
          </p>
          
          <div className="flex items-center mb-4">
            <input
              type="checkbox"
              id="clearLocal"
              checked={shouldClearLocal}
              onChange={(e) => setShouldClearLocal(e.target.checked)}
              className="mr-2"
            />
            <label htmlFor="clearLocal" className="text-sm">
              Remover dados locais após migração bem-sucedida
            </label>
          </div>
          
          <div className="flex justify-end space-x-2">
            <button
              onClick={startMigration}
              disabled={isMigrating}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
            >
              {isMigrating ? 'Migrando...' : 'Migrar Dados'}
            </button>
          </div>
          
          {error && (
            <p className="text-red-500 mt-2 text-sm">{error.message}</p>
          )}
        </>
      ) : (
        <>
          <p className="text-gray-600 dark:text-gray-300 mb-2">
            {migrationCount > 0 
              ? `${migrationCount} medicamentos foram migrados com sucesso para a nuvem.` 
              : 'Nenhum novo medicamento precisou ser migrado.'}
          </p>
          
          {duplicateCount > 0 && (
            <p className="text-yellow-600 dark:text-yellow-400 mb-2 text-sm">
              {duplicateCount} medicamentos foram ignorados por já existirem no banco de dados.
            </p>
          )}
          
          {shouldClearLocal && migrationCount > 0 && (
            <p className="text-green-600 dark:text-green-400 text-sm">
              Os dados locais foram removidos com sucesso.
            </p>
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="app/components/saude/MedicationForm.tsx">
import { useState, useEffect } from 'react';
import { useMedications } from '@/app/hooks/useMedications';
import { useToast } from '@/app/hooks/useToast';
import { Medication, NewMedication } from '@/app/types/supabase';

interface MedicationFormProps {
  onSuccess?: () => void;
  initialData?: Medication;
}

export default function MedicationForm({ onSuccess, initialData }: MedicationFormProps) {
  const { addMedication, updateMedication, isLoading, error, resetError } = useMedications();
  const { showToast } = useToast();
  
  // Estado do formulário
  const [name, setName] = useState(initialData?.name || '');
  const [dosage, setDosage] = useState(initialData?.dosage || '');
  const [frequency, setFrequency] = useState(initialData?.frequency || 'Diária');
  const [schedule, setSchedule] = useState<string[]>(initialData?.schedule || ['08:00']);
  const [startDate, setStartDate] = useState(initialData?.start_date || new Date().toISOString().split('T')[0]);
  const [notes, setNotes] = useState(initialData?.notes || '');
  const [intervalMinutes, setIntervalMinutes] = useState(initialData?.interval_minutes || 240); // 4 horas por padrão
  const [newScheduleTime, setNewScheduleTime] = useState('08:00');
  
  // Resetar erro quando mudar os campos do formulário
  useEffect(() => {
    if (error) resetError();
  }, [name, dosage, frequency, schedule, startDate, notes, intervalMinutes, error, resetError]);
  
  // Adicionar horário ao cronograma
  const handleAddScheduleTime = () => {
    if (newScheduleTime && !schedule.includes(newScheduleTime)) {
      setSchedule([...schedule, newScheduleTime]);
    }
  };
  
  // Remover horário do cronograma
  const handleRemoveScheduleTime = (timeToRemove: string) => {
    setSchedule(schedule.filter(time => time !== timeToRemove));
  };
  
  // Enviar formulário
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!name) {
      showToast('O nome do medicamento é obrigatório', 'error');
      return;
    }
    
    if (schedule.length === 0) {
      showToast('Adicione pelo menos um horário', 'error');
      return;
    }
    
    const medicationData: NewMedication = {
      name,
      dosage: dosage || null,
      frequency,
      schedule,
      start_date: startDate || null,
      notes: notes || null,
      interval_minutes: intervalMinutes
    };
    
    let success;
    
    if (initialData) {
      // Atualizar medicamento existente
      const updated = await updateMedication(initialData.id, medicationData);
      success = !!updated;
      
      if (success) {
        showToast('Medicamento atualizado com sucesso', 'success');
      }
    } else {
      // Adicionar novo medicamento
      const created = await addMedication(medicationData);
      success = !!created;
      
      if (success) {
        showToast('Medicamento adicionado com sucesso', 'success');
        // Resetar formulário se for novo medicamento
        setName('');
        setDosage('');
        setFrequency('Diária');
        setSchedule(['08:00']);
        setStartDate(new Date().toISOString().split('T')[0]);
        setNotes('');
        setIntervalMinutes(240);
        setNewScheduleTime('08:00');
      }
    }
    
    if (!success) {
      showToast('Erro ao salvar medicamento', 'error');
    } else if (onSuccess) {
      onSuccess();
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
      <h3 className="text-lg font-medium mb-4">
        {initialData ? 'Editar Medicamento' : 'Novo Medicamento'}
      </h3>
      
      {/* Nome e Dosagem */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div>
          <label htmlFor="name" className="block text-sm font-medium mb-1">
            Nome do Medicamento*
          </label>
          <input
            type="text"
            id="name"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
            required
          />
        </div>
        
        <div>
          <label htmlFor="dosage" className="block text-sm font-medium mb-1">
            Dosagem
          </label>
          <input
            type="text"
            id="dosage"
            value={dosage || ''}
            onChange={(e) => setDosage(e.target.value)}
            placeholder="ex: 10mg, 1 comprimido"
            className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
          />
        </div>
      </div>
      
      {/* Frequência e Data de Início */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div>
          <label htmlFor="frequency" className="block text-sm font-medium mb-1">
            Frequência*
          </label>
          <select
            id="frequency"
            value={frequency}
            onChange={(e) => setFrequency(e.target.value)}
            className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
            required
          >
            <option value="Diária">Diária</option>
            <option value="Semanal">Semanal</option>
            <option value="Mensal">Mensal</option>
            <option value="Quando necessário">Quando necessário</option>
          </select>
        </div>
        
        <div>
          <label htmlFor="startDate" className="block text-sm font-medium mb-1">
            Data de Início
          </label>
          <input
            type="date"
            id="startDate"
            value={startDate || ''}
            onChange={(e) => setStartDate(e.target.value)}
            className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
          />
        </div>
      </div>
      
      {/* Intervalo Entre Doses */}
      <div className="mb-4">
        <label htmlFor="intervalMinutes" className="block text-sm font-medium mb-1">
          Intervalo Mínimo Entre Doses (em horas)
        </label>
        <div className="flex items-center">
          <input
            type="range"
            min="60"
            max="1440"
            step="60"
            value={intervalMinutes}
            onChange={(e) => setIntervalMinutes(parseInt(e.target.value))}
            className="w-full mr-2"
          />
          <span className="text-sm">{intervalMinutes / 60}h</span>
        </div>
      </div>
      
      {/* Horários */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-2">
          Horários Programados*
        </label>
        
        {/* Horários já adicionados */}
        {schedule.length > 0 && (
          <div className="flex flex-wrap gap-2 mb-2">
            {schedule.map((time, index) => (
              <div 
                key={index}
                className="flex items-center bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded"
              >
                <span className="text-sm">{time}</span>
                <button 
                  type="button"
                  onClick={() => handleRemoveScheduleTime(time)}
                  className="ml-2 text-blue-600 dark:text-blue-300 hover:text-blue-800"
                >
                  &times;
                </button>
              </div>
            ))}
          </div>
        )}
        
        {/* Adicionar novo horário */}
        <div className="flex gap-2">
          <input
            type="time"
            value={newScheduleTime}
            onChange={(e) => setNewScheduleTime(e.target.value)}
            className="flex-1 p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
          />
          <button
            type="button"
            onClick={handleAddScheduleTime}
            className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Adicionar
          </button>
        </div>
      </div>
      
      {/* Observações */}
      <div className="mb-4">
        <label htmlFor="notes" className="block text-sm font-medium mb-1">
          Observações (opcional)
        </label>
        <textarea
          id="notes"
          value={notes || ''}
          onChange={(e) => setNotes(e.target.value)}
          placeholder="Instruções especiais, efeitos colaterais, etc."
          className="w-full p-2 border rounded min-h-[80px] dark:bg-gray-700 dark:border-gray-600"
        />
      </div>
      
      {/* Mensagem de erro */}
      {error && (
        <p className="text-red-500 mb-4 text-sm">{error.message}</p>
      )}
      
      {/* Botões de ação */}
      <div className="flex justify-end">
        <button
          type="submit"
          disabled={isLoading}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {isLoading 
            ? 'Salvando...' 
            : initialData 
              ? 'Atualizar Medicamento' 
              : 'Salvar Medicamento'
          }
        </button>
      </div>
    </form>
  );
}
</file>

<file path="app/components/saude/MedicationItem.tsx">
import { useState } from 'react';
import { Medication } from '@/app/types/supabase';
import { useMedications } from '@/app/hooks/useMedications';
import { useToast } from '@/app/hooks/useToast';

interface MedicationItemProps {
  medication: Medication;
  onUpdate?: () => void;
  onRecord?: (id: string) => void;
}

export default function MedicationItem({ medication, onUpdate, onRecord }: MedicationItemProps) {
  const { deleteMedication, isLoading } = useMedications();
  const { showToast } = useToast();
  const [confirmDelete, setConfirmDelete] = useState(false);
  
  // Formatar data de início
  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'N/A';
    
    const date = new Date(dateString);
    return date.toLocaleDateString('pt-BR', { 
      day: '2-digit', 
      month: '2-digit', 
      year: 'numeric' 
    });
  };
  
  // Formatar última tomada
  const formatLastTaken = (dateString: string | null) => {
    if (!dateString) return 'Nunca';
    
    const date = new Date(dateString);
    return date.toLocaleDateString('pt-BR', { 
      day: '2-digit', 
      month: '2-digit', 
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };
  
  // Verificar se pode tomar mais uma dose
  const canTakeAnother = () => {
    if (!medication.last_taken || !medication.interval_minutes) return true;
    
    const lastTaken = new Date(medication.last_taken);
    const now = new Date();
    const intervalMs = medication.interval_minutes * 60 * 1000;
    
    return now.getTime() - lastTaken.getTime() >= intervalMs;
  };
  
  // Calcular tempo restante até próxima dose
  const getRemainingTime = () => {
    if (!medication.last_taken || !medication.interval_minutes) return null;
    
    const lastTaken = new Date(medication.last_taken);
    const now = new Date();
    const intervalMs = medication.interval_minutes * 60 * 1000;
    const nextDose = new Date(lastTaken.getTime() + intervalMs);
    
    if (now >= nextDose) return null;
    
    const diffMs = nextDose.getTime() - now.getTime();
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    if (diffHours > 0) {
      return `${diffHours}h${diffMinutes > 0 ? ` ${diffMinutes}min` : ''}`;
    }
    return `${diffMinutes}min`;
  };
  
  // Excluir medicamento
  const handleDelete = async () => {
    if (!confirmDelete) {
      setConfirmDelete(true);
      return;
    }
    
    const success = await deleteMedication(medication.id);
    
    if (success) {
      showToast('Medicamento excluído com sucesso', 'success');
      if (onUpdate) onUpdate();
    } else {
      showToast('Erro ao excluir medicamento', 'error');
    }
    
    setConfirmDelete(false);
  };
  
  // Registrar tomada
  const handleRecord = () => {
    if (onRecord) {
      onRecord(medication.id);
    }
  };
  
  return (
    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-3">
      <div className="flex justify-between items-center mb-2">
        <h3 className="text-md font-medium">
          {medication.name}
          {medication.dosage && (
            <span className="text-sm text-gray-500 dark:text-gray-400 ml-2">
              {medication.dosage}
            </span>
          )}
        </h3>
        <div className="flex items-center">
          <span className={`px-2 py-1 text-xs rounded ${
            medication.frequency === 'Diária' 
              ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200' 
              : 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200'
          }`}>
            {medication.frequency}
          </span>
        </div>
      </div>
      
      <div className="grid grid-cols-2 gap-2 mb-2 text-sm">
        <div>
          <p className="text-xs text-gray-500 dark:text-gray-400">Data de início:</p>
          <p>{formatDate(medication.start_date)}</p>
        </div>
        <div>
          <p className="text-xs text-gray-500 dark:text-gray-400">Última dose:</p>
          <p>{formatLastTaken(medication.last_taken)}</p>
        </div>
      </div>
      
      {medication.schedule && medication.schedule.length > 0 && (
        <div className="mb-2">
          <p className="text-xs text-gray-500 dark:text-gray-400 mb-1">Horários:</p>
          <div className="flex flex-wrap gap-1">
            {medication.schedule.map((time, index) => (
              <span 
                key={index}
                className="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded"
              >
                {time}
              </span>
            ))}
          </div>
        </div>
      )}
      
      {medication.notes && (
        <div className="mt-2">
          <p className="text-xs text-gray-500 dark:text-gray-400 mb-1">Observações:</p>
          <p className="text-sm text-gray-700 dark:text-gray-300">
            {medication.notes}
          </p>
        </div>
      )}
      
      <div className="mt-3 flex justify-end space-x-2">
        {medication.interval_minutes && (
          <>
            {canTakeAnother() ? (
              <button
                onClick={handleRecord}
                className="text-xs px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700"
              >
                Tomar Agora
              </button>
            ) : (
              <span className="text-xs px-3 py-1 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded">
                Próxima dose em {getRemainingTime()}
              </span>
            )}
          </>
        )}
        
        <button
          onClick={handleDelete}
          disabled={isLoading}
          className={`text-xs px-2 py-1 rounded ${
            confirmDelete 
              ? 'bg-red-600 text-white' 
              : 'text-red-600 bg-transparent hover:bg-red-100 dark:hover:bg-red-900'
          }`}
        >
          {confirmDelete ? 'Confirmar exclusão' : 'Excluir'}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="app/components/saude/MedicationList.tsx">
import { useState, useEffect, useCallback } from 'react';
import { useMedications } from '@/app/hooks/useMedications';
import { useToast } from '@/app/hooks/useToast';
import MedicationItem from './MedicationItem';
import MedicationForm from './MedicationForm';
import MedicationDataMigration from './MedicationDataMigration';
import { NewMedicationDose, Medication } from '@/app/types/supabase';

export default function MedicationList() {
  const { getMedications, recordMedicationDose, isLoading, error } = useMedications();
  const { showToast } = useToast();
  
  const [medications, setMedications] = useState<Medication[]>([]);
  const [showForm, setShowForm] = useState(false);
  const [editingMedication, setEditingMedication] = useState<Medication | null>(null);
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  
  // Carregar medicamentos
  useEffect(() => {
    const loadMedications = async () => {
      const data = await getMedications();
      setMedications(data);
    };
    
    loadMedications();
  }, [getMedications, refreshTrigger]);
  
  // Atualizar lista após alterações
  const refreshMedications = useCallback(() => {
    setRefreshTrigger(prev => prev + 1);
  }, []);
  
  // Alternar exibição do formulário
  const handleToggleForm = useCallback(() => {
    setShowForm(prev => !prev);
    setEditingMedication(null); // Limpar edição ao fechar/abrir formulário
  }, []);
  
  // Iniciar edição de medicamento
  const handleEditMedication = useCallback((medication: Medication) => {
    setEditingMedication(medication);
    setShowForm(true);
  }, []);
  
  // Gerenciar sucesso do formulário
  const handleFormSuccess = useCallback(() => {
    refreshMedications();
    
    // Se estiver editando, fechar o formulário após concluir
    if (editingMedication) {
      setShowForm(false);
      setEditingMedication(null);
    }
  }, [refreshMedications, editingMedication]);
  
  // Registrar tomada de medicamento
  const handleRecordDose = useCallback(async (medicationId: string) => {
    const now = new Date();
    const dose: NewMedicationDose = {
      medication_id: medicationId,
      taken_at: now.toISOString(),
    };
    
    const result = await recordMedicationDose(medicationId, dose);
    
    if (result) {
      showToast('Dose registrada com sucesso', 'success');
      refreshMedications();
    } else {
      showToast('Erro ao registrar dose', 'error');
    }
  }, [recordMedicationDose, showToast, refreshMedications]);
  
  // Manipular conclusão da migração
  const handleMigrationComplete = useCallback(() => {
    refreshMedications();
  }, [refreshMedications]);
  
  return (
    <div className="container mx-auto max-w-md p-4">
      <h2 className="text-xl font-bold mb-4">Gerenciamento de Medicamentos</h2>
      
      {/* Componente de migração de dados */}
      <MedicationDataMigration onMigrationComplete={handleMigrationComplete} />
      
      {/* Botão para mostrar/ocultar formulário */}
      <div className="mb-4">
        <button
          onClick={handleToggleForm}
          className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        >
          {showForm 
            ? 'Cancelar' 
            : editingMedication 
              ? 'Editar Medicamento' 
              : 'Adicionar Medicamento'
          }
        </button>
      </div>
      
      {/* Formulário para adicionar/editar medicamento */}
      {showForm && (
        <div className="mb-6">
          <MedicationForm 
            onSuccess={handleFormSuccess} 
            initialData={editingMedication || undefined}
          />
        </div>
      )}
      
      {/* Estado de carregamento */}
      {isLoading && !medications.length && (
        <div className="text-center py-4">
          <p>Carregando medicamentos...</p>
        </div>
      )}
      
      {/* Mensagem de erro */}
      {error && (
        <div className="text-red-500 mb-4">
          <p>Erro ao carregar medicamentos: {error.message}</p>
        </div>
      )}
      
      {/* Lista de medicamentos */}
      {!isLoading && !medications.length ? (
        <div className="text-center py-4 bg-gray-100 dark:bg-gray-800 rounded-lg">
          <p>Você ainda não possui medicamentos cadastrados.</p>
          {!showForm && (
            <button
              onClick={handleToggleForm}
              className="mt-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Cadastrar Agora
            </button>
          )}
        </div>
      ) : (
        <div>
          <h3 className="font-medium mb-2">Seus Medicamentos</h3>
          
          {/* Agrupar por frequência */}
          <div className="mb-4">
            <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Uso Diário</h4>
            {medications
              .filter(med => med.frequency === 'Diária')
              .map(medication => (
                <MedicationItem
                  key={medication.id}
                  medication={medication}
                  onUpdate={refreshMedications}
                  onRecord={handleRecordDose}
                />
              ))}
              
            {!medications.some(med => med.frequency === 'Diária') && (
              <p className="text-sm text-gray-500 dark:text-gray-400 text-center py-2">
                Nenhum medicamento de uso diário cadastrado
              </p>
            )}
          </div>
          
          {/* Outros tipos de frequência */}
          {medications.some(med => med.frequency !== 'Diária') && (
            <div>
              <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Outros Medicamentos</h4>
              {medications
                .filter(med => med.frequency !== 'Diária')
                .map(medication => (
                  <MedicationItem
                    key={medication.id}
                    medication={medication}
                    onUpdate={refreshMedications}
                    onRecord={handleRecordDose}
                  />
                ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/components/saude/StatCard.tsx">
'use client'

import { ReactNode } from 'react'
import { cn } from '@/app/lib/utils'
import { Card } from '../ui/Card'

interface StatCardProps {
  title: string
  value: string | number
  icon?: ReactNode
  description?: string
  className?: string
  trend?: {
    value: number
    label: string
    positive?: boolean
  }
}

export function StatCard({
  title,
  value,
  icon,
  description,
  className,
  trend,
}: StatCardProps) {
  return (
    <Card className={cn('flex flex-col', className)}>
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-sm font-medium text-gray-500 dark:text-gray-400">
          {title}
        </h3>
        {icon && <div className="text-saude-primary">{icon}</div>}
      </div>
      
      <div className="flex items-end">
        <div className="text-2xl font-semibold text-gray-900 dark:text-white">
          {value}
        </div>
        
        {trend && (
          <div className={cn(
            "ml-2 text-xs font-medium flex items-center",
            trend.positive 
              ? "text-green-600 dark:text-green-400" 
              : "text-red-600 dark:text-red-400"
          )}>
            <span className="mr-1">
              {trend.positive ? '↑' : '↓'}
            </span>
            {trend.value}% {trend.label}
          </div>
        )}
      </div>
      
      {description && (
        <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
          {description}
        </p>
      )}
    </Card>
  )
}
</file>

<file path="app/components/sono/ConfiguracaoLembretes.tsx">
'use client'

import { useState, useEffect } from 'react'
import { Bell, Trash2, Moon, Sun, Clock, Eye, EyeOff, Edit2 } from 'lucide-react'
import { useSleep } from '@/app/hooks/useSleep'
import { SleepReminder } from '@/app/types/supabase'
import { LoadingIndicator } from '@/app/components/ui/LoadingIndicator'
import { toast } from '@/app/components/ui/Toast'

// Dias da semana para seleção
const diasSemana = [
  { valor: 0, nome: 'Dom', abrev: 'D' },
  { valor: 1, nome: 'Seg', abrev: 'S' },
  { valor: 2, nome: 'Ter', abrev: 'T' },
  { valor: 3, nome: 'Qua', abrev: 'Q' },
  { valor: 4, nome: 'Qui', abrev: 'Q' },
  { valor: 5, nome: 'Sex', abrev: 'S' },
  { valor: 6, nome: 'Sáb', abrev: 'S' },
]

export default function ConfiguracaoLembretes() {
  const { 
    getSleepReminders, 
    addSleepReminder, 
    updateSleepReminder, 
    deleteSleepReminder, 
    toggleReminderActive,
    isLoading 
  } = useSleep()
  
  const [lembretes, setLembretes] = useState<SleepReminder[]>([])
  const [carregando, setCarregando] = useState(false)
  
  // Estado do formulário
  const [tipo, setTipo] = useState<'dormir' | 'acordar'>('dormir')
  const [horario, setHorario] = useState('22:00')
  const [diasSelecionados, setDiasSelecionados] = useState<number[]>([0, 1, 2, 3, 4, 5, 6])
  const [modoEdicao, setModoEdicao] = useState(false)
  const [idEdicao, setIdEdicao] = useState<string | null>(null)

  // Carregar lembretes do Supabase
  useEffect(() => {
    const carregarLembretes = async () => {
      setCarregando(true)
      try {
        const dados = await getSleepReminders()
        setLembretes(dados)
      } catch (erro) {
        console.error('Erro ao carregar lembretes:', erro)
        toast({
          title: "Erro",
          description: "Não foi possível carregar seus lembretes",
          variant: "error"
        })
      } finally {
        setCarregando(false)
      }
    }
    
    carregarLembretes()
  }, [getSleepReminders])

  // Alternar seleção de dia
  const toggleDia = (dia: number) => {
    if (diasSelecionados.includes(dia)) {
      setDiasSelecionados(diasSelecionados.filter(d => d !== dia))
    } else {
      setDiasSelecionados([...diasSelecionados, dia])
    }
  }
  
  // Selecionar todos os dias
  const selecionarTodosDias = () => {
    setDiasSelecionados([0, 1, 2, 3, 4, 5, 6])
  }
  
  // Selecionar apenas dias de semana
  const selecionarDiasSemana = () => {
    setDiasSelecionados([1, 2, 3, 4, 5])
  }
  
  // Selecionar apenas fim de semana
  const selecionarFimDeSemana = () => {
    setDiasSelecionados([0, 6])
  }
  
  // Limpar seleção de dias
  const limparDias = () => {
    setDiasSelecionados([])
  }
  
  // Iniciar edição de um lembrete
  const iniciarEdicao = (lembrete: SleepReminder) => {
    setTipo(lembrete.type as 'dormir' | 'acordar')
    setHorario(lembrete.time)
    setDiasSelecionados(lembrete.days_of_week)
    setModoEdicao(true)
    setIdEdicao(lembrete.id)
  }
  
  // Cancelar edição
  const cancelarEdicao = () => {
    resetForm()
    setModoEdicao(false)
    setIdEdicao(null)
  }
  
  // Resetar formulário
  const resetForm = () => {
    setTipo('dormir')
    setHorario('22:00')
    setDiasSelecionados([0, 1, 2, 3, 4, 5, 6])
  }
  
  // Alternar estado ativo de um lembrete
  const handleToggleAtivo = async (id: string, ativo: boolean) => {
    try {
      const lembrete = await toggleReminderActive(id, !ativo)
      if (lembrete) {
        setLembretes(lembretes.map(l => l.id === id ? lembrete : l))
        toast({
          title: "Sucesso",
          description: `Lembrete ${!ativo ? 'ativado' : 'desativado'} com sucesso`,
          variant: "success"
        })
      }
    } catch (erro) {
      console.error("Erro ao alterar estado do lembrete:", erro)
      toast({
        title: "Erro",
        description: "Não foi possível alterar o estado do lembrete",
        variant: "error"
      })
    }
  }
  
  // Remover um lembrete
  const handleRemoverLembrete = async (id: string) => {
    if (confirm('Tem certeza que deseja remover este lembrete?')) {
      try {
        const sucesso = await deleteSleepReminder(id)
        if (sucesso) {
          setLembretes(lembretes.filter(l => l.id !== id))
          toast({
            title: "Sucesso",
            description: "Lembrete removido com sucesso",
            variant: "success"
          })
        }
      } catch (erro) {
        console.error("Erro ao remover lembrete:", erro)
        toast({
          title: "Erro",
          description: "Não foi possível remover o lembrete",
          variant: "error"
        })
      }
    }
  }
  
  // Lidar com envio do formulário
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (diasSelecionados.length === 0) {
      toast({
        title: "Atenção",
        description: "Selecione pelo menos um dia da semana",
        variant: "warning"
      })
      return
    }
    
    try {
      if (modoEdicao && idEdicao) {
        const lembrete = await updateSleepReminder(idEdicao, {
          type: tipo,
          time: horario,
          days_of_week: diasSelecionados
        })
        
        if (lembrete) {
          setLembretes(lembretes.map(l => l.id === idEdicao ? lembrete : l))
          toast({
            title: "Sucesso",
            description: "Lembrete atualizado com sucesso",
            variant: "success"
          })
        }
        
        // Limpar modo de edição
        setModoEdicao(false)
        setIdEdicao(null)
      } else {
        const novoLembrete = await addSleepReminder({
          type: tipo,
          time: horario,
          days_of_week: diasSelecionados,
          active: true
        })
        
        if (novoLembrete) {
          setLembretes([...lembretes, novoLembrete])
          toast({
            title: "Sucesso",
            description: "Lembrete adicionado com sucesso",
            variant: "success"
          })
        }
      }
      
      // Resetar formulário
      resetForm()
    } catch (erro) {
      console.error("Erro ao salvar lembrete:", erro)
      toast({
        title: "Erro",
        description: "Não foi possível salvar o lembrete",
        variant: "error"
      })
    }
  }
  
  // Formatar exibição dos dias da semana
  const formatarDiasSemana = (dias: number[]) => {
    if (dias.length === 7) return 'Todos os dias'
    if (dias.length === 0) return 'Nenhum dia selecionado'
    if (arrayEquals(dias, [1, 2, 3, 4, 5])) return 'Segunda a Sexta'
    if (arrayEquals(dias, [0, 6])) return 'Fim de semana'
    
    return dias
      .sort((a, b) => a - b)
      .map(dia => diasSemana.find(d => d.valor === dia)?.nome)
      .join(', ')
  }
  
  // Verificar se dois arrays são iguais
  const arrayEquals = (a: any[], b: any[]) => {
    return a.length === b.length && 
      a.sort().every((val, index) => val === b.sort()[index])
  }
  
  // Agrupar lembretes por tipo
  const lembretesDormir = lembretes.filter(l => l.type === 'dormir')
  const lembretesAcordar = lembretes.filter(l => l.type === 'acordar')
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-6">
        Configuração de Lembretes
      </h2>
      
      <form onSubmit={handleSubmit} className="mb-8">
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
          {/* Tipo de lembrete */}
          <div>
            <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3">
              Tipo de Lembrete
            </h3>
            
            <div className="flex space-x-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  name="tipo"
                  checked={tipo === 'dormir'}
                  onChange={() => setTipo('dormir')}
                  className="h-4 w-4 text-sono-primary focus:ring-sono-primary border-gray-300"
                />
                <span className="ml-2 flex items-center text-gray-700 dark:text-gray-300">
                  <Moon className="h-4 w-4 mr-1 rotate-180" />
                  Hora de dormir
                </span>
              </label>
              
              <label className="flex items-center">
                <input
                  type="radio"
                  name="tipo"
                  checked={tipo === 'acordar'}
                  onChange={() => setTipo('acordar')}
                  className="h-4 w-4 text-sono-primary focus:ring-sono-primary border-gray-300"
                />
                <span className="ml-2 flex items-center text-gray-700 dark:text-gray-300">
                  <Sun className="h-4 w-4 mr-1" />
                  Hora de acordar
                </span>
              </label>
            </div>
          </div>
          
          {/* Horário */}
          <div>
            <label htmlFor="horario" className="block font-medium text-gray-700 dark:text-gray-300 mb-3">
              Horário
            </label>
            <input
              type="time"
              id="horario"
              value={horario}
              onChange={(e) => setHorario(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              required
            />
          </div>
        </div>
        
        {/* Dias da semana */}
        <div className="mt-6">
          <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3">
            Dias da Semana
          </h3>
          
          <div className="flex mb-3 space-x-2">
            <button
              type="button"
              onClick={selecionarTodosDias}
              className="px-2 py-1 text-xs text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Todos
            </button>
            <button
              type="button"
              onClick={selecionarDiasSemana}
              className="px-2 py-1 text-xs text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Seg-Sex
            </button>
            <button
              type="button"
              onClick={selecionarFimDeSemana}
              className="px-2 py-1 text-xs text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Fim de semana
            </button>
            <button
              type="button"
              onClick={limparDias}
              className="px-2 py-1 text-xs text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Limpar
            </button>
          </div>
          
          <div className="flex space-x-2 flex-wrap">
            {diasSemana.map((dia) => (
              <button
                key={dia.valor}
                type="button"
                onClick={() => toggleDia(dia.valor)}
                className={`
                  w-9 h-9 rounded-full flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-sono-primary
                  ${diasSelecionados.includes(dia.valor)
                    ? 'bg-sono-primary text-white'
                    : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-300'}
                `}
                aria-label={`${diasSelecionados.includes(dia.valor) ? 'Remover' : 'Adicionar'} ${dia.nome}`}
                aria-pressed={diasSelecionados.includes(dia.valor)}
              >
                {dia.abrev}
              </button>
            ))}
          </div>
          
          <p className="mt-2 text-sm text-gray-500 dark:text-gray-400">
            {formatarDiasSemana(diasSelecionados)}
          </p>
        </div>
        
        {/* Botões de ação */}
        <div className="mt-6 flex justify-end space-x-3">
          {modoEdicao && (
            <button
              type="button"
              onClick={cancelarEdicao}
              className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-sono-primary focus:ring-offset-2 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:hover:bg-gray-600"
            >
              Cancelar
            </button>
          )}
          
          <button
            type="submit"
            disabled={isLoading || carregando}
            className="px-4 py-2 bg-sono-primary text-white rounded-md shadow-sm hover:bg-sono-secondary focus:outline-none focus:ring-2 focus:ring-sono-primary focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
          >
            {isLoading || carregando ? (
              <>
                <LoadingIndicator size="small" text="" />
                <span className="ml-2">Salvando...</span>
              </>
            ) : (
              <span>{modoEdicao ? 'Atualizar' : 'Adicionar'} Lembrete</span>
            )}
          </button>
        </div>
      </form>
      
      {/* Lista de lembretes */}
      {carregando || isLoading ? (
        <div className="flex justify-center items-center py-12">
          <LoadingIndicator text="Carregando lembretes..." />
        </div>
      ) : (
        <>
          {/* Lembretes de Dormir */}
          <div className="mb-6">
            <h3 className="font-medium text-gray-800 dark:text-white mb-3 flex items-center">
              <Moon className="h-4 w-4 mr-2 rotate-180" />
              Lembretes para Dormir
            </h3>
            
            {lembretesDormir.length > 0 ? (
              <div className="space-y-3">
                {lembretesDormir.map((lembrete) => (
                  <div 
                    key={lembrete.id} 
                    className={`p-3 rounded-lg border ${lembrete.active 
                      ? 'border-sono-primary bg-sono-primary/5' 
                      : 'border-gray-300 bg-gray-50 dark:border-gray-600 dark:bg-gray-700/30'}`}
                  >
                    <div className="flex justify-between">
                      <div>
                        <p className={`font-medium ${lembrete.active 
                          ? 'text-gray-800 dark:text-white' 
                          : 'text-gray-500 dark:text-gray-400'}`}
                        >
                          {lembrete.time}
                        </p>
                        <p className={`text-sm ${lembrete.active 
                          ? 'text-gray-600 dark:text-gray-300' 
                          : 'text-gray-500 dark:text-gray-400'}`}
                        >
                          {formatarDiasSemana(lembrete.days_of_week)}
                        </p>
                      </div>
                      
                      <div className="flex space-x-2">
                        <button
                          onClick={() => handleToggleAtivo(lembrete.id, lembrete.active)}
                          className="p-1.5 rounded-full text-gray-500 hover:text-gray-700 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-sono-primary dark:text-gray-400 dark:hover:text-gray-200 dark:hover:bg-gray-700"
                          aria-label={lembrete.active ? 'Desativar lembrete' : 'Ativar lembrete'}
                        >
                          {lembrete.active ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </button>
                        
                        <button
                          onClick={() => iniciarEdicao(lembrete)}
                          className="p-1.5 rounded-full text-gray-500 hover:text-gray-700 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-sono-primary dark:text-gray-400 dark:hover:text-gray-200 dark:hover:bg-gray-700"
                          aria-label="Editar lembrete"
                        >
                          <Edit2 className="h-4 w-4" />
                        </button>
                        
                        <button
                          onClick={() => handleRemoverLembrete(lembrete.id)}
                          className="p-1.5 rounded-full text-red-500 hover:text-red-700 hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-red-500 dark:hover:bg-red-900/20"
                          aria-label="Remover lembrete"
                        >
                          <Trash2 className="h-4 w-4" />
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-6 text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-700/30 rounded-lg">
                Nenhum lembrete de hora de dormir configurado
              </div>
            )}
          </div>
          
          {/* Lembretes de Acordar */}
          <div>
            <h3 className="font-medium text-gray-800 dark:text-white mb-3 flex items-center">
              <Sun className="h-4 w-4 mr-2" />
              Lembretes para Acordar
            </h3>
            
            {lembretesAcordar.length > 0 ? (
              <div className="space-y-3">
                {lembretesAcordar.map((lembrete) => (
                  <div 
                    key={lembrete.id} 
                    className={`p-3 rounded-lg border ${lembrete.active 
                      ? 'border-sono-primary bg-sono-primary/5' 
                      : 'border-gray-300 bg-gray-50 dark:border-gray-600 dark:bg-gray-700/30'}`}
                  >
                    <div className="flex justify-between">
                      <div>
                        <p className={`font-medium ${lembrete.active 
                          ? 'text-gray-800 dark:text-white' 
                          : 'text-gray-500 dark:text-gray-400'}`}
                        >
                          {lembrete.time}
                        </p>
                        <p className={`text-sm ${lembrete.active 
                          ? 'text-gray-600 dark:text-gray-300' 
                          : 'text-gray-500 dark:text-gray-400'}`}
                        >
                          {formatarDiasSemana(lembrete.days_of_week)}
                        </p>
                      </div>
                      
                      <div className="flex space-x-2">
                        <button
                          onClick={() => handleToggleAtivo(lembrete.id, lembrete.active)}
                          className="p-1.5 rounded-full text-gray-500 hover:text-gray-700 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-sono-primary dark:text-gray-400 dark:hover:text-gray-200 dark:hover:bg-gray-700"
                          aria-label={lembrete.active ? 'Desativar lembrete' : 'Ativar lembrete'}
                        >
                          {lembrete.active ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </button>
                        
                        <button
                          onClick={() => iniciarEdicao(lembrete)}
                          className="p-1.5 rounded-full text-gray-500 hover:text-gray-700 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-sono-primary dark:text-gray-400 dark:hover:text-gray-200 dark:hover:bg-gray-700"
                          aria-label="Editar lembrete"
                        >
                          <Edit2 className="h-4 w-4" />
                        </button>
                        
                        <button
                          onClick={() => handleRemoverLembrete(lembrete.id)}
                          className="p-1.5 rounded-full text-red-500 hover:text-red-700 hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-red-500 dark:hover:bg-red-900/20"
                          aria-label="Remover lembrete"
                        >
                          <Trash2 className="h-4 w-4" />
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-6 text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-700/30 rounded-lg">
                Nenhum lembrete de hora de acordar configurado
              </div>
            )}
          </div>
        </>
      )}
    </div>
  )
}
</file>

<file path="app/components/sono/RegistroSono.tsx">
'use client'

import { useState } from 'react'
import { useSonoStore } from '../../stores/sonoStore'
import { formatDistanceToNow, format, isToday, isYesterday, parseISO } from 'date-fns'
import { ptBR } from 'date-fns/locale'
import { Clock, Moon, Trash2, Star, Edit2 } from 'lucide-react'

export function RegistroSono() {
  const { registros, adicionarRegistroSono, atualizarRegistroSono, removerRegistroSono } = useSonoStore()
  
  const [dataInicio, setDataInicio] = useState('')
  const [horaInicio, setHoraInicio] = useState('')
  const [dataFim, setDataFim] = useState('')
  const [horaFim, setHoraFim] = useState('')
  const [notas, setNotas] = useState('')
  const [qualidade, setQualidade] = useState<number | null>(null)
  const [modoEdicao, setModoEdicao] = useState(false)
  const [idEdicao, setIdEdicao] = useState<string | null>(null)
  
  // Formatar data para exibição
  const formatarData = (dataISO: string) => {
    const data = parseISO(dataISO)
    if (isToday(data)) {
      return `Hoje às ${format(data, 'HH:mm')}`
    } else if (isYesterday(data)) {
      return `Ontem às ${format(data, 'HH:mm')}`
    }
    return format(data, "dd 'de' MMMM 'às' HH:mm", { locale: ptBR })
  }
  
  // Calcular duração do sono
  const calcularDuracao = (inicio: string, fim: string | null) => {
    if (!fim) return null
    
    const dataInicio = parseISO(inicio)
    const dataFim = parseISO(fim)
    
    // Diferença em milissegundos
    const diff = dataFim.getTime() - dataInicio.getTime()
    
    // Converter para horas e minutos
    const horas = Math.floor(diff / (1000 * 60 * 60))
    const minutos = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))
    
    return `${horas}h ${minutos}min`
  }
  
  // Formatação da qualidade do sono em estrelas
  const renderEstrelas = (qualidade: number | null) => {
    if (qualidade === null) return null
    
    return Array.from({ length: 5 }).map((_, i) => (
      <Star 
        key={i} 
        className={`h-4 w-4 ${i < qualidade ? 'text-yellow-400 fill-yellow-400' : 'text-gray-300'}`} 
      />
    ))
  }
  
  // Lidar com o envio do formulário
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!dataInicio || !horaInicio) return
    
    const inicioISO = new Date(`${dataInicio}T${horaInicio}:00`).toISOString()
    const fimISO = dataFim && horaFim 
      ? new Date(`${dataFim}T${horaFim}:00`).toISOString() 
      : null
    
    if (modoEdicao && idEdicao) {
      atualizarRegistroSono(idEdicao, {
        inicio: inicioISO,
        fim: fimISO,
        qualidade,
        notas
      })
      
      // Limpar modo de edição
      setModoEdicao(false)
      setIdEdicao(null)
    } else {
      adicionarRegistroSono(inicioISO, fimISO, qualidade, notas)
    }
    
    // Limpar o formulário
    resetForm()
  }
  
  // Resetar formulário
  const resetForm = () => {
    setDataInicio('')
    setHoraInicio('')
    setDataFim('')
    setHoraFim('')
    setNotas('')
    setQualidade(null)
  }
  
  // Iniciar edição de um registro
  const iniciarEdicao = (registro: any) => {
    const dataInicioObj = parseISO(registro.inicio)
    const dataInicio = format(dataInicioObj, 'yyyy-MM-dd')
    const horaInicio = format(dataInicioObj, 'HH:mm')
    
    let dataFim = ''
    let horaFim = ''
    
    if (registro.fim) {
      const dataFimObj = parseISO(registro.fim)
      dataFim = format(dataFimObj, 'yyyy-MM-dd')
      horaFim = format(dataFimObj, 'HH:mm')
    }
    
    setDataInicio(dataInicio)
    setHoraInicio(horaInicio)
    setDataFim(dataFim)
    setHoraFim(horaFim)
    setNotas(registro.notas || '')
    setQualidade(registro.qualidade)
    
    setModoEdicao(true)
    setIdEdicao(registro.id)
  }
  
  // Cancelar edição
  const cancelarEdicao = () => {
    resetForm()
    setModoEdicao(false)
    setIdEdicao(null)
  }
  
  // Registrar sono atual
  const registrarSonoAtual = () => {
    const agora = new Date()
    setDataInicio(format(agora, 'yyyy-MM-dd'))
    setHoraInicio(format(agora, 'HH:mm'))
  }
  
  // Registrar acordar agora
  const registrarAcordarAgora = (id: string) => {
    const agora = new Date().toISOString()
    atualizarRegistroSono(id, { fim: agora })
  }
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-6">
        Registro de Sono
      </h2>
      
      <form onSubmit={handleSubmit} className="mb-8">
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-6 mb-6">
          {/* Início do sono */}
          <div>
            <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3 flex items-center">
              <Moon className="h-4 w-4 mr-2 rotate-180" />
              Horário de dormir
            </h3>
            
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label htmlFor="data-inicio" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                  Data
                </label>
                <input
                  type="date"
                  id="data-inicio"
                  value={dataInicio}
                  onChange={(e) => setDataInicio(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  required
                />
              </div>
              
              <div>
                <label htmlFor="hora-inicio" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                  Hora
                </label>
                <input
                  type="time"
                  id="hora-inicio"
                  value={horaInicio}
                  onChange={(e) => setHoraInicio(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  required
                />
              </div>
            </div>
            
            <button
              type="button"
              onClick={registrarSonoAtual}
              className="mt-2 text-sm text-sono-primary hover:text-sono-secondary dark:text-sono-secondary dark:hover:text-sono-primary"
            >
              Registrar agora
            </button>
          </div>
          
          {/* Fim do sono */}
          <div>
            <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3 flex items-center">
              <Clock className="h-4 w-4 mr-2" />
              Horário de acordar
            </h3>
            
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label htmlFor="data-fim" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                  Data
                </label>
                <input
                  type="date"
                  id="data-fim"
                  value={dataFim}
                  onChange={(e) => setDataFim(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              
              <div>
                <label htmlFor="hora-fim" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                  Hora
                </label>
                <input
                  type="time"
                  id="hora-fim"
                  value={horaFim}
                  onChange={(e) => setHoraFim(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
            </div>
            
            <div className="text-sm text-gray-500 dark:text-gray-400 mt-2">
              Deixe em branco se ainda não acordou
            </div>
          </div>
        </div>
        
        {/* Qualidade do sono */}
        <div className="mb-6">
          <label className="block font-medium text-gray-700 dark:text-gray-300 mb-2">
            Qualidade do sono
          </label>
          
          <div className="flex space-x-2">
            {[1, 2, 3, 4, 5].map((valor) => (
              <button
                key={valor}
                type="button"
                onClick={() => setQualidade(valor)}
                className="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-sono-primary"
                aria-label={`Qualidade ${valor} de 5`}
              >
                <Star 
                  className={`h-6 w-6 ${qualidade !== null && valor <= qualidade ? 'text-yellow-400 fill-yellow-400' : 'text-gray-300'}`} 
                />
              </button>
            ))}
          </div>
          
          <div className="text-sm text-gray-500 dark:text-gray-400 mt-1">
            {qualidade === null ? 'Selecione a qualidade do sono' : `Qualidade: ${qualidade}/5`}
          </div>
        </div>
        
        {/* Notas */}
        <div className="mb-6">
          <label htmlFor="notas" className="block font-medium text-gray-700 dark:text-gray-300 mb-2">
            Notas (opcional)
          </label>
          <textarea
            id="notas"
            value={notas}
            onChange={(e) => setNotas(e.target.value)}
            rows={3}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            placeholder="Exemplo: Acordei várias vezes, tive sonhos vívidos, etc."
          />
        </div>
        
        {/* Botões */}
        <div className="flex space-x-3">
          <button
            type="submit"
            className="px-4 py-2 bg-sono-primary text-white rounded-md hover:bg-sono-secondary focus:outline-none focus:ring-2 focus:ring-sono-primary focus:ring-offset-2"
          >
            {modoEdicao ? 'Atualizar Registro' : 'Registrar Sono'}
          </button>
          
          {modoEdicao && (
            <button
              type="button"
              onClick={cancelarEdicao}
              className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600"
            >
              Cancelar
            </button>
          )}
        </div>
      </form>
      
      {/* Lista de registros recentes */}
      <div>
        <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3">
          Registros Recentes
        </h3>
        
        <div className="space-y-4">
          {registros.length === 0 ? (
            <div className="text-gray-500 dark:text-gray-400 text-center py-4">
              Nenhum registro de sono encontrado
            </div>
          ) : (
            registros
              .sort((a, b) => new Date(b.inicio).getTime() - new Date(a.inicio).getTime())
              .slice(0, 5)
              .map((registro) => (
                <div 
                  key={registro.id}
                  className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg border border-gray-200 dark:border-gray-600"
                >
                  <div className="flex justify-between items-start">
                    <div>
                      <div className="font-medium text-gray-800 dark:text-white">
                        {formatarData(registro.inicio)}
                      </div>
                      
                      {registro.fim ? (
                        <div className="text-gray-600 dark:text-gray-300 text-sm">
                          Até {formatarData(registro.fim)}
                        </div>
                      ) : (
                        <div className="text-sono-primary dark:text-sono-secondary text-sm font-medium">
                          Ainda dormindo
                        </div>
                      )}
                      
                      {registro.fim && (
                        <div className="flex items-center mt-1">
                          <Clock className="h-4 w-4 text-gray-500 dark:text-gray-400 mr-1" />
                          <span className="text-sm text-gray-700 dark:text-gray-300">
                            {calcularDuracao(registro.inicio, registro.fim)}
                          </span>
                        </div>
                      )}
                      
                      {registro.qualidade !== null && (
                        <div className="flex mt-1">
                          {renderEstrelas(registro.qualidade)}
                        </div>
                      )}
                      
                      {registro.notas && (
                        <div className="mt-2 text-sm text-gray-600 dark:text-gray-400">
                          "{registro.notas}"
                        </div>
                      )}
                    </div>
                    
                    <div className="flex space-x-2">
                      <button
                        onClick={() => iniciarEdicao(registro)}
                        className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                        aria-label="Editar registro"
                      >
                        <Edit2 className="h-4 w-4" />
                      </button>
                      
                      <button
                        onClick={() => removerRegistroSono(registro.id)}
                        className="p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                        aria-label="Remover registro"
                      >
                        <Trash2 className="h-4 w-4" />
                      </button>
                    </div>
                  </div>
                  
                  {!registro.fim && (
                    <button
                      onClick={() => registrarAcordarAgora(registro.id)}
                      className="mt-2 px-3 py-1 text-sm bg-sono-light text-sono-primary rounded-md hover:bg-opacity-70"
                    >
                      Registrar acordar agora
                    </button>
                  )}
                </div>
              ))
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/sono/SleepDataMigration.tsx">
'use client';

import { useState } from 'react';
import { Button } from '@/app/components/ui/Button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/app/components/ui/Card';
import { Toast } from '@/app/components/ui/Toast';
import { AlertCircle, CheckCircle2 } from 'lucide-react';
import { Upload as CloudUpload } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from '@/app/components/ui/Alert';
import { LoadingIndicator } from '@/app/components/ui/LoadingIndicator';
import { useSleep } from '@/app/hooks/useSleep';

export default function SleepDataMigration() {
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [recordsCount, setRecordsCount] = useState(0);
  const [remindersCount, setRemindersCount] = useState(0);
  const [duplicateRecordsCount, setDuplicateRecordsCount] = useState(0);
  const [duplicateRemindersCount, setDuplicateRemindersCount] = useState(0);
  
  // Estado para o toast
  const [showToast, setShowToast] = useState(false);
  const [toastMessage, setToastMessage] = useState('');
  const [toastType, setToastType] = useState<'success' | 'error' | 'info' | 'warning'>('info');
  
  const { migrateFromLocalStorage } = useSleep();

  const displayToast = (message: string, type: 'success' | 'error' | 'info' | 'warning') => {
    setToastMessage(message);
    setToastType(type);
    setShowToast(true);
  };

  const handleMigration = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await migrateFromLocalStorage();
      
      if (!result.success) {
        throw new Error(result.error || "Erro desconhecido durante a migração");
      }
      
      setRecordsCount(result.recordsCount);
      setRemindersCount(result.remindersCount);
      setDuplicateRecordsCount(result.duplicateRecordsCount);
      setDuplicateRemindersCount(result.duplicateRemindersCount);
      
      // Apenas limpa dados locais se houver migração bem-sucedida ou duplicados
      if (result.recordsCount > 0 || result.remindersCount > 0 || 
          result.duplicateRecordsCount > 0 || result.duplicateRemindersCount > 0) {
        localStorage.removeItem('sleepRecords');
        localStorage.removeItem('sleepReminders');
      }
      
      setSuccess(true);
      displayToast(
        `${result.recordsCount} registros e ${result.remindersCount} lembretes foram migrados.${
          (result.duplicateRecordsCount > 0 || result.duplicateRemindersCount > 0) 
            ? ` ${result.duplicateRecordsCount} registros e ${result.duplicateRemindersCount} lembretes foram ignorados por já existirem.` 
            : ''
        }`,
        'success'
      );
    } catch (e) {
      setError(`Erro durante a migração: ${e instanceof Error ? e.message : 'Desconhecido'}`);
      displayToast(
        `Não foi possível migrar seus dados. Erro: ${e instanceof Error ? e.message : 'Desconhecido'}`,
        'error'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <Card className="w-full">
        <CardHeader>
          <CardTitle>Migração de Sono</CardTitle>
          <CardDescription>
            Migre seus registros e lembretes de sono para a nuvem para acessá-los em qualquer dispositivo.
          </CardDescription>
        </CardHeader>
        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Erro</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          {success ? (
            <Alert className="mb-4">
              <CheckCircle2 className="h-4 w-4" />
              <AlertTitle>Dados migrados com sucesso!</AlertTitle>
              <AlertDescription>
                {recordsCount} registros e {remindersCount} lembretes foram migrados.
                {(duplicateRecordsCount > 0 || duplicateRemindersCount > 0) && (
                  <p className="mt-1">
                    {duplicateRecordsCount} registros e {duplicateRemindersCount} lembretes foram ignorados por já existirem.
                  </p>
                )}
              </AlertDescription>
            </Alert>
          ) : (
            <div className="space-y-4">
              <p>
                Esta operação transferirá seus registros e lembretes de sono armazenados localmente 
                para o banco de dados na nuvem. Seus dados continuarão protegidos e privados.
              </p>
              <p>
                Os dados migrados estarão disponíveis em todos os seus dispositivos após fazer login.
              </p>
            </div>
          )}
        </CardContent>
        <CardFooter className="flex justify-end">
          {!success && (
            <Button 
              onClick={handleMigration} 
              disabled={loading}
              className="flex gap-2"
            >
              {loading ? (
                <>
                  <LoadingIndicator /> Migrando...
                </>
              ) : (
                <>
                  <CloudUpload size={16} /> Migrar Dados
                </>
              )}
            </Button>
          )}
        </CardFooter>
      </Card>
      
      {/* Renderiza o toast quando necessário */}
      {showToast && (
        <Toast
          type={toastType}
          message={toastMessage}
          show={showToast}
          onClose={() => setShowToast(false)}
        />
      )}
    </>
  );
}
</file>

<file path="app/components/sono/VisualizadorSemanal.tsx">
'use client'

import { useState, useMemo, useEffect } from 'react'
import { 
  startOfWeek, endOfWeek, eachDayOfInterval, 
  format, parseISO, isSameDay, isWithinInterval,
  differenceInMinutes, addDays, subWeeks
} from 'date-fns'
import { ptBR } from 'date-fns/locale'
import { ArrowLeft, ArrowRight, Moon, Sun, Clock } from 'lucide-react'
import { useSleep } from '@/app/hooks/useSleep'
import { SleepRecord } from '@/app/types/supabase'

export default function VisualizadorSemanal() {
  const { getSleepRecords, isLoading } = useSleep()
  const [registros, setRegistros] = useState<SleepRecord[]>([])
  const [semanaAtual, setSemanaAtual] = useState(new Date())
  const [carregando, setCarregando] = useState(false)
  
  // Carregar registros do Supabase
  useEffect(() => {
    const carregarRegistros = async () => {
      setCarregando(true)
      try {
        const dadosRegistros = await getSleepRecords()
        setRegistros(dadosRegistros)
      } catch (erro) {
        console.error('Erro ao carregar registros de sono:', erro)
      } finally {
        setCarregando(false)
      }
    }
    
    carregarRegistros()
  }, [getSleepRecords])
  
  // Navegar entre semanas
  const irParaSemanaAnterior = () => {
    setSemanaAtual(prevData => subWeeks(prevData, 1))
  }
  
  const irParaProximaSemana = () => {
    setSemanaAtual(prevData => addDays(prevData, 7))
  }
  
  // Calcular o intervalo da semana atual
  const intervaloSemana = useMemo(() => {
    const inicioDaSemana = startOfWeek(semanaAtual, { weekStartsOn: 0 }) // Domingo como início da semana
    const fimDaSemana = endOfWeek(semanaAtual, { weekStartsOn: 0 })
    return {
      inicio: inicioDaSemana,
      fim: fimDaSemana,
      diasDaSemana: eachDayOfInterval({ start: inicioDaSemana, end: fimDaSemana })
    }
  }, [semanaAtual])
  
  // Formatar os dias da semana para exibição
  const diasFormatados = useMemo(() => {
    return intervaloSemana.diasDaSemana.map(dia => {
      const diaSemanaAbreviado = format(dia, 'EEE', { locale: ptBR })
      const diaMes = format(dia, 'dd/MM')
      return {
        data: dia,
        diaSemana: diaSemanaAbreviado.charAt(0).toUpperCase() + diaSemanaAbreviado.slice(1),
        diaMes
      }
    })
  }, [intervaloSemana])
  
  // Filtrar e processar os registros da semana
  const dadosSemanal = useMemo(() => {
    return diasFormatados.map(dia => {
      // Encontrar registros que começam ou terminam neste dia
      const registrosDoDia = registros.filter(registro => {
        const dataInicio = parseISO(registro.start_time)
        const dataFim = registro.end_time ? parseISO(registro.end_time) : new Date()
        
        // Verificar se o início ou fim do sono está neste dia
        // Ou se o sono abrange completamente este dia
        return (
          isSameDay(dataInicio, dia.data) || 
          isSameDay(dataFim, dia.data) ||
          isWithinInterval(dia.data, { start: dataInicio, end: dataFim })
        )
      })
      
      // Calcular tempo total de sono para este dia (em minutos)
      let minutosTotais = 0
      
      registrosDoDia.forEach(registro => {
        const dataInicio = parseISO(registro.start_time)
        const dataFim = registro.end_time ? parseISO(registro.end_time) : new Date()
        
        // Início e fim do dia
        const inicioDia = new Date(dia.data)
        inicioDia.setHours(0, 0, 0, 0)
        
        const fimDia = new Date(dia.data)
        fimDia.setHours(23, 59, 59, 999)
        
        // Determinar o intervalo de sono dentro deste dia específico
        const inicioIntervalo = dataInicio < inicioDia ? inicioDia : dataInicio
        const fimIntervalo = dataFim > fimDia ? fimDia : dataFim
        
        // Calcular minutos de sono neste dia
        if (fimIntervalo > inicioIntervalo) {
          minutosTotais += differenceInMinutes(fimIntervalo, inicioIntervalo)
        }
      })
      
      // Converter para horas (arredondar para 1 casa decimal)
      const horasDeSono = Math.round(minutosTotais / 6) / 10
      
      // Qualidade média do sono
      const registrosComQualidade = registrosDoDia.filter(r => r.quality !== null)
      const qualidadeMedia = registrosComQualidade.length > 0
        ? registrosComQualidade.reduce((sum, r) => sum + (r.quality || 0), 0) / registrosComQualidade.length
        : null
      
      return {
        ...dia,
        horasDeSono,
        qualidadeMedia,
        registros: registrosDoDia
      }
    })
  }, [diasFormatados, registros])
  
  // Calcular estatísticas da semana
  const estatisticasSemana = useMemo(() => {
    const diasComSono = dadosSemanal.filter(d => d.horasDeSono > 0)
    
    if (diasComSono.length === 0) {
      return {
        mediaHoras: 0,
        mediaQualidade: 0,
        melhorDia: null,
        piorDia: null
      }
    }
    
    const totalHoras = diasComSono.reduce((sum, dia) => sum + dia.horasDeSono, 0)
    const mediaHoras = Math.round((totalHoras / diasComSono.length) * 10) / 10
    
    const diasComQualidade = diasComSono.filter(d => d.qualidadeMedia !== null)
    const mediaQualidade = diasComQualidade.length > 0
      ? Math.round((diasComQualidade.reduce((sum, dia) => sum + (dia.qualidadeMedia || 0), 0) / diasComQualidade.length) * 10) / 10
      : 0
    
    // Melhor e pior dia baseado em horas de sono (mais próximo de 8h é melhor)
    const melhorDia = [...diasComSono].sort((a, b) => {
      const distA = Math.abs(a.horasDeSono - 8)
      const distB = Math.abs(b.horasDeSono - 8)
      return distA - distB
    })[0]
    
    const piorDia = [...diasComSono].sort((a, b) => {
      const distA = Math.abs(a.horasDeSono - 8)
      const distB = Math.abs(b.horasDeSono - 8)
      return distB - distA
    })[0]
    
    return {
      mediaHoras,
      mediaQualidade,
      melhorDia,
      piorDia
    }
  }, [dadosSemanal])
  
  // Calcular altura máxima da barra (12 horas)
  const calcularAlturaBarra = (horas: number) => {
    const maxHoras = 12
    const alturaPorcentagem = Math.min((horas / maxHoras) * 100, 100)
    return `${alturaPorcentagem}%`
  }
  
  // Calcular cor da barra com base nas horas (verde = ideal, amarelo = médio, vermelho = pouco)
  const calcularCorBarra = (horas: number) => {
    if (horas >= 7 && horas <= 9) return 'bg-green-500'
    if (horas >= 5 && horas < 7) return 'bg-yellow-500'
    if (horas > 9 && horas <= 11) return 'bg-yellow-500'
    return 'bg-red-500'
  }
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-6">
        Visualizador Semanal de Sono
      </h2>
      
      {/* Navegação de semanas */}
      <div className="flex items-center justify-between mb-6">
        <button
          onClick={irParaSemanaAnterior}
          className="p-2 rounded-full text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-sono-primary"
          aria-label="Semana anterior"
        >
          <ArrowLeft className="h-5 w-5" />
        </button>
        
        <div className="text-center">
          <h3 className="font-medium text-gray-800 dark:text-white">
            {format(intervaloSemana.inicio, "dd 'de' MMMM", { locale: ptBR })} - {format(intervaloSemana.fim, "dd 'de' MMMM", { locale: ptBR })}
          </h3>
          <p className="text-sm text-gray-500 dark:text-gray-400">
            {format(intervaloSemana.inicio, "yyyy")}
          </p>
        </div>
        
        <button
          onClick={irParaProximaSemana}
          className="p-2 rounded-full text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-sono-primary"
          aria-label="Próxima semana"
          disabled={isWithinInterval(new Date(), { start: intervaloSemana.inicio, end: intervaloSemana.fim })}
        >
          <ArrowRight className="h-5 w-5" />
        </button>
      </div>
      
      {carregando || isLoading ? (
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-sono-primary"></div>
        </div>
      ) : (
        <>
          {/* Visualização de gráfico */}
          <div className="mb-8">
            <div className="flex items-end justify-between h-64 bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
              {dadosSemanal.map((dia, index) => (
                <div key={index} className="flex flex-col items-center w-1/7">
                  <div className="relative h-48 w-full flex items-end justify-center mb-2">
                    {dia.horasDeSono > 0 ? (
                      <div 
                        className={`w-8 rounded-t-lg ${calcularCorBarra(dia.horasDeSono)}`} 
                        style={{ height: calcularAlturaBarra(dia.horasDeSono) }}
                        title={`${dia.horasDeSono} horas de sono`}
                      />
                    ) : (
                      <div className="text-gray-400 dark:text-gray-500">
                        —
                      </div>
                    )}
                  </div>
                  <div className="text-center">
                    <div className="font-medium text-sono-primary dark:text-sono-secondary text-sm">
                      {dia.diaSemana}
                    </div>
                    <div className="text-xs text-gray-500 dark:text-gray-400">
                      {dia.diaMes}
                    </div>
                  </div>
                </div>
              ))}
            </div>
            
            <div className="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-2">
              <div className="flex items-center">
                <div className="w-3 h-3 rounded-full bg-green-500 mr-1"></div>
                <span>7-9h (ideal)</span>
              </div>
              <div className="flex items-center">
                <div className="w-3 h-3 rounded-full bg-yellow-500 mr-1"></div>
                <span>5-7h / 9-11h</span>
              </div>
              <div className="flex items-center">
                <div className="w-3 h-3 rounded-full bg-red-500 mr-1"></div>
                <span>&lt;5h / &gt;11h</span>
              </div>
            </div>
          </div>
          
          {/* Estatísticas da semana */}
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
            <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
              <h3 className="font-medium text-gray-800 dark:text-white mb-2 flex items-center">
                <Clock className="h-4 w-4 mr-1" />
                Média de Sono
              </h3>
              <p className="text-2xl font-bold text-sono-primary dark:text-sono-secondary">
                {estatisticasSemana.mediaHoras} <span className="text-sm font-normal">horas/dia</span>
              </p>
            </div>
            
            <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
              <h3 className="font-medium text-gray-800 dark:text-white mb-2 flex items-center">
                <Sun className="h-4 w-4 mr-1" />
                Qualidade Média
              </h3>
              <p className="text-2xl font-bold text-sono-primary dark:text-sono-secondary">
                {estatisticasSemana.mediaQualidade > 0 
                  ? `${estatisticasSemana.mediaQualidade}/5` 
                  : 'N/A'}
              </p>
            </div>
          </div>
          
          {/* Melhor e pior dia */}
          {estatisticasSemana.melhorDia && (
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                <h3 className="font-medium text-gray-800 dark:text-white mb-2 flex items-center">
                  <Moon className="h-4 w-4 mr-1" />
                  Melhor Noite
                </h3>
                <p className="font-medium text-sono-primary dark:text-sono-secondary">
                  {estatisticasSemana.melhorDia.diaSemana}, {estatisticasSemana.melhorDia.diaMes}
                </p>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  {estatisticasSemana.melhorDia.horasDeSono} horas de sono
                  {estatisticasSemana.melhorDia.qualidadeMedia 
                    ? `, qualidade ${estatisticasSemana.melhorDia.qualidadeMedia}/5` 
                    : ''}
                </p>
              </div>
              
              {estatisticasSemana.piorDia && (
                <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                  <h3 className="font-medium text-gray-800 dark:text-white mb-2 flex items-center">
                    <Sun className="h-4 w-4 mr-1" />
                    Pior Noite
                  </h3>
                  <p className="font-medium text-sono-primary dark:text-sono-secondary">
                    {estatisticasSemana.piorDia.diaSemana}, {estatisticasSemana.piorDia.diaMes}
                  </p>
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    {estatisticasSemana.piorDia.horasDeSono} horas de sono
                    {estatisticasSemana.piorDia.qualidadeMedia 
                      ? `, qualidade ${estatisticasSemana.piorDia.qualidadeMedia}/5` 
                      : ''}
                  </p>
                </div>
              )}
            </div>
          )}
        </>
      )}
    </div>
  )
}
</file>

<file path="app/components/ui/Alert.tsx">
'use client'

import { ReactNode } from 'react'
import { cn } from '@/app/lib/utils'
import { AlertCircle, CheckCircle, Info, XCircle } from 'lucide-react'

type AlertVariant = 'info' | 'success' | 'warning' | 'error' | 'destructive'

interface AlertProps {
  variant?: AlertVariant
  title?: string
  children: ReactNode
  className?: string
}

const variantStyles = {
  info: {
    container: 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800',
    icon: <Info className="h-5 w-5 text-blue-500 dark:text-blue-400" />,
    title: 'text-blue-800 dark:text-blue-300',
    content: 'text-blue-700 dark:text-blue-200',
  },
  success: {
    container: 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800',
    icon: <CheckCircle className="h-5 w-5 text-green-500 dark:text-green-400" />,
    title: 'text-green-800 dark:text-green-300',
    content: 'text-green-700 dark:text-green-200',
  },
  warning: {
    container: 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800',
    icon: <AlertCircle className="h-5 w-5 text-yellow-500 dark:text-yellow-400" />,
    title: 'text-yellow-800 dark:text-yellow-300',
    content: 'text-yellow-700 dark:text-yellow-200',
  },
  error: {
    container: 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800',
    icon: <XCircle className="h-5 w-5 text-red-500 dark:text-red-400" />,
    title: 'text-red-800 dark:text-red-300',
    content: 'text-red-700 dark:text-red-200',
  },
  destructive: {
    container: 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800',
    icon: <XCircle className="h-5 w-5 text-red-500 dark:text-red-400" />,
    title: 'text-red-800 dark:text-red-300',
    content: 'text-red-700 dark:text-red-200',
  },
}

export function Alert({ 
  variant = 'info', 
  title, 
  children, 
  className 
}: AlertProps) {
  const styles = variantStyles[variant]
  
  return (
    <div
      className={cn(
        'border rounded-md p-4 flex gap-3',
        styles.container,
        className
      )}
      role="alert"
    >
      <div className="flex-shrink-0">{styles.icon}</div>
      <div>
        {title && (
          <h3 className={cn('text-sm font-medium mb-1', styles.title)}>
            {title}
          </h3>
        )}
        <div className={cn('text-sm', styles.content)}>{children}</div>
      </div>
    </div>
  )
}

interface AlertTitleProps {
  children: ReactNode
  className?: string
}

export function AlertTitle({ children, className }: AlertTitleProps) {
  return (
    <h3 className={cn('text-sm font-medium mb-1', className)}>
      {children}
    </h3>
  )
}

interface AlertDescriptionProps {
  children: ReactNode
  className?: string
}

export function AlertDescription({ children, className }: AlertDescriptionProps) {
  return (
    <div className={cn('text-sm', className)}>{children}</div>
  )
}
</file>

<file path="app/components/ui/Badge.tsx">
'use client'

import { ReactNode } from 'react'
import { cva, type VariantProps } from 'class-variance-authority'
import { cn } from '@/app/lib/utils'

const badgeVariants = cva(
  'inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium',
  {
    variants: {
      variant: {
        default: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300',
        primary: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300',
        secondary: 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300',
        success: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300',
        warning: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300',
        danger: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300',
        outline: 'bg-transparent border border-gray-300 text-gray-700 dark:border-gray-600 dark:text-gray-300',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
)

export interface BadgeProps extends VariantProps<typeof badgeVariants> {
  children: ReactNode
  className?: string
  onClick?: () => void
}

export function Badge({ className, variant, children, onClick }: BadgeProps) {
  return (
    <span className={cn(badgeVariants({ variant, className }))} onClick={onClick}>
      {children}
    </span>
  )
}
</file>

<file path="app/components/ui/Button.tsx">
'use client'

import { ButtonHTMLAttributes, ReactNode } from 'react'
import { cva, type VariantProps } from 'class-variance-authority'
import { cn } from '@/app/lib/utils'

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none',
  {
    variants: {
      variant: {
        default: 'bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-600',
        destructive: 'bg-red-600 text-white hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-600',
        outline: 'border border-gray-300 dark:border-gray-700 bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800',
        subtle: 'bg-gray-100 text-gray-900 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-100 dark:hover:bg-gray-700',
        ghost: 'bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800 text-gray-700 dark:text-gray-300',
        link: 'bg-transparent underline-offset-4 hover:underline text-blue-600 dark:text-blue-400 hover:bg-transparent',
        primary: 'bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-600',
        success: 'bg-green-600 text-white hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-600',
        warning: 'bg-yellow-600 text-white hover:bg-yellow-700 dark:bg-yellow-700 dark:hover:bg-yellow-600',
        danger: 'bg-red-600 text-white hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-600',
        secondary: 'bg-gray-600 text-white hover:bg-gray-700 dark:bg-gray-700 dark:hover:bg-gray-600',
      },
      size: {
        default: 'h-10 py-2 px-4',
        sm: 'h-8 px-3 text-xs',
        lg: 'h-12 px-6 text-base',
        icon: 'h-9 w-9 p-1',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

export interface ButtonProps
  extends ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  children: ReactNode
  icon?: ReactNode
}

export function Button({
  className,
  variant,
  size,
  children,
  icon,
  ...props
}: ButtonProps) {
  return (
    <button
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    >
      {icon && <span className="mr-2">{icon}</span>}
      {children}
    </button>
  )
}
</file>

<file path="app/components/ui/Card.tsx">
'use client'

import { cn } from '@/app/lib/utils'
import React from 'react'

interface CardProps {
  children: React.ReactNode
  className?: string
}

export function Card({ children, className }: CardProps) {
  return (
    <div className={cn(
      "bg-white dark:bg-gray-800 rounded-xl shadow-md overflow-hidden",
      className
    )}>
      {children}
    </div>
  )
}

interface CardHeaderProps {
  children: React.ReactNode
  className?: string
}

export function CardHeader({ children, className }: CardHeaderProps) {
  return (
    <div className={cn("p-4 border-b border-gray-200 dark:border-gray-700", className)}>
      {children}
    </div>
  )
}

interface CardTitleProps {
  children: React.ReactNode
  className?: string
}

export function CardTitle({ children, className }: CardTitleProps) {
  return (
    <h3 className={cn("text-lg font-medium text-gray-900 dark:text-white", className)}>
      {children}
    </h3>
  )
}

interface CardDescriptionProps {
  children: React.ReactNode
  className?: string
}

export function CardDescription({ children, className }: CardDescriptionProps) {
  return (
    <p className={cn("text-sm text-gray-500 dark:text-gray-400 mt-1", className)}>
      {children}
    </p>
  )
}

interface CardContentProps {
  children: React.ReactNode
  className?: string
}

export function CardContent({ children, className }: CardContentProps) {
  return (
    <div className={cn("p-4", className)}>
      {children}
    </div>
  )
}

interface CardFooterProps {
  children: React.ReactNode
  className?: string
}

export function CardFooter({ children, className }: CardFooterProps) {
  return (
    <div className={cn("p-4 border-t border-gray-200 dark:border-gray-700", className)}>
      {children}
    </div>
  )
}
</file>

<file path="app/components/ui/Checkbox.tsx">
'use client'

import { InputHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/app/lib/utils'

export interface CheckboxProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'type'> {
  label?: string
}

export const Checkbox = forwardRef<HTMLInputElement, CheckboxProps>(
  ({ className, label, id, ...props }, ref) => {
    const checkboxId = id || `checkbox-${Math.random().toString(36).substring(2, 9)}`
    
    return (
      <div className="flex items-center">
        <input
          id={checkboxId}
          type="checkbox"
          className={cn(
            "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 dark:border-gray-700 dark:bg-gray-800",
            className
          )}
          ref={ref}
          {...props}
        />
        {label && (
          <label
            htmlFor={checkboxId}
            className="ml-2 block text-sm text-gray-700 dark:text-gray-300"
          >
            {label}
          </label>
        )}
      </div>
    )
  }
)
</file>

<file path="app/components/ui/Container.tsx">
'use client'

import { cn } from '@/app/lib/utils'

interface ContainerProps {
  children: React.ReactNode
  className?: string
}

export function Container({ children, className }: ContainerProps) {
  return (
    <div className={cn(
      "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
      className
    )}>
      {children}
    </div>
  )
}
</file>

<file path="app/components/ui/Input.tsx">
'use client'

import { InputHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/app/lib/utils'

export interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string
  error?: string
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ className, label, error, id, ...props }, ref) => {
    const inputId = id || `input-${Math.random().toString(36).substring(2, 9)}`
    
    return (
      <div className="w-full">
        {label && (
          <label
            htmlFor={inputId}
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            {label}
          </label>
        )}
        <input
          id={inputId}
          className={cn(
            "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white text-sm",
            error && "border-red-500 focus:ring-red-500 focus:border-red-500",
            className
          )}
          ref={ref}
          aria-invalid={error ? 'true' : 'false'}
          aria-describedby={error ? `${inputId}-error` : undefined}
          {...props}
        />
        {error && (
          <p
            id={`${inputId}-error`}
            className="mt-1 text-xs text-red-600 dark:text-red-400"
          >
            {error}
          </p>
        )}
      </div>
    )
  }
)
</file>

<file path="app/components/ui/Label.tsx">
import * as React from "react";
import { cn } from "@/app/lib/utils";

export interface LabelProps extends React.LabelHTMLAttributes<HTMLLabelElement> {
  // Propriedades específicas do label, se necessário
}

const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
  ({ className, ...props }, ref) => {
    return (
      <label
        ref={ref}
        className={cn(
          "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
          className
        )}
        {...props}
      />
    );
  }
);

Label.displayName = "Label";

export { Label };
</file>

<file path="app/components/ui/LoadingIndicator.tsx">
'use client'

type LoadingIndicatorProps = {
  size?: 'small' | 'medium' | 'large'
  fullScreen?: boolean
  text?: string
}

export function LoadingIndicator({
  size = 'medium',
  fullScreen = false,
  text = 'Carregando...'
}: LoadingIndicatorProps) {
  const sizeClasses = {
    small: 'h-4 w-4 border-2',
    medium: 'h-8 w-8 border-2',
    large: 'h-12 w-12 border-3'
  }

  // Se for fullScreen, cobrir toda a tela com um overlay
  if (fullScreen) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-black/20 dark:bg-black/50 backdrop-blur-sm z-50">
        <div className="flex flex-col items-center gap-3 p-6 bg-white dark:bg-gray-800 rounded-lg shadow-xl">
          <div className={`${sizeClasses[size]} animate-spin rounded-full border-gray-300 dark:border-gray-600 border-t-blue-500 dark:border-t-blue-400`}></div>
          {text && <p className="text-gray-700 dark:text-gray-300 font-medium">{text}</p>}
        </div>
      </div>
    )
  }

  // Versão inline
  return (
    <div className="flex items-center gap-2">
      <div className={`${sizeClasses[size]} animate-spin rounded-full border-gray-300 dark:border-gray-600 border-t-blue-500 dark:border-t-blue-400`}></div>
      {text && <p className="text-gray-700 dark:text-gray-300 text-sm">{text}</p>}
    </div>
  )
}
</file>

<file path="app/components/ui/Modal.tsx">
'use client'

import { Fragment, ReactNode } from 'react'
import { Dialog, Transition } from '@headlessui/react'
import { X } from 'lucide-react'
import { cn } from '@/app/lib/utils'
import { Button } from './Button'

interface ModalProps {
  isOpen: boolean
  onClose: () => void
  title: string
  children: ReactNode
  footer?: ReactNode
  size?: 'sm' | 'md' | 'lg' | 'xl'
  className?: string
}

export function Modal({
  isOpen,
  onClose,
  title,
  children,
  footer,
  size = 'md',
  className,
}: ModalProps) {
  const sizeClasses = {
    sm: 'max-w-sm',
    md: 'max-w-md',
    lg: 'max-w-lg',
    xl: 'max-w-xl',
  }
  
  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25 dark:bg-opacity-50" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel
                className={cn(
                  'w-full transform overflow-hidden rounded-lg bg-white dark:bg-gray-800 p-6 text-left align-middle shadow-xl transition-all',
                  sizeClasses[size],
                  className
                )}
              >
                <div className="flex items-center justify-between mb-4">
                  <Dialog.Title
                    as="h3"
                    className="text-lg font-medium leading-6 text-gray-900 dark:text-white"
                  >
                    {title}
                  </Dialog.Title>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={onClose}
                    aria-label="Fechar"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
                
                <div className="mt-2">{children}</div>
                
                {footer && (
                  <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                    {footer}
                  </div>
                )}
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  )
}
</file>

<file path="app/components/ui/Section.tsx">
'use client'

import { cn } from '@/app/lib/utils'

interface SectionProps {
  children: React.ReactNode
  title: string
  description?: string
  className?: string
}

export function Section({ children, title, description, className }: SectionProps) {
  return (
    <section className={cn("py-6", className)}>
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-2">{title}</h1>
        {description && (
          <p className="text-gray-600 dark:text-gray-400">{description}</p>
        )}
      </div>
      <div className="space-y-6">
        {children}
      </div>
    </section>
  )
}
</file>

<file path="app/components/ui/Select.tsx">
'use client'

import { SelectHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/app/lib/utils'

export interface SelectOption {
  value: string
  label: string
}

export interface SelectProps extends SelectHTMLAttributes<HTMLSelectElement> {
  label?: string
  options: SelectOption[]
  error?: string
  helpText?: string
}

export const Select = forwardRef<HTMLSelectElement, SelectProps>(
  ({ className, label, options, error, helpText, id, ...props }, ref) => {
    const selectId = id || `select-${Math.random().toString(36).substring(2, 9)}`
    
    return (
      <div className="w-full">
        {label && (
          <label
            htmlFor={selectId}
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            {label}
          </label>
        )}
        {helpText && (
          <p className="text-xs text-gray-500 dark:text-gray-400 mb-1">
            {helpText}
          </p>
        )}
        <select
          id={selectId}
          className={cn(
            "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white text-sm",
            error && "border-red-500 focus:ring-red-500 focus:border-red-500",
            className
          )}
          ref={ref}
          aria-invalid={error ? 'true' : 'false'}
          aria-describedby={error ? `${selectId}-error` : undefined}
          {...props}
        >
          {options.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
        {error && (
          <p
            id={`${selectId}-error`}
            className="mt-1 text-xs text-red-600 dark:text-red-400"
          >
            {error}
          </p>
        )}
      </div>
    )
  }
)
</file>

<file path="app/components/ui/Slider.tsx">
'use client'

import React from 'react'

interface SliderProps {
  min: number
  max: number
  step?: number
  value: number
  onChange: (value: number) => void
  disabled?: boolean
}

export function Slider({ min, max, step = 1, value, onChange, disabled = false }: SliderProps) {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(Number(e.target.value))
  }
  
  // Calcular a porcentagem para o background gradient
  const percentage = ((value - min) / (max - min)) * 100
  
  return (
    <div className="relative w-full">
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        value={value}
        onChange={handleChange}
        disabled={disabled}
        className={`
          w-full h-2 rounded-lg appearance-none cursor-pointer
          bg-gradient-to-r from-lazer-primary to-lazer-primary via-lazer-primary
          bg-no-repeat
          dark:bg-gray-700
          ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
        `}
        style={{
          backgroundSize: `${percentage}% 100%`,
          backgroundImage: 'linear-gradient(to right, var(--lazer-primary), var(--lazer-primary))'
        }}
        aria-valuemin={min}
        aria-valuemax={max}
        aria-valuenow={value}
      />
    </div>
  )
}
</file>

<file path="app/components/ui/StatCard.tsx">
import React, { ReactNode } from 'react'

interface StatCardProps {
  title: string
  value: string
  icon?: ReactNode
  description?: string
  className?: string
}

export function StatCard({ title, value, icon, description, className = '' }: StatCardProps) {
  return (
    <div className={`bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 ${className}`}>
      <div className="flex items-start">
        {icon && (
          <div className="mr-3 p-2 bg-gray-100 dark:bg-gray-700 rounded-full">
            {icon}
          </div>
        )}
        <div>
          <h3 className="text-sm font-medium text-gray-500 dark:text-gray-400">{title}</h3>
          <p className="text-2xl font-bold text-gray-900 dark:text-white mt-1">{value}</p>
          {description && (
            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{description}</p>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/ui/Tabs.tsx">
'use client';

import React, { useState, ReactNode, useEffect } from 'react';

export type TabItem = {
  id: string;
  label: string;
  content: ReactNode;
  icon?: ReactNode;
};

type TabsProps = {
  tabs: TabItem[];
  defaultTab?: string;
  variant?: 'underline' | 'pills' | 'enclosed';
  className?: string;
  tabClassName?: string;
  contentClassName?: string;
  onChange?: (tabId: string) => void;
};

export function Tabs({
  tabs,
  defaultTab,
  variant = 'underline',
  className = '',
  tabClassName = '',
  contentClassName = '',
  onChange
}: TabsProps) {
  const [activeTab, setActiveTab] = useState<string>(defaultTab || (tabs.length > 0 ? tabs[0].id : ''));

  useEffect(() => {
    if (defaultTab) {
      setActiveTab(defaultTab);
    }
  }, [defaultTab]);

  const handleTabClick = (tabId: string) => {
    setActiveTab(tabId);
    if (onChange) {
      onChange(tabId);
    }
  };

  const variantStyles = {
    underline: {
      container: 'border-b border-gray-200 dark:border-gray-700',
      tab: 'px-4 py-2 border-b-2 -mb-px',
      active: 'border-blue-600 text-blue-600 dark:border-blue-400 dark:text-blue-400',
      inactive: 'border-transparent hover:border-gray-300 hover:text-gray-700 dark:hover:text-gray-300'
    },
    pills: {
      container: 'flex space-x-2',
      tab: 'px-4 py-2 rounded-full',
      active: 'bg-blue-600 text-white',
      inactive: 'hover:bg-gray-100 dark:hover:bg-gray-700'
    },
    enclosed: {
      container: 'flex',
      tab: 'px-4 py-2 border-t border-l border-r',
      active: 'rounded-t-lg border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800',
      inactive: 'border-transparent hover:bg-gray-50 dark:hover:bg-gray-700'
    }
  };
  
  const styles = variantStyles[variant];

  return (
    <div className={`w-full ${className}`}>
      <div className={`flex flex-wrap ${styles.container}`}>
        {tabs.map(tab => (
          <button
            key={tab.id}
            className={`
              ${styles.tab}
              ${activeTab === tab.id ? styles.active : styles.inactive}
              font-medium text-sm transition-colors
              ${tabClassName}
            `}
            onClick={() => handleTabClick(tab.id)}
            aria-selected={activeTab === tab.id}
            role="tab"
          >
            <div className="flex items-center space-x-2">
              {tab.icon && <div>{tab.icon}</div>}
              <span>{tab.label}</span>
            </div>
          </button>
        ))}
      </div>
      <div className={`py-4 ${contentClassName}`}>
        {tabs.find(tab => tab.id === activeTab)?.content}
      </div>
    </div>
  );
}
</file>

<file path="app/components/ui/Textarea.tsx">
'use client'

import { TextareaHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/app/lib/utils'

export interface TextareaProps extends TextareaHTMLAttributes<HTMLTextAreaElement> {
  label?: string
  error?: string
}

export const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, label, error, id, ...props }, ref) => {
    const textareaId = id || `textarea-${Math.random().toString(36).substring(2, 9)}`
    
    return (
      <div className="w-full">
        {label && (
          <label
            htmlFor={textareaId}
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            {label}
          </label>
        )}
        <textarea
          id={textareaId}
          className={cn(
            "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white text-sm min-h-[80px]",
            error && "border-red-500 focus:ring-red-500 focus:border-red-500",
            className
          )}
          ref={ref}
          aria-invalid={error ? 'true' : 'false'}
          aria-describedby={error ? `${textareaId}-error` : undefined}
          {...props}
        />
        {error && (
          <p
            id={`${textareaId}-error`}
            className="mt-1 text-xs text-red-600 dark:text-red-400"
          >
            {error}
          </p>
        )}
      </div>
    )
  }
)
</file>

<file path="app/components/ui/Tooltip.tsx">
'use client'

import { ReactNode, useState } from 'react'
import { cn } from '@/app/lib/utils'

interface TooltipProps {
  children: ReactNode
  content: string
  position?: 'top' | 'bottom' | 'left' | 'right'
  className?: string
}

export function Tooltip({
  children,
  content,
  position = 'top',
  className,
}: TooltipProps) {
  const [isVisible, setIsVisible] = useState(false)

  const positionClasses = {
    top: 'bottom-full left-1/2 transform -translate-x-1/2 mb-2',
    bottom: 'top-full left-1/2 transform -translate-x-1/2 mt-2',
    left: 'right-full top-1/2 transform -translate-y-1/2 mr-2',
    right: 'left-full top-1/2 transform -translate-y-1/2 ml-2',
  }

  return (
    <div
      className="relative inline-block"
      onMouseEnter={() => setIsVisible(true)}
      onMouseLeave={() => setIsVisible(false)}
      onFocus={() => setIsVisible(true)}
      onBlur={() => setIsVisible(false)}
    >
      {isVisible && (
        <div
          className={cn(
            'absolute z-10 px-2 py-1 text-xs font-medium text-white bg-gray-800 rounded shadow-sm dark:bg-gray-700 max-w-xs',
            positionClasses[position],
            className
          )}
          role="tooltip"
        >
          {content}
          <div
            className={cn(
              'absolute w-2 h-2 bg-gray-800 dark:bg-gray-700 transform rotate-45',
              position === 'top' && 'bottom-0 left-1/2 -translate-x-1/2 translate-y-1/2',
              position === 'bottom' && 'top-0 left-1/2 -translate-x-1/2 -translate-y-1/2',
              position === 'left' && 'right-0 top-1/2 translate-x-1/2 -translate-y-1/2',
              position === 'right' && 'left-0 top-1/2 -translate-x-1/2 -translate-y-1/2'
            )}
          />
        </div>
      )}
      {children}
    </div>
  )
}
</file>

<file path="app/components/ErrorBoundary.jsx">
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
    
    console.error("Error capturado pela Error Boundary:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Você pode renderizar uma UI personalizada
      return (
        <div className="error-container">
          <h2>Algo deu errado.</h2>
          <button 
            onClick={() => {
              // Limpar o cache e tentar novamente
              import('../services/api').then(module => {
                module.default.clearCache();
                this.setState({ hasError: false });
                window.location.reload();
              });
            }}
            className="retry-button"
          >
            Tentar novamente
          </button>
          {this.props.showDetails && (
            <details style={{ marginTop: 20, whiteSpace: 'pre-wrap' }}>
              <summary>Detalhes do erro</summary>
              {this.state.error && this.state.error.toString()}
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
</file>

<file path="app/components/ExportarImportarDados.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import { exportarDados, importarDados } from '../lib/dataService';
import { useDataTransferStore } from '../stores/dataTransferStore';
import { Download, Upload, AlertCircle, CheckCircle, Info, Clock, HelpCircle } from 'lucide-react';
import Link from 'next/link';

/**
 * Componente para exportar e importar dados do aplicativo
 * Permite ao usuário fazer backup dos seus dados ou restaurar a partir de um backup
 */
export const ExportarImportarDados = () => {
  const [status, setStatus] = useState<'idle' | 'exporting' | 'importing' | 'success' | 'error'>('idle');
  const [mensagem, setMensagem] = useState('');
  const [mostrarConfirmacao, setMostrarConfirmacao] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [arquivoSelecionado, setArquivoSelecionado] = useState<File | null>(null);
  
  // Acessar a store de transferência de dados
  const { 
    ultimaExportacao, 
    ultimaImportacao, 
    registrarExportacao, 
    registrarImportacao 
  } = useDataTransferStore();
  
  // Formatar datas para exibição
  const formatarData = (dataIso: string | null) => {
    if (!dataIso) return null;
    
    const data = new Date(dataIso);
    return data.toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };
  
  /**
   * Manipula o processo de exportação de dados
   */
  const handleExportar = async () => {
    setStatus('exporting');
    try {
      const resultado = exportarDados();
      if (resultado.sucesso) {
        setStatus('success');
        setMensagem('Dados exportados com sucesso!');
        registrarExportacao(); // Registrar a exportação no histórico
      } else {
        throw new Error(resultado.erro);
      }
    } catch (error: any) {
      setStatus('error');
      setMensagem(`Erro ao exportar: ${error.message}`);
    }
    
    // Limpar mensagem após 3 segundos
    setTimeout(() => {
      setStatus('idle');
      setMensagem('');
    }, 3000);
  };
  
  /**
   * Manipula a seleção de arquivo para importação
   */
  const handleSelecionarArquivo = (evento: React.ChangeEvent<HTMLInputElement>) => {
    const arquivos = evento.target.files;
    if (!arquivos || arquivos.length === 0) return;
    
    const arquivo = arquivos[0];
    setArquivoSelecionado(arquivo);
    setMostrarConfirmacao(true);
  };
  
  /**
   * Cancela a importação e limpa o arquivo selecionado
   */
  const cancelarImportacao = () => {
    setArquivoSelecionado(null);
    setMostrarConfirmacao(false);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };
  
  /**
   * Confirma e executa a importação de dados
   */
  const confirmarImportacao = async () => {
    if (!arquivoSelecionado) return;
    
    setStatus('importing');
    setMostrarConfirmacao(false);
    
    try {
      const resultado = await importarDados(arquivoSelecionado);
      if (resultado.sucesso) {
        setStatus('success');
        
        // Registrar no histórico com o timestamp do backup
        registrarImportacao(resultado.timestamp);
        
        // Formatar a data do backup
        const dataBackup = new Date(resultado.timestamp || new Date().toISOString());
        const dataFormatada = dataBackup.toLocaleDateString('pt-BR', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        setMensagem(`Dados importados com sucesso! (Backup de ${dataFormatada})`);
      } else {
        throw new Error(resultado.erro);
      }
    } catch (error: any) {
      setStatus('error');
      setMensagem(`Erro ao importar: ${error.message}`);
    }
    
    // Resetar input de arquivo
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
    
    setArquivoSelecionado(null);
  };
  
  return (
    <div className="w-full max-w-md mx-auto bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
      <div className="mb-6">
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-semibold mb-2 text-gray-800 dark:text-white">Importar/Exportar Dados</h2>
          <Link 
            href="/perfil/ajuda" 
            className="text-blue-600 dark:text-blue-400 hover:underline flex items-center"
            title="Ajuda com importação e exportação"
          >
            <HelpCircle size={16} />
          </Link>
        </div>
        <p className="text-sm text-gray-600 dark:text-gray-300">
          Faça backup dos seus dados ou restaure a partir de um backup anterior
        </p>
      </div>
      
      <div className="space-y-6">
        {/* Histórico de transferências */}
        {(ultimaExportacao || ultimaImportacao) && (
          <div className="text-xs text-gray-500 dark:text-gray-400 space-y-1">
            {ultimaExportacao && (
              <div className="flex items-center gap-1">
                <Clock size={12} />
                <span>Última exportação: {formatarData(ultimaExportacao)}</span>
              </div>
            )}
            {ultimaImportacao && (
              <div className="flex items-center gap-1">
                <Clock size={12} />
                <span>Última importação: {formatarData(ultimaImportacao)}</span>
              </div>
            )}
          </div>
        )}
        
        {/* Seção de Exportação */}
        <div className="space-y-2">
          <button 
            onClick={handleExportar}
            disabled={status === 'exporting' || status === 'importing'}
            className="w-full flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Download size={18} />
            Exportar Dados
          </button>
          <p className="text-xs text-gray-500 dark:text-gray-400">
            Cria um arquivo JSON com todos os seus dados para backup
          </p>
        </div>
        
        {/* Seção de Importação */}
        <div className="space-y-2 pt-4 border-t border-gray-200 dark:border-gray-700">
          <button
            onClick={() => fileInputRef.current?.click()}
            disabled={status === 'exporting' || status === 'importing' || mostrarConfirmacao}
            className="w-full flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-800 dark:text-white py-2 px-4 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Upload size={18} />
            Importar Dados
          </button>
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleSelecionarArquivo}
            accept=".json"
            className="hidden"
          />
          <p className="text-xs text-gray-500 dark:text-gray-400">
            Restaura seus dados a partir de um arquivo de backup
          </p>
        </div>
        
        {/* Diálogo de confirmação */}
        {mostrarConfirmacao && arquivoSelecionado && (
          <div className="mt-4 p-4 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-800 rounded-md">
            <div className="flex items-start gap-3">
              <Info className="text-yellow-500 mt-0.5 flex-shrink-0" size={20} />
              <div>
                <h3 className="font-medium text-yellow-800 dark:text-yellow-200">Confirmar importação</h3>
                <p className="text-sm text-yellow-700 dark:text-yellow-300 mt-1">
                  Isso substituirá seus dados atuais pelos dados do arquivo selecionado.
                  Arquivo: {arquivoSelecionado.name}
                </p>
                <div className="flex gap-2 mt-3">
                  <button 
                    onClick={confirmarImportacao}
                    className="px-3 py-1 text-sm bg-yellow-600 hover:bg-yellow-700 text-white rounded-md"
                  >
                    Importar
                  </button>
                  <button 
                    onClick={cancelarImportacao}
                    className="px-3 py-1 text-sm bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-white rounded-md"
                  >
                    Cancelar
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}
        
        {/* Mensagem de status */}
        {mensagem && (
          <div className={`mt-4 flex items-start gap-3 p-3 rounded-md ${
            status === 'success' ? 'bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-800' : 
            status === 'error' ? 'bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-800' : ''
          }`}>
            {status === 'success' ? 
              <CheckCircle className="text-green-500 flex-shrink-0" size={18} /> : 
              <AlertCircle className="text-red-500 flex-shrink-0" size={18} />
            }
            <p className={`text-sm ${
              status === 'success' ? 'text-green-700 dark:text-green-300' : 
              status === 'error' ? 'text-red-700 dark:text-red-300' : ''
            }`}>
              {mensagem}
            </p>
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="app/components/SyncStatusNotification.js">
import React, { useState, useEffect, useContext } from 'react';
import { createPortal } from 'react-dom';
import { getUserFriendlyMessage, categorizeError } from '../lib/utils/errorHandler';
import { logError, logPerformance } from '../lib/utils/logger';

// Contexto para gerenciar o estado de sincronização global
export const SyncContext = React.createContext({
  syncStatus: 'idle', // 'idle', 'syncing', 'error', 'success', 'retrying'
  syncError: null,
  errorType: null, // 'network', 'server', 'auth', 'unknown'
  pendingSyncCount: 0,
  retryCount: 0,
  retryAttempts: 0,
  maxRetries: 5,
  lastErrorTime: null,
  queryPerformance: {},
  setSyncStatus: () => {},
  setSyncError: () => {},
  setPendingSyncCount: () => {},
  retrySync: () => {},
  resetRetry: () => {},
  logQueryPerformance: () => {}
});

export const SyncProvider = ({ children }) => {
  const [syncStatus, setSyncStatus] = useState('idle');
  const [syncError, setSyncError] = useState(null);
  const [errorType, setErrorType] = useState(null);
  const [pendingSyncCount, setPendingSyncCount] = useState(0);
  const [retryCount, setRetryCount] = useState(0);
  const [retryAttempts, setRetryAttempts] = useState(0);
  const [maxRetries] = useState(5);
  const [lastErrorTime, setLastErrorTime] = useState(null);
  const [queryPerformance, setQueryPerformance] = useState({});

  // Função para manipular erros com mais detalhes
  const handleSyncError = (error) => {
    const errorInfo = categorizeError(error);
    setSyncError(error);
    setErrorType(errorInfo.type);
    setSyncStatus('error');
    setLastErrorTime(new Date());
    logError('Sync Error', { error, type: errorInfo.type, details: errorInfo.details });
    
    // Iniciar retentativas automáticas apenas para erros de rede
    if (errorInfo.type === 'network' && retryAttempts < maxRetries) {
      scheduleRetry();
    }
  };

  // Função para retentativa com backoff exponencial
  const scheduleRetry = () => {
    setRetryAttempts(prev => prev + 1);
    setSyncStatus('retrying');
    
    // Cálculo do tempo de backoff exponencial (1s, 2s, 4s, 8s, 16s)
    const backoffTime = Math.min(1000 * Math.pow(2, retryAttempts), 30000);
    
    logError('Scheduling retry', {
      attempt: retryAttempts + 1, 
      maxRetries, 
      backoffTime
    });
    
    const timerId = setTimeout(() => {
      setRetryCount(prev => prev + 1);
      // Dispara evento para retry
      window.dispatchEvent(new CustomEvent('sync:retry'));
    }, backoffTime);
    
    return () => clearTimeout(timerId);
  };

  // Reset das tentativas de retry
  const resetRetry = () => {
    setRetryAttempts(0);
  };

  // Registrar dados de performance das queries
  const logQueryPerformance = (queryName, duration, success, dataSize) => {
    const perfData = {
      timestamp: new Date(),
      duration,
      success,
      dataSize
    };
    
    setQueryPerformance(prev => ({
      ...prev,
      [queryName]: [...(prev[queryName] || []), perfData]
    }));
    
    logPerformance('Query Performance', {
      query: queryName,
      duration,
      success,
      dataSize
    });
  };

  return (
    <SyncContext.Provider value={{
      syncStatus, 
      syncError, 
      errorType,
      pendingSyncCount,
      retryCount,
      retryAttempts,
      maxRetries,
      lastErrorTime,
      queryPerformance,
      setSyncStatus,
      setSyncError: handleSyncError,
      setPendingSyncCount,
      retrySync: scheduleRetry,
      resetRetry,
      logQueryPerformance
    }}>
      {children}
      <SyncStatusNotification />
    </SyncContext.Provider>
  );
};

// Hook para usar o contexto de sincronização
export const useSyncStatus = () => useContext(SyncContext);

// Componente de notificação
const SyncStatusNotification = () => {
  const { 
    syncStatus, 
    syncError, 
    errorType, 
    pendingSyncCount,
    retryAttempts,
    maxRetries
  } = useSyncStatus();
  const [visible, setVisible] = useState(false);
  const [isOffline, setIsOffline] = useState(false);
  
  useEffect(() => {
    // Verificar status de conexão
    const checkConnection = () => {
      setIsOffline(!navigator.onLine);
    };
    
    window.addEventListener('online', checkConnection);
    window.addEventListener('offline', checkConnection);
    checkConnection();
    
    return () => {
      window.removeEventListener('online', checkConnection);
      window.removeEventListener('offline', checkConnection);
    };
  }, []);
  
  useEffect(() => {
    if (syncStatus === 'idle' && !isOffline) {
      setVisible(false);
      return;
    }
    
    setVisible(true);
    
    // Esconder automaticamente após sucesso
    if (syncStatus === 'success' && !isOffline) {
      const timer = setTimeout(() => setVisible(false), 3000);
      return () => clearTimeout(timer);
    }
  }, [syncStatus, isOffline]);

  if (!visible) return null;

  // Estilos e conteúdo baseados no status
  let icon, message, backgroundColor;
  
  if (isOffline) {
    icon = '📱';
    message = 'Modo offline - Seus dados estão salvos localmente';
    backgroundColor = '#f39c12';
  } else {
    switch (syncStatus) {
      case 'syncing':
        icon = '🔄';
        message = 'Sincronizando dados...';
        backgroundColor = '#3498db';
        break;
      case 'retrying':
        icon = '🔄';
        message = `Reconectando (${retryAttempts}/${maxRetries})...`;
        backgroundColor = '#f39c12';
        break;
      case 'error':
        icon = '❌';
        message = syncError ? getUserFriendlyMessage(syncError, errorType) : 
                  'Erro ao sincronizar. Seus dados estão salvos localmente.';
        backgroundColor = '#e74c3c';
        break;
      case 'success':
        icon = '✅';
        message = 'Sincronização concluída com sucesso!';
        backgroundColor = '#2ecc71';
        break;
      default:
        return null;
    }
  }

  // Adicionar badge para itens pendentes
  const pendingBadge = pendingSyncCount > 0 ? (
    <span className="pending-badge" style={{
      position: 'absolute',
      top: '-8px',
      right: '-8px',
      backgroundColor: '#e74c3c',
      color: 'white',
      borderRadius: '50%',
      width: '20px',
      height: '20px',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      fontSize: '12px',
      fontWeight: 'bold'
    }}>{pendingSyncCount}</span>
  ) : null;

  return createPortal(
    <div 
      className="sync-notification"
      style={{
        position: 'fixed',
        bottom: '20px',
        right: '20px',
        padding: '12px 16px',
        borderRadius: '4px',
        backgroundColor,
        color: '#fff',
        boxShadow: '0 2px 10px rgba(0,0,0,0.2)',
        display: 'flex',
        alignItems: 'center',
        zIndex: 9999,
        maxWidth: '300px',
        position: 'relative'
      }}
    >
      <div className="icon" style={{ marginRight: '10px' }}>{icon}</div>
      <div className="message">{message}</div>
      {pendingBadge}
      {(syncStatus === 'error' && errorType !== 'network') && (
        <button 
          className="retry-button"
          style={{
            marginLeft: '10px',
            background: 'transparent',
            border: '1px solid white',
            color: 'white',
            padding: '4px 8px',
            borderRadius: '3px',
            cursor: 'pointer'
          }}
          onClick={() => {
            // Trigger retry logic
            window.dispatchEvent(new CustomEvent('sync:retry'));
          }}
        >
          Tentar novamente
        </button>
      )}
      {(syncStatus === 'retrying') && (
        <div className="retry-progress" style={{
          position: 'absolute',
          bottom: '0',
          left: '0',
          height: '3px',
          backgroundColor: 'rgba(255,255,255,0.5)',
          width: `${(retryAttempts / maxRetries) * 100}%`
        }}></div>
      )}
    </div>,
    document.body
  );
};

export default SyncStatusNotification;
</file>

<file path="app/components/ThemeProvider.tsx">
'use client'

import { createContext, useContext, useEffect, useState } from 'react'

type Theme = 'dark' | 'light' | 'system'

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  enableSystem?: boolean
  disableTransitionOnChange?: boolean
  attribute?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
  systemTheme: 'dark' | 'light' | undefined
}

const initialState: ThemeProviderState = {
  theme: 'system',
  setTheme: () => null,
  systemTheme: undefined,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = 'system',
  enableSystem = true,
  disableTransitionOnChange = false,
  attribute = 'class',
  ...props
}: ThemeProviderProps) {
  const [theme, setThemeState] = useState<Theme>(defaultTheme)
  const [systemTheme, setSystemTheme] = useState<'dark' | 'light' | undefined>(undefined)

  useEffect(() => {
    const root = window.document.documentElement
    
    // Remove transition classes
    if (disableTransitionOnChange) {
      root.classList.add('transition-none')
      window.setTimeout(() => {
        root.classList.remove('transition-none')
      }, 0)
    }

    // Check for system preference
    if (theme === 'system' && enableSystem) {
      const systemPreference = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
      setSystemTheme(systemPreference)
      
      root.classList.remove('light', 'dark')
      root.classList.add(systemPreference)
      return
    }

    // Apply theme
    root.classList.remove('light', 'dark')
    root.classList.add(theme)
  }, [theme, disableTransitionOnChange, enableSystem])

  // Listen for system preference changes
  useEffect(() => {
    if (!enableSystem) return

    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
    
    const handleChange = () => {
      const newSystemTheme = mediaQuery.matches ? 'dark' : 'light'
      setSystemTheme(newSystemTheme)
      
      if (theme === 'system') {
        document.documentElement.classList.remove('light', 'dark')
        document.documentElement.classList.add(newSystemTheme)
      }
    }

    mediaQuery.addEventListener('change', handleChange)
    return () => mediaQuery.removeEventListener('change', handleChange)
  }, [enableSystem, theme])

  const setTheme = (theme: Theme) => {
    setThemeState(theme)
    // Save to localStorage
    localStorage.setItem('theme', theme)
  }

  // Initialize from localStorage
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as Theme | null
    if (savedTheme) {
      setThemeState(savedTheme)
    }
  }, [])

  const value = {
    theme,
    setTheme,
    systemTheme,
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }

  return context
}
</file>

<file path="app/context/ToastContext.tsx">
'use client'

import React, { createContext, useContext, useState, ReactNode } from 'react'
import { Toast } from '../components/ui/Toast'

type ToastType = 'success' | 'error' | 'info' | 'warning'

type ToastContextType = {
  showToast: (message: string, type: ToastType, duration?: number) => void
  hideToast: () => void
}

const ToastContext = createContext<ToastContextType | undefined>(undefined)

export function useToast() {
  const context = useContext(ToastContext)
  if (!context) {
    throw new Error('useToast deve ser usado dentro de um ToastProvider')
  }
  return context
}

type ToastProviderProps = {
  children: ReactNode
}

export function ToastProvider({ children }: ToastProviderProps) {
  const [toast, setToast] = useState<{
    message: string
    type: ToastType
    duration: number
    show: boolean
  }>({
    message: '',
    type: 'info',
    duration: 5000,
    show: false
  })

  const showToast = (message: string, type: ToastType = 'info', duration: number = 5000) => {
    setToast({
      message,
      type,
      duration,
      show: true
    })
  }

  const hideToast = () => {
    setToast(prev => ({
      ...prev,
      show: false
    }))
  }

  return (
    <ToastContext.Provider value={{ showToast, hideToast }}>
      {children}
      <Toast
        message={toast.message}
        type={toast.type}
        duration={toast.duration}
        show={toast.show}
        onClose={hideToast}
      />
    </ToastContext.Provider>
  )
}
</file>

<file path="app/dashboard/sono/page.tsx">
import { Tabs } from "@/app/components/ui/Tabs";
import VisualizadorSemanal from "@/app/components/sono/VisualizadorSemanal";
import ConfiguracaoLembretes from "@/app/components/sono/ConfiguracaoLembretes";
import SleepDataMigration from "@/app/components/sono/SleepDataMigration";

export default function SonoPage() {
  return (
    <div className="p-4 md:p-6 space-y-6">
      <div className="flex flex-col space-y-2">
        <h1 className="text-3xl font-bold tracking-tight">Sono</h1>
        <p className="text-muted-foreground">
          Acompanhe seus padrões de sono e estabeleça rotinas saudáveis.
        </p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2">
          <Tabs 
            tabs={[
              {
                id: "visualizador",
                label: "Visualizador Semanal",
                content: <VisualizadorSemanal />
              },
              {
                id: "lembretes",
                label: "Lembretes",
                content: <ConfiguracaoLembretes />
              }
            ]}
            defaultTab="visualizador"
          />
        </div>
        
        <div className="space-y-6">
          <SleepDataMigration />
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/estudos/page.tsx">
import { Card, CardHeader, CardTitle, CardContent } from '@/app/components/ui/Card'
import { TemporizadorPomodoro } from '@/app/components/estudos/TemporizadorPomodoro'
import { RegistroEstudos } from '@/app/components/estudos/RegistroEstudos'

export default function EstudosPage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Estudos</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Temporizador Pomodoro Adaptado */}
        <Card>
          <CardHeader>
            <CardTitle>Temporizador Pomodoro</CardTitle>
          </CardHeader>
          <CardContent>
            <TemporizadorPomodoro />
          </CardContent>
        </Card>
        
        {/* Registro de Sessões de Estudo */}
        <Card>
          <CardHeader>
            <CardTitle>Registro de Estudos</CardTitle>
          </CardHeader>
          <CardContent>
            <RegistroEstudos />
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="app/financas/page.tsx">
import { Card, CardHeader, CardTitle, CardContent } from '@/app/components/ui/Card'
import { RastreadorGastos } from '@/app/components/financas/RastreadorGastos'
import { EnvelopesVirtuais } from '@/app/components/financas/EnvelopesVirtuais'
import { CalendarioPagamentos } from '@/app/components/financas/CalendarioPagamentos'
import { AdicionarDespesa } from '@/app/components/financas/AdicionarDespesa'

export default function FinancasPage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Finanças</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Rastreador de Gastos */}
        <Card>
          <CardHeader>
            <CardTitle>Rastreador de Gastos</CardTitle>
          </CardHeader>
          <CardContent>
            <RastreadorGastos />
          </CardContent>
        </Card>
        
        {/* Envelopes Virtuais */}
        <Card>
          <CardHeader>
            <CardTitle>Envelopes Virtuais</CardTitle>
          </CardHeader>
          <CardContent>
            <EnvelopesVirtuais />
          </CardContent>
        </Card>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Calendário de Pagamentos */}
        <Card>
          <CardHeader>
            <CardTitle>Calendário de Pagamentos</CardTitle>
          </CardHeader>
          <CardContent>
            <CalendarioPagamentos />
          </CardContent>
        </Card>
        
        {/* Adicionar Despesa Rápida */}
        <Card>
          <CardHeader>
            <CardTitle>Adicionar Despesa</CardTitle>
          </CardHeader>
          <CardContent>
            <AdicionarDespesa />
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="app/hiperfocos/page.tsx">
'use client'

import { useState } from 'react'
import { ConversorInteresses } from '../components/hiperfocos/ConversorInteresses'
import { SistemaAlternancia } from '../components/hiperfocos/SistemaAlternancia'
import { VisualizadorProjetos } from '../components/hiperfocos/VisualizadorProjetos'
import { TemporizadorFoco } from '../components/hiperfocos/TemporizadorFoco'
import { useHiperfocosStore } from '../stores/hiperfocosStore'

export default function HiperfocosPage() {
  // Separamos a interface em guias para melhor organização
  const [tabAtiva, setTabAtiva] = useState<'conversor' | 'alternancia' | 'visualizador' | 'temporizador'>('conversor')
  const { hiperfocos } = useHiperfocosStore()

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6 text-gray-800 dark:text-white flex items-center">
        <span role="img" aria-label="Foguete" className="mr-2">🚀</span>
        Hiperfocos
      </h1>
      
      <p className="text-gray-600 dark:text-gray-300 mb-8">
        Transforme seus interesses intensos em projetos estruturados e gerencie suas transições de foco.
      </p>
      
      {/* Tabs de navegação */}
      <div className="flex flex-wrap gap-2 mb-6 border-b border-gray-200 dark:border-gray-700">
        <button
          onClick={() => setTabAtiva('conversor')}
          className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
            tabAtiva === 'conversor'
              ? 'bg-hiperfocos-light text-hiperfocos-primary border-b-2 border-hiperfocos-primary'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white'
          }`}
          aria-current={tabAtiva === 'conversor' ? 'page' : undefined}
        >
          Conversor de Interesses
        </button>
        
        <button
          onClick={() => setTabAtiva('alternancia')}
          className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
            tabAtiva === 'alternancia'
              ? 'bg-hiperfocos-light text-hiperfocos-primary border-b-2 border-hiperfocos-primary'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white'
          }`}
          aria-current={tabAtiva === 'alternancia' ? 'page' : undefined}
        >
          Sistema de Alternância
        </button>
        
        <button
          onClick={() => setTabAtiva('visualizador')}
          className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
            tabAtiva === 'visualizador'
              ? 'bg-hiperfocos-light text-hiperfocos-primary border-b-2 border-hiperfocos-primary'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white'
          }`}
          aria-current={tabAtiva === 'visualizador' ? 'page' : undefined}
        >
          Estrutura de Projetos
        </button>
        
        <button
          onClick={() => setTabAtiva('temporizador')}
          className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
            tabAtiva === 'temporizador'
              ? 'bg-hiperfocos-light text-hiperfocos-primary border-b-2 border-hiperfocos-primary'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white'
          }`}
          aria-current={tabAtiva === 'temporizador' ? 'page' : undefined}
        >
          Temporizador
        </button>
      </div>
      
      {/* Conteúdo da tab ativa */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
        {tabAtiva === 'conversor' && <ConversorInteresses />}
        {tabAtiva === 'alternancia' && <SistemaAlternancia />}
        {tabAtiva === 'visualizador' && <VisualizadorProjetos />}
        {tabAtiva === 'temporizador' && <TemporizadorFoco />}
      </div>
      
      {/* Card de resumo - visível em todas as abas */}
      {hiperfocos.length > 0 && (
        <div className="mt-8 bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
          <h2 className="text-lg font-medium mb-2 text-gray-800 dark:text-white">Resumo dos Hiperfocos</h2>
          <div className="space-y-2">
            {hiperfocos.map((hiperfoco) => (
              <div 
                key={hiperfoco.id} 
                className="px-3 py-2 rounded-md flex justify-between"
                style={{ backgroundColor: `${hiperfoco.cor}20` }}
              >
                <span className="font-medium" style={{ color: hiperfoco.cor }}>
                  {hiperfoco.titulo}
                </span>
                <span className="text-gray-600 dark:text-gray-300">
                  {hiperfoco.tarefas.filter(t => t.concluida).length}/{hiperfoco.tarefas.length} tarefas
                </span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/hooks/useAuth.ts">
'use client'

import { useCallback, useEffect, useState } from 'react';
import { useSupabase } from '../components/providers/supabase-provider';
import { useRouter } from 'next/navigation';
import { User, Session } from '@supabase/supabase-js';

export function useAuth() {
  const { supabase } = useSupabase();
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const router = useRouter();

  // Função para sincronizar dados do localStorage com Supabase
  const syncLocalDataWithSupabase = useCallback(async (userId: string) => {
    try {
      const localData = localStorage.getItem('zustand');
      if (!localData) return;

      const parsedData = JSON.parse(localData);
      const state = parsedData?.state;

      if (!state) return;

      // Sincronizar prioridades
      if (state.prioridades?.length > 0) {
        const { error: prioritiesError } = await supabase
          .from('priorities')
          .upsert(
            state.prioridades.map((p: any) => ({
              user_id: userId,
              content: p.texto,
              completed: p.concluida,
              category: p.categoria,
              due_date: p.dataVencimento
            })),
            { onConflict: 'user_id,content' }
          );

        if (prioritiesError) console.error('Erro ao sincronizar prioridades:', prioritiesError);
      }

      // Sincronizar medicamentos
      if (state.medicamentos?.length > 0) {
        const { error: medsError } = await supabase
          .from('medications')
          .upsert(
            state.medicamentos.map((m: any) => ({
              user_id: userId,
              name: m.nome,
              dosage: m.dosagem,
              frequency: m.frequencia,
              schedule: m.horarios,
              start_date: m.dataInicio,
              notes: m.observacoes,
              last_taken: m.ultimaTomada,
              interval_minutes: m.intervalo
            })),
            { onConflict: 'user_id,name,dosage' }
          );

        if (medsError) console.error('Erro ao sincronizar medicamentos:', medsError);
      }

      // Sincronizar registros de humor
      if (state.registrosHumor?.length > 0) {
        const { error: moodError } = await supabase
          .from('mood_records')
          .upsert(
            state.registrosHumor.map((r: any) => ({
              user_id: userId,
              record_date: r.data,
              mood_level: r.nivel,
              factors: r.fatores,
              notes: r.notas
            })),
            { onConflict: 'user_id,record_date' }
          );

        if (moodError) console.error('Erro ao sincronizar registros de humor:', moodError);
      }

      // Sincronizar registros de sono
      if (state.registrosSono?.length > 0) {
        const { error: sleepError } = await supabase
          .from('sleep_records')
          .upsert(
            state.registrosSono.map((s: any) => ({
              user_id: userId,
              start_time: s.horaInicio,
              end_time: s.horaFim,
              quality: s.qualidade,
              notes: s.observacoes
            })),
            { onConflict: 'user_id,start_time' }
          );

        if (sleepError) console.error('Erro ao sincronizar registros de sono:', sleepError);
      }
    } catch (err) {
      console.error('Erro ao sincronizar dados:', err);
    }
  }, [supabase]);

  // Carregar o usuário e sessão inicial
  useEffect(() => {
    let mounted = true;

    async function loadUserSession() {
      try {
        setLoading(true);
        
        // Obter sessão atual
        const { data: { session: currentSession }, error: sessionError } = await supabase.auth.getSession();
        if (sessionError) throw sessionError;
        
        if (mounted) {
          setSession(currentSession);
          setUser(currentSession?.user || null);

          // Se houver uma sessão, sincronizar dados
          if (currentSession?.user) {
            await syncLocalDataWithSupabase(currentSession.user.id);
          }
        }
        
        // Configurar listener para mudanças de autenticação
        const { data: { subscription } } = supabase.auth.onAuthStateChange(async (_event, newSession) => {
          if (mounted) {
            setSession(newSession);
            setUser(newSession?.user || null);

            // Se houver uma nova sessão, sincronizar dados
            if (newSession?.user) {
              await syncLocalDataWithSupabase(newSession.user.id);
            }
          }
        });
        
        return () => {
          mounted = false;
          subscription.unsubscribe();
        };
      } catch (err) {
        console.error('Erro ao carregar usuário:', err);
        if (mounted) {
          setError(err instanceof Error ? err : new Error('Erro desconhecido ao carregar usuário'));
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    }
    
    loadUserSession();

    return () => {
      mounted = false;
    };
  }, [supabase, syncLocalDataWithSupabase]);

  // Função de login com email/senha
  const signInWithEmail = useCallback(
    async (email: string, password: string) => {
      try {
        setLoading(true);
        setError(null);
        
        const { data, error: signInError } = await supabase.auth.signInWithPassword({ email, password });
        if (signInError) throw signInError;
        
        // Se o login for bem-sucedido, sincronizar dados
        if (data?.user) {
          await syncLocalDataWithSupabase(data.user.id);
        }
        
        return { data, error: null };
      } catch (err) {
        console.error('Erro ao fazer login:', err);
        setError(err instanceof Error ? err : new Error('Erro desconhecido ao fazer login'));
        return { data: null, error: err };
      } finally {
        setLoading(false);
      }
    },
    [supabase, syncLocalDataWithSupabase]
  );

  // Função de cadastro com email/senha
  const signUpWithEmail = useCallback(
    async (email: string, password: string, userData?: { [key: string]: any }) => {
      try {
        setLoading(true);
        setError(null);
        
        const { data, error: signUpError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: userData
          }
        });
        
        if (signUpError) throw signUpError;
        return { data, error: null };
      } catch (err) {
        console.error('Erro ao criar conta:', err);
        setError(err instanceof Error ? err : new Error('Erro desconhecido ao criar conta'));
        return { data: null, error: err };
      } finally {
        setLoading(false);
      }
    },
    [supabase]
  );

  // Função de logout
  const signOut = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const { error: signOutError } = await supabase.auth.signOut();
      if (signOutError) throw signOutError;
      
      router.push('/auth/login');
      
      return { success: true, error: null };
    } catch (err) {
      console.error('Erro ao fazer logout:', err);
      setError(err instanceof Error ? err : new Error('Erro desconhecido ao fazer logout'));
      return { success: false, error: err };
    } finally {
      setLoading(false);
    }
  }, [supabase, router]);

  // Login com OAuth (Google)
  const signInWithGoogle = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const { data, error: oauthError } = await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: `${window.location.origin}/auth/callback`
        }
      });
      
      if (oauthError) throw oauthError;
      return { data, error: null };
    } catch (err) {
      console.error('Erro ao fazer login com Google:', err);
      setError(err instanceof Error ? err : new Error('Erro desconhecido ao fazer login com Google'));
      return { data: null, error: err };
    } finally {
      setLoading(false);
    }
  }, [supabase]);

  return {
    user,
    session,
    loading,
    error,
    signInWithEmail,
    signUpWithEmail,
    signOut,
    signInWithGoogle
  };
}
</file>

<file path="app/hooks/useBidirectionalSync.ts">
import { useCallback, useEffect, useState, useRef } from 'react';
import { createClient } from '../lib/supabase';
import { useAuthContext } from '../context/AuthContext';
import { v4 as uuidv4 } from 'uuid';

// Tipo genérico para itens sincronizáveis
interface SyncableItem {
  id: string;
  version: number;
  device_id?: string | null;
  last_synced_at?: string | null;
  [key: string]: any;
}

interface SyncOptions {
  table: string;
  localStorageKey: string;
  getLocalData: () => any[];
  setLocalData: (data: any[]) => void;
}

export function useBidirectionalSync<T extends SyncableItem>(options: SyncOptions) {
  const { table, localStorageKey, getLocalData, setLocalData } = options;
  const supabase = createClient();
  const { user } = useAuthContext();
  const [isSyncing, setIsSyncing] = useState(false);
  const [lastSyncTime, setLastSyncTime] = useState<string | null>(null);
  const [deviceId] = useState(() => localStorage.getItem('deviceId') || uuidv4());
  
  // Ref para controlar se o componente está montado
  const isMounted = useRef(true);
  // Ref para armazenar a subscription do canal
  const channelRef = useRef<any>(null);

  // Garantir que o deviceId seja persistido
  useEffect(() => {
    if (!localStorage.getItem('deviceId')) {
      localStorage.setItem('deviceId', deviceId);
    }
    
    // Limpeza quando o componente desmontar
    return () => {
      isMounted.current = false;
    };
  }, [deviceId]);

  // Função segura para atualizar state
  const safeSetState = useCallback((setter: Function, value: any) => {
    if (isMounted.current) {
      setter(value);
    }
  }, []);

  // Função para obter mudanças do servidor desde a última sincronização
  const getServerChanges = useCallback(async () => {
    if (!user) return [];

    try {
      const query = supabase
        .from(table)
        .select('*')
        .eq('user_id', user.id);

      if (lastSyncTime) {
        query.gt('last_synced_at', lastSyncTime);
      }

      const { data, error } = await query;

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Erro ao obter mudanças do servidor:', error);
      return [];
    }
  }, [user, table, lastSyncTime, supabase]);

  // Função para resolver conflitos entre dados locais e do servidor
  const resolveConflicts = useCallback((localItems: T[], serverItems: T[]): T[] => {
    const mergedItems = new Map<string, T>();

    // Primeiro, adicionar todos os itens locais
    localItems.forEach(item => {
      mergedItems.set(item.id, item);
    });

    // Depois, resolver conflitos com itens do servidor
    serverItems.forEach(serverItem => {
      const localItem = mergedItems.get(serverItem.id);

      if (!localItem) {
        // Item novo do servidor
        mergedItems.set(serverItem.id, serverItem);
      } else if (serverItem.version > localItem.version) {
        // Versão do servidor é mais recente
        mergedItems.set(serverItem.id, serverItem);
      }
      // Se a versão local for maior, manter a versão local
    });

    return Array.from(mergedItems.values());
  }, []);

  // Função para sincronizar dados com o servidor
  const syncWithServer = useCallback(async () => {
    if (!user || isSyncing || !isMounted.current) return;

    try {
      safeSetState(setIsSyncing, true);

      // 1. Obter mudanças do servidor
      const serverChanges = await getServerChanges();
      
      // Verificar novamente se componente ainda está montado
      if (!isMounted.current) return;

      // 2. Obter dados locais
      const localData = getLocalData();

      // 3. Resolver conflitos
      const resolvedData = resolveConflicts(localData, serverChanges);

      // 4. Atualizar dados locais
      setLocalData(resolvedData);

      // 5. Enviar dados locais para o servidor
      const { error } = await supabase.from(table).upsert(
        resolvedData.map(item => ({
          ...item,
          user_id: user.id,
          device_id: deviceId,
          last_synced_at: new Date().toISOString()
        }))
      );

      if (error) throw error;

      // Verificar novamente se componente ainda está montado
      if (!isMounted.current) return;

      // 6. Atualizar timestamp da última sincronização
      const newSyncTime = new Date().toISOString();
      safeSetState(setLastSyncTime, newSyncTime);
      localStorage.setItem(`${localStorageKey}_lastSync`, newSyncTime);

    } catch (error) {
      console.error('Erro durante a sincronização:', error);
    } finally {
      if (isMounted.current) {
        safeSetState(setIsSyncing, false);
      }
    }
  }, [user, isSyncing, getServerChanges, getLocalData, setLocalData, resolveConflicts, table, deviceId, localStorageKey, supabase, safeSetState]);

  // Configurar sincronização automática
  useEffect(() => {
    if (!user) return;

    // Carregar último timestamp de sincronização
    const savedSyncTime = localStorage.getItem(`${localStorageKey}_lastSync`);
    if (savedSyncTime) {
      safeSetState(setLastSyncTime, savedSyncTime);
    }

    // Sincronizar imediatamente ao montar
    syncWithServer();

    // Configurar sincronização periódica
    const syncIntervalId = setInterval(() => {
      if (isMounted.current) {
        syncWithServer();
      }
    }, 30000); // 30 segundos

    // Configurar listener para mudanças no localStorage
    const handleStorageChange = (event: StorageEvent) => {
      if (event.key === localStorageKey && isMounted.current) {
        syncWithServer();
      }
    };

    window.addEventListener('storage', handleStorageChange);

    // Configurar Realtime subscription
    const channel = supabase
      .channel('db_changes')
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public',
          table: table,
          filter: `user_id=eq.${user.id}`
        },
        () => {
          if (isMounted.current) {
            syncWithServer();
          }
        }
      )
      .subscribe();
    
    // Armazenar referência ao canal
    channelRef.current = channel;

    // Cleanup
    return () => {
      clearInterval(syncIntervalId);
      window.removeEventListener('storage', handleStorageChange);
      
      // Garantir que a inscrição do canal seja cancelada
      if (channelRef.current) {
        channelRef.current.unsubscribe();
        channelRef.current = null;
      }
      
      // Marcar componente como desmontado
      isMounted.current = false;
    };
  }, [user, localStorageKey, syncWithServer, supabase, table, safeSetState]);

  return {
    isSyncing,
    lastSyncTime,
    syncWithServer
  };
}
</file>

<file path="app/hooks/useFetch.js">
import { useState, useEffect, useCallback } from 'react';
import apiService from '../lib/services/api';

// Adicionar suporte para armazenamento local
const getLocalData = (endpoint) => {
  try {
    const data = localStorage.getItem(`offline_${endpoint}`);
    return data ? JSON.parse(data) : null;
  } catch (error) {
    console.warn(`Erro ao ler dados offline para ${endpoint}:`, error);
    return null;
  }
};

const setLocalData = (endpoint, data) => {
  try {
    localStorage.setItem(`offline_${endpoint}`, JSON.stringify(data));
  } catch (error) {
    console.warn(`Erro ao salvar dados offline para ${endpoint}:`, error);
  }
};

const useFetch = (endpoint, options = {}) => {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [shouldRefresh, setShouldRefresh] = useState(0);
  const [isOffline, setIsOffline] = useState(false);

  const fetchData = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      let methodName;
      
      // Mapear endpoints para métodos da API
      switch (endpoint) {
        case '/medications':
          methodName = 'getMedications';
          break;
        case '/mood_records':
          methodName = 'getMoodRecords';
          break;
        case '/sleep_records':
          methodName = 'getSleepRecords';
          break;
        case '/priorities':
          methodName = 'getPriorities';
          break;
        default:
          throw new Error(`Endpoint não suportado: ${endpoint}`);
      }
      
      if (!apiService[methodName]) {
        throw new Error(`Método não encontrado para endpoint: ${endpoint}`);
      }
      
      // Tentar buscar dados da API
      try {
        const result = await apiService[methodName]();
        
        // Se o resultado contiver um erro, verificamos dados offline
        if (result && result.error) {
          console.warn(`Aviso ao buscar ${endpoint}: ${result.message}`);
          const offlineData = getLocalData(endpoint);
          if (offlineData) {
            setData(offlineData);
            setIsOffline(true);
          } else {
            setData([]);
          }
        } else {
          setData(result);
          setLocalData(endpoint, result); // Salvar para uso offline
          setIsOffline(false);
        }
      } catch (apiError) {
        // Em caso de erro na API, tentar usar dados offline
        const offlineData = getLocalData(endpoint);
        if (offlineData) {
          setData(offlineData);
          setIsOffline(true);
        } else {
          setData([]);
        }
        throw apiError;
      }
      
    } catch (err) {
      console.error(`Erro ao buscar dados de ${endpoint}:`, err);
      setError(err.message || 'Ocorreu um erro ao buscar os dados');
      setData([]); // Sempre definir como array vazio em caso de erro
    } finally {
      setIsLoading(false);
    }
  }, [endpoint]); // Removida dependência shouldRefresh pois não é usada dentro do callback

  // Função para forçar atualização
  const refresh = useCallback(() => {
    setShouldRefresh(prev => prev + 1);
    fetchData(); // Adicionado chamada direta ao fetchData
  }, [fetchData]);

  useEffect(() => {
    fetchData();
  }, [fetchData, shouldRefresh]); // Adicionado shouldRefresh como dependência

  return { data, isLoading, error, refresh, isOffline };
};

export default useFetch;
</file>

<file path="app/hooks/useHumor.ts">
import { useCallback, useState, useRef, useEffect } from 'react';
import { createClient } from '@/app/lib/supabase';
import { useAuthContext } from '@/app/context/AuthContext';
import { MoodRecord, NewMoodRecord, MoodRecordUpdate } from '@/app/types/supabase';

// Definindo o tipo de retorno para a função de migração
type MigrationResult = {
  success: boolean;
  count: number;
  duplicates: number;
  error?: string;
};

export function useHumor() {
  const supabase = createClient();
  const { user } = useAuthContext();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // Ref para controlar se o componente está montado
  const isMounted = useRef(true);
  
  // Configurar e limpar flag de montagem
  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  
  // Função para limpar erros
  const resetError = useCallback(() => {
    if (isMounted.current) {
      setError(null);
    }
  }, []);

  // GERENCIAMENTO DE REGISTROS DE HUMOR

  // Obter todos os registros de humor do usuário
  const getMoodRecords = useCallback(async (): Promise<MoodRecord[]> => {
    if (!user || !isMounted.current) return [];
    
    if (isMounted.current) {
      setIsLoading(true);
      setError(null);
    }
    
    try {
      const { data, error } = await supabase
        .from('mood_records')
        .select('*')
        .eq('user_id', user.id)
        .order('record_date', { ascending: false });
        
      if (error) throw new Error(error.message);
      
      return data || [];
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar registros de humor';
      if (isMounted.current) {
        setError(new Error(errorMessage));
      }
      return [];
    } finally {
      if (isMounted.current) {
        setIsLoading(false);
      }
    }
  }, [user, supabase]);
  
  // Verificar duplicações antes da migração
  const checkDuplicates = useCallback(async (date: string): Promise<boolean> => {
    if (!user) return false;
    
    try {
      const { data, error } = await supabase
        .from('mood_records')
        .select('id')
        .eq('user_id', user.id)
        .eq('record_date', date)
        .maybeSingle();
        
      if (error) throw new Error(error.message);
      
      return !!data; // retorna true se existir um registro para essa data
    } catch (err) {
      console.error('Erro ao verificar duplicação:', err);
      return false; // em caso de erro, assumimos que não é duplicado
    }
  }, [user, supabase]);
  
  // Obter um registro de humor específico por ID
  const getMoodRecord = useCallback(async (id: string): Promise<MoodRecord | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('mood_records')
        .select('*')
        .eq('id', id)
        .eq('user_id', user.id)
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar registro de humor';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Adicionar um novo registro de humor
  const addMoodRecord = useCallback(async (record: NewMoodRecord): Promise<MoodRecord | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('mood_records')
        .insert([
          { 
            ...record,
            user_id: user.id,
          }
        ])
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao adicionar registro de humor';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Atualizar um registro de humor existente
  const updateMoodRecord = useCallback(async (id: string, updates: MoodRecordUpdate): Promise<MoodRecord | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('mood_records')
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao atualizar registro de humor';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Excluir um registro de humor
  const deleteMoodRecord = useCallback(async (id: string): Promise<boolean> => {
    if (!user) return false;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { error } = await supabase
        .from('mood_records')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id);
        
      if (error) throw new Error(error.message);
      
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao excluir registro de humor';
      setError(new Error(errorMessage));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Migrar registros de humor do localStorage para o Supabase
  const migrateFromLocalStorage = useCallback(async (): Promise<MigrationResult> => {
    if (!user) return { success: false, count: 0, duplicates: 0, error: 'Usuário não autenticado' };
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Obter dados do localStorage
      const localData = localStorage.getItem('zustand');
      if (!localData) return { success: true, count: 0, duplicates: 0 };
      
      // Transformar dados
      const parsedData = JSON.parse(localData);
      if (!parsedData?.state?.registrosHumor || !Array.isArray(parsedData.state.registrosHumor)) {
        return { success: false, count: 0, duplicates: 0, error: 'Formato de dados inválido' };
      }
      
      // Preparar registros para inserção, verificando duplicatas
      const moodRecords = parsedData.state.registrosHumor;
      const toInsert = [];
      let duplicateCount = 0;
      
      for (const record of moodRecords) {
        const isDuplicate = await checkDuplicates(record.data);
        if (isDuplicate) {
          duplicateCount++;
          continue;
        }
        
        toInsert.push({
          record_date: record.data,
          mood_level: record.nivel,
          factors: record.fatores,
          notes: record.notas || '',
          user_id: user.id
        });
      }
      
      if (toInsert.length === 0) {
        return { 
          success: true, 
          count: 0, 
          duplicates: duplicateCount,
          error: duplicateCount > 0 ? `${duplicateCount} registros já existiam no banco de dados` : undefined
        };
      }
      
      // Inserir no Supabase
      const { error } = await supabase.from('mood_records').insert(toInsert);
      
      if (error) throw new Error(error.message);
      
      return { 
        success: true, 
        count: toInsert.length,
        duplicates: duplicateCount
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao migrar registros de humor';
      setError(new Error(errorMessage));
      return { success: false, count: 0, duplicates: 0, error: errorMessage };
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase, checkDuplicates]);
  
  // Obter estatísticas de humor
  const getMoodStats = useCallback(async (startDate: string, endDate: string): Promise<any> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('mood_records')
        .select('*')
        .eq('user_id', user.id)
        .gte('record_date', startDate)
        .lte('record_date', endDate)
        .order('record_date', { ascending: true });
        
      if (error) throw new Error(error.message);
      
      // Calcular estatísticas básicas
      if (!data || data.length === 0) return { average: 0, records: [] };
      
      const sum = data.reduce((acc, record) => acc + record.mood_level, 0);
      const average = sum / data.length;
      
      // Análise de fatores mais comuns
      const factorCount: Record<string, number> = {};
      data.forEach(record => {
        if (record.factors) {
          record.factors.forEach((factor: string) => {
            factorCount[factor] = (factorCount[factor] || 0) + 1;
          });
        }
      });
      
      // Ordenar fatores por frequência
      const sortedFactors = Object.entries(factorCount)
        .sort((a, b) => b[1] - a[1])
        .map(([factor, count]) => ({ factor, count }));
      
      return {
        average,
        lowest: Math.min(...data.map(r => r.mood_level)),
        highest: Math.max(...data.map(r => r.mood_level)),
        records: data,
        commonFactors: sortedFactors.slice(0, 5),
        total: data.length
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar estatísticas de humor';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);

  return {
    // Estado
    isLoading,
    error,
    resetError,
    
    // Operações CRUD
    getMoodRecords,
    getMoodRecord,
    addMoodRecord,
    updateMoodRecord,
    deleteMoodRecord,
    
    // Migração
    migrateFromLocalStorage,
    
    // Análise
    getMoodStats
  };
}
</file>

<file path="app/hooks/useMedications.ts">
import { useCallback, useState, useRef, useEffect } from 'react';
import { createClient } from '@/app/lib/supabase';
import { useAuthContext } from '@/app/context/AuthContext';
import { Medication, MedicationDose, NewMedication, NewMedicationDose, MedicationUpdate } from '@/app/types/supabase';

// Definindo o tipo de retorno para a função de migração
type MigrationResult = {
  success: boolean;
  count: number;
  duplicates: number;
  error?: string;
};

export function useMedications() {
  const supabase = createClient();
  const { user } = useAuthContext();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // Ref para controlar se o componente está montado
  const isMounted = useRef(true);
  
  // Configurar e limpar flag de montagem
  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  
  // Função para limpar erros
  const resetError = useCallback(() => {
    if (isMounted.current) {
      setError(null);
    }
  }, []);

  // GERENCIAMENTO DE MEDICAMENTOS

  // Obter todos os medicamentos do usuário
  const getMedications = useCallback(async (): Promise<Medication[]> => {
    if (!user || !isMounted.current) return [];
    
    if (isMounted.current) {
      setIsLoading(true);
      setError(null);
    }
    
    try {
      const { data, error } = await supabase
        .from('medications')
        .select('*')
        .eq('user_id', user.id)
        .order('name');
        
      if (error) throw new Error(error.message);
      
      return data || [];
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar medicamentos';
      if (isMounted.current) {
        setError(new Error(errorMessage));
      }
      return [];
    } finally {
      if (isMounted.current) {
        setIsLoading(false);
      }
    }
  }, [user, supabase]);
  
  // Verificar duplicações antes da migração
  const checkDuplicates = useCallback(async (name: string, dosage?: string): Promise<boolean> => {
    if (!user) return false;
    
    try {
      const query = supabase
        .from('medications')
        .select('id')
        .eq('user_id', user.id)
        .eq('name', name);
        
      if (dosage) {
        query.eq('dosage', dosage);
      }
      
      const { data, error } = await query.maybeSingle();
        
      if (error) throw new Error(error.message);
      
      return !!data; // retorna true se existir um registro com esse nome/dosagem
    } catch (err) {
      console.error('Erro ao verificar duplicação:', err);
      return false; // em caso de erro, assumimos que não é duplicado
    }
  }, [user, supabase]);
  
  // Obter um medicamento específico por ID
  const getMedication = useCallback(async (id: string): Promise<Medication | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('medications')
        .select('*')
        .eq('id', id)
        .eq('user_id', user.id)
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar medicamento';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Adicionar um novo medicamento
  const addMedication = useCallback(async (medication: NewMedication): Promise<Medication | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('medications')
        .insert([
          { 
            ...medication,
            user_id: user.id,
          }
        ])
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao adicionar medicamento';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Atualizar um medicamento existente
  const updateMedication = useCallback(async (id: string, updates: MedicationUpdate): Promise<Medication | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('medications')
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao atualizar medicamento';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Excluir um medicamento
  const deleteMedication = useCallback(async (id: string): Promise<boolean> => {
    if (!user) return false;
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Primeiro excluir as doses relacionadas
      await supabase
        .from('medication_doses')
        .delete()
        .eq('medication_id', id)
        .eq('user_id', user.id);
      
      // Depois excluir o medicamento
      const { error } = await supabase
        .from('medications')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id);
        
      if (error) throw new Error(error.message);
      
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao excluir medicamento';
      setError(new Error(errorMessage));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // GERENCIAMENTO DE DOSES

  // Registrar uma dose tomada
  const recordMedicationDose = useCallback(async (medicationId: string, dose: NewMedicationDose): Promise<MedicationDose | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Inserir registro de dose
      const { data: doseData, error: doseError } = await supabase
        .from('medication_doses')
        .insert([
          { 
            ...dose,
            medication_id: medicationId,
            user_id: user.id,
          }
        ])
        .select()
        .single();
        
      if (doseError) throw new Error(doseError.message);
      
      // Atualizar a última vez que o medicamento foi tomado
      await supabase
        .from('medications')
        .update({
          last_taken: dose.taken_at,
          updated_at: new Date().toISOString(),
        })
        .eq('id', medicationId)
        .eq('user_id', user.id);
      
      return doseData;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao registrar dose';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Obter histórico de doses para um medicamento
  const getMedicationDoses = useCallback(async (medicationId: string, limit = 10): Promise<MedicationDose[]> => {
    if (!user) return [];
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('medication_doses')
        .select('*')
        .eq('medication_id', medicationId)
        .eq('user_id', user.id)
        .order('taken_at', { ascending: false })
        .limit(limit);
        
      if (error) throw new Error(error.message);
      
      return data || [];
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar histórico de doses';
      setError(new Error(errorMessage));
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);

  // MIGRAÇÃO DE DADOS

  // Migrar medicamentos do localStorage para o Supabase
  const migrateFromLocalStorage = useCallback(async (): Promise<MigrationResult> => {
    if (!user) return { success: false, count: 0, duplicates: 0, error: 'Usuário não autenticado' };
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Obter dados do localStorage
      const localData = localStorage.getItem('zustand');
      if (!localData) return { success: true, count: 0, duplicates: 0 };
      
      // Transformar dados
      const parsedData = JSON.parse(localData);
      if (!parsedData?.state?.medicamentos || !Array.isArray(parsedData.state.medicamentos)) {
        return { success: false, count: 0, duplicates: 0, error: 'Formato de dados inválido' };
      }
      
      // Preparar medicamentos para inserção, verificando duplicatas
      const localMedications = parsedData.state.medicamentos;
      const toInsert = [];
      let duplicateCount = 0;
      
      for (const med of localMedications) {
        const isDuplicate = await checkDuplicates(med.nome, med.dosagem);
        if (isDuplicate) {
          duplicateCount++;
          continue;
        }
        
        toInsert.push({
          name: med.nome,
          dosage: med.dosagem || null,
          frequency: med.frequencia,
          schedule: med.horarios || [],
          start_date: med.dataInicio || null,
          notes: med.observacoes || null,
          last_taken: med.ultimaTomada || null,
          interval_minutes: med.intervalo || null,
          user_id: user.id
        });
      }
      
      if (toInsert.length === 0) {
        return { 
          success: true, 
          count: 0, 
          duplicates: duplicateCount,
          error: duplicateCount > 0 ? `${duplicateCount} medicamentos já existem no banco de dados` : undefined
        };
      }
      
      // Inserir no Supabase
      const { error } = await supabase.from('medications').insert(toInsert);
      
      if (error) throw new Error(error.message);
      
      return { 
        success: true, 
        count: toInsert.length,
        duplicates: duplicateCount
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao migrar medicamentos';
      setError(new Error(errorMessage));
      return { success: false, count: 0, duplicates: 0, error: errorMessage };
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase, checkDuplicates]);

  return {
    // Estado
    isLoading,
    error,
    resetError,
    
    // Operações de medicamentos
    getMedications,
    getMedication,
    addMedication,
    updateMedication,
    deleteMedication,
    
    // Operações de doses
    recordMedicationDose,
    getMedicationDoses,
    
    // Migração
    migrateFromLocalStorage
  };
}
</file>

<file path="app/hooks/usePriorities.ts">
import { useCallback, useState, useRef, useEffect } from 'react';
import { createClient } from '@/app/lib/supabase';
import { useAuthContext } from '@/app/context/AuthContext';
import { Priority } from '@/app/types/supabase';

export function usePriorities() {
  const supabase = createClient();
  const { user } = useAuthContext();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // Ref para controlar se o componente está montado
  const isMounted = useRef(true);
  
  // Configurar e limpar flag de montagem
  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  
  // Função para limpar erros
  const resetError = useCallback(() => {
    if (isMounted.current) {
      setError(null);
    }
  }, []);
  
  // Obter todas as prioridades do usuário
  const getPriorities = useCallback(async (): Promise<Priority[]> => {
    if (!user || !isMounted.current) return [];
    
    if (isMounted.current) {
      setIsLoading(true);
      setError(null);
    }
    
    try {
      const { data, error } = await supabase
        .from('priorities')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });
        
      if (error) throw new Error(error.message);
      
      return data || [];
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar prioridades';
      if (isMounted.current) {
        setError(new Error(errorMessage));
      }
      return [];
    } finally {
      if (isMounted.current) {
        setIsLoading(false);
      }
    }
  }, [user, supabase]);
  
  // Verificar duplicações antes da migração
  const checkDuplicates = useCallback(async (content: string): Promise<boolean> => {
    if (!user || !isMounted.current) return false;
    
    try {
      const { data, error } = await supabase
        .from('priorities')
        .select('id')
        .eq('user_id', user.id)
        .eq('content', content)
        .maybeSingle();
        
      if (error) throw new Error(error.message);
      
      return !!data; // retorna true se existir um registro com esse conteúdo
    } catch (err) {
      console.error('Erro ao verificar duplicação:', err);
      return false; // em caso de erro, assumimos que não é duplicado
    }
  }, [user, supabase]);
  
  // Obter uma prioridade específica por ID
  const getPriority = useCallback(async (id: string): Promise<Priority | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('priorities')
        .select('*')
        .eq('id', id)
        .eq('user_id', user.id)
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar prioridade';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Adicionar uma nova prioridade
  const addPriority = useCallback(async (priority: Omit<Priority, 'id' | 'user_id' | 'created_at' | 'updated_at'>): Promise<Priority | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('priorities')
        .insert([
          { 
            ...priority,
            user_id: user.id,
          }
        ])
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao adicionar prioridade';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Atualizar uma prioridade existente
  const updatePriority = useCallback(async (id: string, updates: Partial<Omit<Priority, 'id' | 'user_id' | 'created_at'>>): Promise<Priority | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('priorities')
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao atualizar prioridade';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Alternar o estado de conclusão de uma prioridade
  const togglePriorityCompletion = useCallback(async (id: string, completed: boolean): Promise<Priority | null> => {
    return updatePriority(id, { completed });
  }, [updatePriority]);
  
  // Excluir uma prioridade
  const deletePriority = useCallback(async (id: string): Promise<boolean> => {
    if (!user) return false;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { error } = await supabase
        .from('priorities')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id);
        
      if (error) throw new Error(error.message);
      
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao excluir prioridade';
      setError(new Error(errorMessage));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Migrar prioridades do localStorage para o Supabase
  const migrateFromLocalStorage = useCallback(async (): Promise<{ success: boolean; count: number; duplicates: number; error?: string }> => {
    if (!user) return { success: false, count: 0, duplicates: 0, error: 'Usuário não autenticado' };
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Obter dados do localStorage
      const localData = localStorage.getItem('prioridades-diarias');
      if (!localData) return { success: true, count: 0, duplicates: 0 };
      
      // Transformar dados
      const parsedData = JSON.parse(localData);
      if (!parsedData?.state?.prioridades || !Array.isArray(parsedData.state.prioridades)) {
        return { success: false, count: 0, duplicates: 0, error: 'Formato de dados inválido' };
      }
      
      // Preparar prioridades para inserção, verificando duplicatas
      const priorities = parsedData.state.prioridades;
      const toInsert = [];
      let duplicateCount = 0;
      
      for (const p of priorities) {
        const isDuplicate = await checkDuplicates(p.texto);
        if (isDuplicate) {
          duplicateCount++;
          continue;
        }
        
        toInsert.push({
          content: p.texto,
          completed: p.concluida || false,
          due_date: p.data || null,
          category: 'migrated',
          user_id: user.id
        });
      }
      
      if (toInsert.length === 0) {
        return { 
          success: true, 
          count: 0, 
          duplicates: duplicateCount,
          error: duplicateCount > 0 ? `${duplicateCount} prioridades já existiam no banco de dados` : undefined
        };
      }
      
      // Inserir no Supabase
      const { error } = await supabase.from('priorities').insert(toInsert);
      
      if (error) throw new Error(error.message);
      
      return { 
        success: true, 
        count: toInsert.length,
        duplicates: duplicateCount
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao migrar prioridades';
      setError(new Error(errorMessage));
      return { success: false, count: 0, duplicates: 0, error: errorMessage };
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase, checkDuplicates]);
  
  return {
    // Estado
    isLoading,
    error,
    resetError,
    
    // Operações CRUD
    getPriorities,
    getPriority,
    addPriority,
    updatePriority,
    togglePriorityCompletion,
    deletePriority,
    
    // Migração
    migrateFromLocalStorage,
    checkDuplicates
  };
}
</file>

<file path="app/hooks/useToast.ts">
import { useState } from 'react';

interface ToastState {
  message: string;
  type: 'success' | 'error' | 'info' | 'warning';
  visible: boolean;
}

/**
 * Hook personalizado para exibir mensagens toast na aplicação
 * @returns Funções e estado para gerenciar toasts
 */
export function useToast() {
  const [toast, setToast] = useState<ToastState>({
    message: '',
    type: 'info',
    visible: false,
  });

  /**
   * Exibe uma mensagem toast
   * @param message Mensagem a ser exibida
   * @param type Tipo de toast (sucesso, erro, informação ou alerta)
   */
  const showToast = (
    message: string, 
    type: 'success' | 'error' | 'info' | 'warning' = 'info'
  ) => {
    setToast({
      message,
      type,
      visible: true,
    });

    // Esconde o toast após 5 segundos
    setTimeout(() => {
      hideToast();
    }, 5000);
  };

  /**
   * Esconde o toast atual
   */
  const hideToast = () => {
    setToast(prev => ({
      ...prev,
      visible: false,
    }));
  };

  return {
    toast,
    showToast,
    hideToast,
  };
}
</file>

<file path="app/lazer/page.tsx">
import { Card, CardHeader, CardTitle, CardContent } from '@/app/components/ui/Card'
import { AtividadesLazer } from '@/app/components/lazer/AtividadesLazer'
import { SugestoesDescanso } from '@/app/components/lazer/SugestoesDescanso'
import { TemporizadorLazer } from '@/app/components/lazer/TemporizadorLazer'

export default function LazerPage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-4">Lazer</h1>
      
      <div className="grid grid-cols-1 gap-6">
        {/* Temporizador de Lazer */}
        <Card>
          <CardHeader>
            <CardTitle>Temporizador de Lazer</CardTitle>
          </CardHeader>
          <CardContent>
            <TemporizadorLazer />
          </CardContent>
        </Card>
        
        {/* Atividades de Lazer */}
        <Card>
          <CardHeader>
            <CardTitle>Atividades de Lazer</CardTitle>
          </CardHeader>
          <CardContent>
            <AtividadesLazer />
          </CardContent>
        </Card>
        
        {/* Sugestões de Descanso */}
        <Card>
          <CardHeader>
            <CardTitle>Sugestões de Descanso</CardTitle>
          </CardHeader>
          <CardContent>
            <SugestoesDescanso />
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="app/lib/utils/errorHandler.js">
/**
 * Manipulador centralizado de erros para a aplicação StayFocus
 */

// Tipos de erros comuns
export const ErrorTypes = {
  NETWORK: 'NETWORK_ERROR',
  API: 'API_ERROR',
  AUTH: 'AUTH_ERROR',
  SYNC: 'SYNC_ERROR',
  VALIDATION: 'VALIDATION_ERROR',
  UNKNOWN: 'UNKNOWN_ERROR'
};

// Classe para padronizar os erros da aplicação
export class AppError extends Error {
  constructor(type, message, originalError = null) {
    super(message);
    this.type = type;
    this.originalError = originalError;
    this.timestamp = new Date().toISOString();
  }
}

/**
 * Categoriza um erro e retorna informações úteis
 */
export function categorizeError(error) {
  // Erros de rede
  if (!navigator.onLine || error.name === 'NetworkError' || 
      error.message?.includes('network') || 
      error.message?.includes('Failed to fetch') ||
      error.code === 'ERR_NETWORK') {
    return {
      type: 'network',
      details: 'Problema de conexão com a internet',
      retryable: true
    };
  }

  // Erros de servidor
  if (error.status >= 500 || 
      error.message?.includes('server') || 
      error.message?.includes('timeout')) {
    return {
      type: 'server',
      details: 'Problema com o servidor',
      retryable: true
    };
  }

  // Erros de autenticação
  if (error.status === 401 || error.status === 403 || 
      error.message?.includes('unauthorized') || 
      error.message?.includes('forbidden')) {
    return {
      type: 'auth',
      details: 'Problema de autenticação',
      retryable: false
    };
  }

  // Erro desconhecido
  return {
    type: 'unknown',
    details: 'Erro desconhecido',
    retryable: false
  };
}

/**
 * Retorna uma mensagem amigável para o usuário com base no erro
 */
export function getUserFriendlyMessage(error, errorType) {
  if (!errorType) {
    const errorInfo = categorizeError(error);
    errorType = errorInfo.type;
  }

  switch (errorType) {
    case 'network':
      return 'Problemas na conexão de internet. Tentando reconectar automaticamente...';
    case 'server':
      return 'Nosso servidor está com problemas. Tente novamente em alguns instantes.';
    case 'auth':
      return 'Sua sessão expirou. Por favor, faça login novamente.';
    default:
      return error.message || 'Ocorreu um erro inesperado. Seus dados estão salvos localmente.';
  }
}

/**
 * Lida com erros de forma global
 */
export function handleError(error, context = {}) {
  const errorInfo = categorizeError(error);
  
  console.error(`[Erro: ${errorInfo.type}]`, error, context);
  
  return {
    ...errorInfo,
    originalError: error,
    context
  };
}
</file>

<file path="app/lib/ai.ts">
import { GoogleGenerativeAI, GenerativeModel } from "@google/generative-ai";
import { PromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { RunnableSequence } from "@langchain/core/runnables";

// Verifica se a chave da API do Gemini está configurada
if (!process.env.GEMINI_API_KEY) {
  console.warn("GEMINI_API_KEY não configurada. Funcionalidades de IA não estarão disponíveis.");
}

// Inicializa o cliente do Gemini
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || "");

// Inicializa o modelo do Gemini 2.0-flash
const geminiModel = genAI.getGenerativeModel({
  model: "gemini-2.0-flash",
  generationConfig: {
    temperature: 0.5,
    topP: 0.8,
    topK: 40
  }
});

// Função auxiliar para adaptar o Gemini 2.0-flash ao formato esperado pelo LangChain
const model = {
  invoke: async (prompt: any) => {
    try {
      // Garantir que o prompt esteja no formato correto para o Gemini 2.0-flash
      const content = typeof prompt.content === 'string' ? prompt.content : prompt.content;
      
      // Chamar o modelo Gemini 2.0-flash
      const result = await geminiModel.generateContent(content);
      
      // Verificar se a resposta foi gerada com sucesso
      if (!result || !result.response) {
        throw new Error("Resposta vazia do modelo Gemini 2.0-flash");
      }
      
      const response = await result.response;
      return response.text();
    } catch (error) {
      console.error("Erro ao chamar o modelo Gemini 2.0-flash:", error);
      throw error;
    }
  }
};

const outputParser = new StringOutputParser();

/**
 * Gera recomendações para priorizar tarefas com base nas necessidades de neurodivergentes
 * @param tarefas Lista de tarefas a serem priorizadas
 * @param contexto Contexto adicional sobre o estado atual do usuário (opcional)
 * @returns Uma lista de tarefas priorizadas com explicações
 */
export async function priorizarTarefas(tarefas: string[], contexto?: string): Promise<string> {
  const template = `
  Como assistente especializado em ajudar pessoas neurodivergentes com TDAH, organize as seguintes tarefas em ordem de prioridade.
  Considere fatores como urgência, importância, tempo necessário e dificuldade.
  
  TAREFAS:
  ${tarefas.map((tarefa, index) => `${index + 1}. ${tarefa}`).join('\n')}
  
  ${contexto ? `CONTEXTO ADICIONAL:\n${contexto}\n` : ''}
  
  Para cada tarefa, forneça:
  1. Nível de prioridade (Alta, Média, Baixa)
  2. Explicação breve do motivo da priorização
  3. Sugestão de quanto tempo dedicar
  4. Uma pequena dica para facilitar o início da tarefa (vencendo a procrastinação)
  
  Apresente o resultado em formato de lista, fácil de ler e estruturado.
  `;

  const promptTemplate = PromptTemplate.fromTemplate(template);
  const chain = RunnableSequence.from([promptTemplate, model, outputParser]);
  
  return chain.invoke({ tarefas, contexto });
}

/**
 * Gera sugestões de rotina diária com base nas necessidades de neurodivergentes
 * @param acordar Horário em que o usuário acorda
 * @param dormir Horário em que o usuário dorme
 * @param preferencias Preferências e necessidades específicas do usuário
 * @returns Uma rotina diária estruturada
 */
export async function gerarRotinaDiaria(acordar: string, dormir: string, preferencias?: string): Promise<string> {
  const template = `
  Como assistente especializado em ajudar pessoas neurodivergentes com TDAH, crie uma rotina diária estruturada.
  
  HORÁRIO DE ACORDAR: ${acordar}
  HORÁRIO DE DORMIR: ${dormir}
  ${preferencias ? `PREFERÊNCIAS E NECESSIDADES:\n${preferencias}\n` : ''}
  
  Crie uma rotina que:
  1. Inclua blocos de tempo específicos para diferentes atividades
  2. Tenha intervalos regulares para descanso
  3. Alterne entre tarefas que exigem foco intenso e tarefas mais leves
  4. Inclua lembretes para necessidades básicas (alimentação, hidratação, etc.)
  5. Reserve tempo para lazer e atividades prazerosas
  
  Apresente a rotina em formato de cronograma, fácil de seguir e com horários específicos.
  Inclua pequenas dicas para transição entre atividades.
  `;

  const promptTemplate = PromptTemplate.fromTemplate(template);
  const chain = RunnableSequence.from([promptTemplate, model, outputParser]);
  
  return chain.invoke({ acordar, dormir, preferencias });
}

/**
 * Analisa as tendências de humor e sugere ações para melhorar bem-estar
 * @param registrosHumor Array de registros de humor com data e nível
 * @returns Análise e sugestões personalizadas
 */
export async function analisarHumor(registrosHumor: Array<{ data: string, nivel: number, notas?: string }>): Promise<string> {
  const template = `
  Como assistente especializado em ajudar pessoas neurodivergentes com TDAH, analise os seguintes registros de humor:
  
  REGISTROS DE HUMOR:
  ${registrosHumor.map(r => `Data: ${r.data}, Nível: ${r.nivel}/10 ${r.notas ? `, Notas: ${r.notas}` : ''}`).join('\n')}
  
  Com base nesses registros:
  1. Identifique padrões ou tendências no humor
  2. Sugira possíveis gatilhos para alterações de humor
  3. Recomende 3-5 estratégias específicas para melhorar o bem-estar emocional
  4. Destaque pontos positivos (se houver)
  
  Considere que pessoas com TDAH podem ter desregulação emocional e responda com sensibilidade.
  Foque em sugestões práticas e implementáveis.
  `;

  const promptTemplate = PromptTemplate.fromTemplate(template);
  const chain = RunnableSequence.from([promptTemplate, model, outputParser]);
  
  return chain.invoke({ registrosHumor: JSON.stringify(registrosHumor) });
}

/**
 * Gera estratégias para melhorar a qualidade do sono
 * @param horasDormidas Média de horas dormidas recentemente
 * @param problemas Problemas específicos de sono relatados
 * @returns Estratégias personalizadas para melhorar o sono
 */
export async function estrategiasSono(horasDormidas: number, problemas?: string[]): Promise<string> {
  const template = `
  Como assistente especializado em ajudar pessoas neurodivergentes com TDAH, sugira estratégias para melhorar o sono.
  
  MÉDIA DE HORAS DORMIDAS: ${horasDormidas} horas por noite
  ${problemas ? `PROBLEMAS ESPECÍFICOS:\n${problemas.map(p => `- ${p}`).join('\n')}\n` : ''}
  
  Pessoas com TDAH frequentemente enfrentam desafios com o sono, incluindo dificuldade para adormecer, sono agitado e manutenção de uma rotina regular.
  
  Forneça:
  1. Uma explicação sobre como o TDAH afeta o sono
  2. 5-7 estratégias específicas e práticas para melhorar a qualidade do sono
  3. Sugestões de rotina noturna que podem ajudar
  4. Quando procurar ajuda profissional
  
  Suas sugestões devem ser específicas para pessoas com TDAH e considerar a dificuldade em manter rotinas.
  `;

  const promptTemplate = PromptTemplate.fromTemplate(template);
  const chain = RunnableSequence.from([promptTemplate, model, outputParser]);
  
  return chain.invoke({ horasDormidas, problemas: problemas ? problemas.join(', ') : '' });
}

/**
 * Gera um plano de estudos adaptado para neurodivergentes
 * @param assunto Assunto a ser estudado
 * @param objetivo Objetivo de aprendizado
 * @param tempoDisponivel Tempo disponível para estudo (em minutos/horas)
 * @returns Um plano de estudos estruturado
 */
export async function planoDeEstudos(assunto: string, objetivo: string, tempoDisponivel: string): Promise<string> {
  const template = `
  Como assistente especializado em ajudar pessoas neurodivergentes com TDAH, crie um plano de estudos para o seguinte:
  
  ASSUNTO: ${assunto}
  OBJETIVO: ${objetivo}
  TEMPO DISPONÍVEL: ${tempoDisponivel}
  
  Crie um plano de estudos que:
  1. Divida o conteúdo em segmentos pequenos e gerenciáveis
  2. Utilize técnicas como Pomodoro (25 minutos de estudo, 5 de pausa)
  3. Incorpore diferentes métodos de aprendizado (visual, auditivo, prático)
  4. Inclua intervalos regulares e microrrotinas
  5. Utilize estratégias para manter o engajamento e evitar a procrastinação
  
  Adicione dicas específicas para manter o foco durante cada sessão de estudo.
  O plano deve ser realista, considerando as dificuldades de atenção relacionadas ao TDAH.
  `;

  const promptTemplate = PromptTemplate.fromTemplate(template);
  const chain = RunnableSequence.from([promptTemplate, model, outputParser]);
  
  return chain.invoke({ assunto, objetivo, tempoDisponivel });
}

/**
 * Analisa padrões de gastos e sugere estratégias para organização financeira
 * @param categorias Categorias de gastos e valores
 * @param renda Renda disponível
 * @returns Análise e recomendações para organização financeira
 */
export async function analiseFinanceira(categorias: Record<string, number>, renda: number): Promise<string> {
  const template = `
  Como assistente especializado em ajudar pessoas neurodivergentes com TDAH, analise os seguintes dados financeiros:
  
  RENDA DISPONÍVEL: R$ ${renda}
  
  CATEGORIAS DE GASTOS:
  ${Object.entries(categorias).map(([categoria, valor]) => `${categoria}: R$ ${valor}`).join('\n')}
  
  Pessoas com TDAH frequentemente enfrentam desafios com gestão financeira, incluindo compras por impulso, dificuldade em manter um orçamento e falta de planejamento de longo prazo.
  
  Forneça:
  1. Uma análise simples dos gastos atuais (percentuais por categoria)
  2. Identificação de possíveis áreas de melhoria
  3. 3-5 estratégias práticas para melhorar a organização financeira, específicas para pessoas com TDAH
  4. Sugestões de ferramentas ou sistemas que podem ajudar a automatizar e simplificar o gerenciamento financeiro
  
  Mantenha suas recomendações simples, práticas e fáceis de implementar.
  `;

  const promptTemplate = PromptTemplate.fromTemplate(template);
  const chain = RunnableSequence.from([promptTemplate, model, outputParser]);
  
  return chain.invoke({ categorias: JSON.stringify(categorias), renda });
}
</file>

<file path="app/lib/contentSummarizer.ts">
export interface SummarizationOptions {
  maxLength?: number; // comprimento máximo do resumo
  complexity?: 'simple' | 'moderate' | 'detailed'; // nível de complexidade
  includeKeyPoints?: boolean; // incluir pontos-chave
  format?: 'text' | 'bullets' | 'steps'; // formato do resumo
}

export class ContentSummarizer {
  /**
   * Simplifica e resume textos para reduzir sobrecarga cognitiva
   */
  async summarizeContent(
    content: string, 
    options: SummarizationOptions = {}
  ): Promise<string> {
    const {
      maxLength = 300,
      complexity = 'moderate',
      includeKeyPoints = true,
      format = 'bullets'
    } = options;
    
    // Aqui implementaríamos a chamada para uma API de IA para resumo
    // Como exemplo, vamos criar uma versão simplificada
    
    // Simulação da lógica de resumo
    let summary = this.createSimplifiedSummary(content, maxLength, complexity);
    
    // Adicionar pontos-chave se solicitado
    if (includeKeyPoints) {
      const keyPoints = this.extractKeyPoints(content);
      
      if (format === 'bullets') {
        summary += "\n\nPontos-chave:\n" + keyPoints.map(point => `• ${point}`).join("\n");
      } else if (format === 'steps') {
        summary += "\n\nPassos principais:\n" + keyPoints.map((point, i) => `${i+1}. ${point}`).join("\n");
      } else {
        summary += " Pontos-chave: " + keyPoints.join(". ");
      }
    }
    
    return summary;
  }
  
  private createSimplifiedSummary(content: string, maxLength: number, complexity: string): string {
    // Versão simplificada - em produção usaríamos uma API NLP
    let sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    
    // Ajustar número de sentenças com base na complexidade
    let sentenceCount = 1;
    switch (complexity) {
      case 'simple': sentenceCount = Math.min(2, sentences.length); break;
      case 'moderate': sentenceCount = Math.min(4, sentences.length); break;
      case 'detailed': sentenceCount = Math.min(6, sentences.length); break;
    }
    
    let simpleSummary = sentences.slice(0, sentenceCount).join(". ") + ".";
    
    // Garantir comprimento máximo
    if (simpleSummary.length > maxLength) {
      simpleSummary = simpleSummary.substring(0, maxLength - 3) + "...";
    }
    
    return simpleSummary;
  }
  
  private extractKeyPoints(content: string): string[] {
    // Versão simplificada - em produção usaríamos uma API NLP
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    
    // Selecionar sentenças que parecem ser pontos-chave
    // (contêm palavras indicativas de importância)
    const keywordPatterns = [
      /importante/i, /principal/i, /essencial/i, /crucial/i, /fundamental/i,
      /chave/i, /destaque/i, /prioridade/i, /relevante/i, /significativo/i
    ];
    
    const keyPoints = sentences.filter(sentence => 
      keywordPatterns.some(pattern => pattern.test(sentence))
    );
    
    // Limitar a 5 pontos no máximo
    return keyPoints.slice(0, 5).map(point => point.trim());
  }
  
  /**
   * Cria uma versão do texto com formatação especial para TDAH
   * (espaçamento, cores, dicas visuais)
   */
  formatForNeurodivergent(content: string): string {
    // Nesta implementação simplificada, retornamos HTML com formatação 
    // que auxilia leitores neurodivergentes
    
    // Dividir em parágrafos
    const paragraphs = content.split(/\n\n+/);
    
    // Criar HTML com formatação especial
    let formattedHtml = '<div class="neurodivergent-friendly-text">';
    
    paragraphs.forEach(para => {
      // Aplicar formatação apenas para parágrafos não vazios
      if (para.trim().length > 0) {
        // Substituir termos importantes com destaque
        let highlightedPara = para
          .replace(/(!important|importante|atenção|atenção|nota|lembre-se|prioridade)/gi, 
                  '<span class="highlight">$1</span>');
                  
        // Adicionar parágrafo com espaçamento adequado
        formattedHtml += `<p class="nd-paragraph">${highlightedPara}</p>`;
      }
    });
    
    formattedHtml += '</div>';
    formattedHtml += `
      <style>
        .neurodivergent-friendly-text {
          line-height: 1.8;
          font-size: 1.1rem;
          max-width: 750px;
          margin: 0 auto;
        }
        .nd-paragraph {
          margin-bottom: 1.5em;
          color: #333;
          background-color: #fff;
          padding: 0.7em;
          border-left: 4px solid #638de3;
          border-radius: 4px;
        }
        .highlight {
          background-color: #ffffd0;
          font-weight: bold;
          padding: 0 3px;
          border-radius: 3px;
        }
      </style>
    `;
    
    return formattedHtml;
  }
}
</file>

<file path="app/lib/dataService.ts">
/**
 * Serviço para exportação e importação de dados do StayFocus
 * Permite que usuários façam backup de seus dados e os restaurem quando necessário
 */

// Importações das stores
import { useFinancasStore } from '../stores/financasStore';
import { useAlimentacaoStore } from '../stores/alimentacaoStore';
import { useAutoconhecimentoStore } from '../stores/autoconhecimentoStore';
import { useHiperfocosStore } from '../stores/hiperfocosStore';
import { usePainelDiaStore } from '../stores/painelDiaStore';
import { usePerfilStore } from '../stores/perfilStore';
import { usePomodoroStore } from '../stores/pomodoroStore';
import { usePrioridadesStore } from '../stores/prioridadesStore';
import { useRegistroEstudosStore } from '../stores/registroEstudosStore';
import { useSonoStore } from '../stores/sonoStore';
import { useAtividadesStore } from '../stores/atividadesStore';
import { useAppStore } from '../store'; // Store global que contém dados de saúde e lazer

/**
 * Exporta todos os dados do aplicativo para um arquivo JSON
 * @returns Objeto com informação de sucesso e mensagem
 */
export const exportarDados = (): { sucesso: boolean; mensagem?: string; erro?: string } => {
  try {
    // Coletar todos os dados dos stores
    const financas = useFinancasStore.getState();
    const alimentacao = useAlimentacaoStore.getState();
    const autoconhecimento = useAutoconhecimentoStore.getState();
    const hiperfocos = useHiperfocosStore.getState();
    const painelDia = usePainelDiaStore.getState();
    const perfil = usePerfilStore.getState();
    const pomodoro = usePomodoroStore.getState();
    const prioridades = usePrioridadesStore.getState();
    const registroEstudos = useRegistroEstudosStore.getState();
    const sono = useSonoStore.getState();
    const atividades = useAtividadesStore.getState();
    const appGlobal = useAppStore.getState(); // Obter dados da store global
    
    // Formato unificado com metadados
    const dadosExportados = {
      versao: '1.0',
      timestamp: new Date().toISOString(),
      dados: {
        financas: limparFuncoesDoObjeto(financas),
        alimentacao: limparFuncoesDoObjeto(alimentacao),
        autoconhecimento: limparFuncoesDoObjeto(autoconhecimento),
        hiperfocos: limparFuncoesDoObjeto(hiperfocos),
        painelDia: limparFuncoesDoObjeto(painelDia),
        perfil: limparFuncoesDoObjeto(perfil),
        pomodoro: limparFuncoesDoObjeto(pomodoro),
        prioridades: limparFuncoesDoObjeto(prioridades),
        registroEstudos: limparFuncoesDoObjeto(registroEstudos),
        sono: limparFuncoesDoObjeto(sono),
        atividades: limparFuncoesDoObjeto(atividades),
        appGlobal: limparFuncoesDoObjeto(appGlobal), // Adicionar dados globais que incluem saúde e lazer
      }
    };
    
    // Converter para JSON e criar arquivo para download
    const jsonString = JSON.stringify(dadosExportados, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    // Criar link de download com nome de arquivo padronizado
    const dataFormatada = new Date().toISOString().split('T')[0];
    const link = document.createElement('a');
    link.href = url;
    link.download = `stayfocus_backup_${dataFormatada}.json`;
    link.click();
    
    URL.revokeObjectURL(url);
    
    return {
      sucesso: true,
      mensagem: 'Dados exportados com sucesso'
    };
  } catch (error: unknown) {
    console.error('Erro ao exportar dados:', error);
    
    let mensagemErro = 'Erro desconhecido';
    if (error instanceof Error) {
      mensagemErro = error.message;
    }
    
    return {
      sucesso: false,
      erro: `Erro ao exportar dados: ${mensagemErro}`
    };
  }
};

/**
 * Limpa as funções de um objeto para exportação JSON
 * @param obj Objeto a ser limpo
 * @returns Objeto sem funções
 */
const limparFuncoesDoObjeto = (obj: Record<string, any>): Record<string, any> => {
  // Criar cópia do objeto
  const resultado = {...obj};
  
  // Remover todas as funções pois não podem ser serializadas em JSON
  Object.keys(resultado).forEach(key => {
    if (typeof resultado[key] === 'function') {
      delete resultado[key];
    }
  });
  
  return resultado;
};

/**
 * Valida a estrutura de dados importados
 * @param dados Dados a serem validados
 * @returns Objeto com informação de validade e possível erro
 */
export const validarDadosImportados = (dados: any): { valido: boolean; erro?: string } => {
  // Verificar estrutura básica
  if (!dados?.versao || !dados?.timestamp || !dados?.dados) {
    return { valido: false, erro: 'Formato de arquivo inválido' };
  }
  
  // Verificar versão compatível
  if (dados.versao !== '1.0') {
    return { 
      valido: false, 
      erro: `Versão incompatível: ${dados.versao}. Esperada: 1.0` 
    };
  }
  
  // Verificar presença de pelo menos um módulo de dados
  if (Object.keys(dados.dados).length === 0) {
    return { valido: false, erro: 'Arquivo de backup vazio' };
  }
  
  return { valido: true };
};

/**
 * Importa dados de um arquivo JSON para o aplicativo
 * @param arquivo Arquivo a ser importado
 * @returns Objeto com informação de sucesso e mensagem
 */
export const importarDados = async (arquivo: File): Promise<{ sucesso: boolean; mensagem?: string; timestamp?: string; erro?: string }> => {
  try {
    // Ler arquivo
    const texto = await arquivo.text();
    const dados = JSON.parse(texto);
    
    // Validar dados
    const validacao = validarDadosImportados(dados);
    if (!validacao.valido) {
      return { sucesso: false, erro: validacao.erro };
    }
    
    // Aplicar dados aos stores
    if (dados.dados.financas) {
      const financas = dados.dados.financas;
      useFinancasStore.setState(state => ({
        ...state,
        ...financas
      }));
    }
    
    if (dados.dados.alimentacao) {
      const alimentacao = dados.dados.alimentacao;
      useAlimentacaoStore.setState(state => ({
        ...state,
        ...alimentacao
      }));
    }
    
    if (dados.dados.autoconhecimento) {
      const autoconhecimento = dados.dados.autoconhecimento;
      useAutoconhecimentoStore.setState(state => ({
        ...state,
        ...autoconhecimento
      }));
    }
    
    if (dados.dados.hiperfocos) {
      const hiperfocos = dados.dados.hiperfocos;
      useHiperfocosStore.setState(state => ({
        ...state,
        ...hiperfocos
      }));
    }
    
    if (dados.dados.painelDia) {
      const painelDia = dados.dados.painelDia;
      usePainelDiaStore.setState(state => ({
        ...state,
        ...painelDia
      }));
    }
    
    if (dados.dados.perfil) {
      const perfil = dados.dados.perfil;
      usePerfilStore.setState(state => ({
        ...state,
        ...perfil
      }));
    }
    
    if (dados.dados.pomodoro) {
      const pomodoro = dados.dados.pomodoro;
      usePomodoroStore.setState(state => ({
        ...state,
        ...pomodoro
      }));
    }
    
    if (dados.dados.prioridades) {
      const prioridades = dados.dados.prioridades;
      usePrioridadesStore.setState(state => ({
        ...state,
        ...prioridades
      }));
    }
    
    if (dados.dados.registroEstudos) {
      const registroEstudos = dados.dados.registroEstudos;
      useRegistroEstudosStore.setState(state => ({
        ...state,
        ...registroEstudos
      }));
    }
    
    if (dados.dados.sono) {
      const sono = dados.dados.sono;
      useSonoStore.setState(state => ({
        ...state,
        ...sono
      }));
    }
    
    if (dados.dados.atividades) {
      const atividades = dados.dados.atividades;
      useAtividadesStore.setState(state => ({
        ...state,
        ...atividades
      }));
    }
    
    if (dados.dados.appGlobal) {
      const appGlobal = dados.dados.appGlobal;
      useAppStore.setState(state => ({
        ...state,
        ...appGlobal
      }));
    }
    
    return { 
      sucesso: true, 
      mensagem: 'Dados importados com sucesso',
      timestamp: dados.timestamp
    };
  } catch (error: unknown) {
    console.error('Erro ao importar dados:', error);
    
    let mensagemErro = 'Erro desconhecido';
    if (error instanceof Error) {
      mensagemErro = error.message;
    }
    
    return { 
      sucesso: false, 
      erro: `Erro ao importar dados: ${mensagemErro}` 
    };
  }
};
</file>

<file path="app/lib/README.md">
# Integração com IA - Gemini 2.0-flash

## Visão Geral

Este diretório contém a integração com o modelo Gemini 2.0-flash do Google, que é usado para fornecer funcionalidades de IA para usuários neurodivergentes no aplicativo.

## Arquivos Principais

- `ai.ts`: Contém a configuração do modelo Gemini 2.0-flash e funções para diferentes casos de uso.

## Modelo Utilizado

O aplicativo utiliza o modelo `gemini-2.0-flash` do Google, que oferece:

- Respostas mais rápidas que o modelo anterior (gemini-pro)
- Melhor qualidade de resposta para casos de uso específicos
- Otimização para prompts de tamanho médio

## Configuração

Para que a integração funcione corretamente, é necessário configurar a variável de ambiente `GEMINI_API_KEY` com uma chave de API válida do Google AI Studio.

## Funções Disponíveis

O arquivo `ai.ts` exporta as seguintes funções:

- `priorizarTarefas`: Ajuda a priorizar tarefas considerando necessidades de pessoas com TDAH
- `gerarRotinaDiaria`: Cria uma rotina diária estruturada
- `analisarHumor`: Analisa registros de humor e sugere estratégias
- `estrategiasSono`: Fornece estratégias para melhorar a qualidade do sono
- `planoDeEstudos`: Gera um plano de estudos adaptado para neurodivergentes
- `analiseFinanceira`: Analisa padrões de gastos e sugere estratégias financeiras

## Uso

Importe as funções necessárias do arquivo `ai.ts` e utilize-as em seus componentes:

```typescript
import { priorizarTarefas } from '@/app/lib/ai';

// Exemplo de uso
const resultado = await priorizarTarefas(['Tarefa 1', 'Tarefa 2'], 'Contexto adicional');
```

## Manutenção

Ao atualizar o modelo ou adicionar novas funcionalidades, certifique-se de:

1. Testar todas as funções existentes para garantir compatibilidade
2. Atualizar a documentação com novas funções ou parâmetros
3. Ajustar os parâmetros de geração (temperatura, topP, topK) conforme necessário para cada caso de uso
</file>

<file path="app/lib/supabase.ts">
import { createPagesBrowserClient } from '@supabase/auth-helpers-nextjs';
import { Database } from '../types/supabase';
import { SupabaseClient } from '@supabase/supabase-js';

let supabaseClient: SupabaseClient<Database> | null = null;

export const createClient = () => {
  if (!supabaseClient) {
    supabaseClient = createPagesBrowserClient<Database>();
  }
  return supabaseClient;
};
</file>

<file path="app/lib/supabaseExport.ts">
/**
 * Serviço para exportação de dados do Supabase para formatos CSV e PDF
 * Permite que usuários façam backup e compartilhem seus dados com profissionais de saúde
 */

import { createClient } from '@/app/lib/supabase';
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import { User } from '@supabase/supabase-js';

// Tipos de módulos que podem ser exportados
export type ModuleType = 'priorities' | 'sleep_records' | 'mood_records' | 'medications';

// Opções de formato para exportação
export type ExportFormat = 'csv' | 'pdf';

// Opções para exportação
export interface ExportOptions {
  startDate?: Date;
  endDate?: Date;
  modules: ModuleType[];
  format: ExportFormat;
}

// Resultado da exportação
export interface ExportResult {
  success: boolean;
  message?: string;
  error?: string;
  filename?: string;
}

/**
 * Exporta dados do Supabase para o formato selecionado
 * @param user Usuário atual autenticado
 * @param options Opções de exportação (formato, datas, módulos)
 * @returns Resultado da exportação
 */
export const exportSupabaseData = async (
  user: User | null,
  options: ExportOptions
): Promise<ExportResult> => {
  if (!user) {
    return {
      success: false,
      error: 'Usuário não autenticado',
    };
  }

  try {
    const supabase = createClient();
    const today = new Date();
    const formattedDate = today.toISOString().split('T')[0];
    const data: Record<string, any[]> = {};

    // Buscar dados de cada módulo selecionado
    for (const module of options.modules) {
      let query = supabase.from(module).select('*').eq('user_id', user.id);

      // Aplicar filtros de data se forem fornecidos
      if (options.startDate) {
        const dateField = getDateFieldForModule(module);
        query = query.gte(dateField, options.startDate.toISOString());
      }

      if (options.endDate) {
        const dateField = getDateFieldForModule(module);
        query = query.lte(dateField, options.endDate.toISOString());
      }

      // Executar query
      const { data: moduleData, error } = await query;

      if (error) {
        console.error(`Erro ao buscar dados de ${module}:`, error);
        continue;
      }

      data[module] = moduleData || [];
    }

    // Gerar o arquivo no formato selecionado
    if (options.format === 'csv') {
      return generateCSV(data, formattedDate);
    } else if (options.format === 'pdf') {
      return generatePDF(data, formattedDate, user);
    }

    return {
      success: false,
      error: 'Formato de exportação não suportado',
    };
  } catch (error) {
    console.error('Erro ao exportar dados:', error);
    const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';
    
    return {
      success: false,
      error: `Erro ao exportar dados: ${errorMessage}`,
    };
  }
};

/**
 * Obtém o campo de data para cada tipo de módulo
 * @param module Tipo do módulo
 * @returns Nome do campo de data
 */
const getDateFieldForModule = (module: ModuleType): string => {
  switch (module) {
    case 'priorities':
      return 'created_at';
    case 'sleep_records':
      return 'start_time';
    case 'mood_records':
      return 'record_date';
    case 'medications':
      return 'created_at';
    default:
      return 'created_at';
  }
};

/**
 * Gera um arquivo CSV com os dados exportados
 * @param data Dados dos módulos
 * @param formattedDate Data formatada para o nome do arquivo
 * @returns Resultado da exportação
 */
const generateCSV = (data: Record<string, any[]>, formattedDate: string): ExportResult => {
  try {
    const modulesWithData = Object.keys(data).filter(module => data[module].length > 0);
    
    if (modulesWithData.length === 0) {
      return {
        success: false,
        error: 'Nenhum dado encontrado para exportar',
      };
    }

    // Gerar um CSV para cada módulo
    const csvFiles: Blob[] = [];
    
    for (const module of modulesWithData) {
      if (data[module].length > 0) {
        const headers = Object.keys(data[module][0]).join(',');
        const rows = data[module].map(item => 
          Object.values(item).map(value => 
            typeof value === 'object' ? JSON.stringify(value) : value
          ).join(',')
        ).join('\n');
        
        const csvContent = `${headers}\n${rows}`;
        csvFiles.push(new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }));
      }
    }

    // Se há apenas um módulo, baixamos diretamente
    if (csvFiles.length === 1) {
      const url = URL.createObjectURL(csvFiles[0]);
      const filename = `myneuroapp_${modulesWithData[0]}_${formattedDate}.csv`;
      
      triggerDownload(url, filename);
      
      return {
        success: true,
        message: 'Dados exportados com sucesso',
        filename,
      };
    } 
    // Se há múltiplos módulos, criamos um arquivo zip (simplificado para este exemplo)
    else {
      // Em uma implementação real, usaríamos uma biblioteca como JSZip para criar um arquivo .zip
      // Para este exemplo, baixaremos apenas o primeiro arquivo
      const url = URL.createObjectURL(csvFiles[0]);
      const filename = `myneuroapp_${modulesWithData[0]}_${formattedDate}.csv`;
      
      triggerDownload(url, filename);
      
      return {
        success: true,
        message: `Exportado primeiro módulo (${modulesWithData[0]}). Em uma implementação completa, todos os módulos seriam compactados em um arquivo zip.`,
        filename,
      };
    }
  } catch (error) {
    console.error('Erro ao gerar CSV:', error);
    const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';
    
    return {
      success: false,
      error: `Erro ao gerar CSV: ${errorMessage}`,
    };
  }
};

/**
 * Gera um arquivo PDF com os dados exportados
 * @param data Dados dos módulos
 * @param formattedDate Data formatada para o nome do arquivo
 * @param user Usuário atual
 * @returns Resultado da exportação
 */
const generatePDF = (data: Record<string, any[]>, formattedDate: string, user: User): ExportResult => {
  try {
    const modulesWithData = Object.keys(data).filter(module => data[module].length > 0);
    
    if (modulesWithData.length === 0) {
      return {
        success: false,
        error: 'Nenhum dado encontrado para exportar',
      };
    }

    // Criar documento PDF
    const doc = new jsPDF();
    
    // Adicionar título e data
    doc.setFontSize(16);
    doc.text('MyNeuroApp - Relatório de Dados', 14, 15);
    doc.setFontSize(10);
    doc.text(`Gerado em: ${new Date().toLocaleString('pt-BR')}`, 14, 22);
    doc.text(`Usuário: ${user.email}`, 14, 28);
    doc.line(14, 30, 196, 30); // Linha separadora
    
    let yPosition = 35;
    
    // Adicionar dados de cada módulo
    for (const module of modulesWithData) {
      const moduleData = data[module];
      
      if (moduleData.length === 0) continue;
      
      // Adicionar título do módulo
      yPosition += 10;
      doc.setFontSize(14);
      doc.text(getModuleTitle(module), 14, yPosition);
      yPosition += 5;
      
      // Configurar tabela com os dados
      const headers = Object.keys(moduleData[0]).map(key => ({
        header: formatHeaderName(key),
        dataKey: key
      }));
      
      // @ts-ignore - usando jspdf-autotable
      doc.autoTable({
        startY: yPosition,
        columns: headers,
        body: moduleData.map(item => {
          // Formatar valores de objeto para string
          const formattedItem: Record<string, any> = {};
          
          Object.entries(item).forEach(([key, value]) => {
            if (typeof value === 'object' && value !== null) {
              formattedItem[key] = JSON.stringify(value);
            } else {
              formattedItem[key] = value;
            }
          });
          
          return formattedItem;
        }),
        didDrawPage: (data: any) => {
          // Atualizar posição Y após desenhar a tabela
          yPosition = data.cursor.y + 15;
          
          // Adicionar nova página se necessário
          if (yPosition > doc.internal.pageSize.height - 20) {
            doc.addPage();
            yPosition = 15;
          }
        }
      });
    }
    
    // Salvar o PDF
    const filename = `myneuroapp_relatorio_${formattedDate}.pdf`;
    doc.save(filename);
    
    return {
      success: true,
      message: 'PDF gerado com sucesso',
      filename,
    };
  } catch (error) {
    console.error('Erro ao gerar PDF:', error);
    const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';
    
    return {
      success: false,
      error: `Erro ao gerar PDF: ${errorMessage}`,
    };
  }
};

/**
 * Obtém o título formatado para cada tipo de módulo
 * @param module Tipo do módulo
 * @returns Título formatado
 */
const getModuleTitle = (module: string): string => {
  switch (module) {
    case 'priorities':
      return 'Prioridades';
    case 'sleep_records':
      return 'Registros de Sono';
    case 'mood_records':
      return 'Registros de Humor';
    case 'medications':
      return 'Medicamentos';
    default:
      return module.charAt(0).toUpperCase() + module.slice(1).replace('_', ' ');
  }
};

/**
 * Formata nomes de cabeçalho para exibição
 * @param header Nome do cabeçalho
 * @returns Nome formatado
 */
const formatHeaderName = (header: string): string => {
  return header
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};

/**
 * Dispara o download de um arquivo
 * @param url URL do arquivo
 * @param filename Nome do arquivo
 */
const triggerDownload = (url: string, filename: string): void => {
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
  
  // Liberar URL
  setTimeout(() => {
    URL.revokeObjectURL(url);
  }, 100);
};
</file>

<file path="app/lib/testHelper.ts">
import { createClient } from './supabase';
import { Database } from '../types/supabase';

/**
 * Helper para testes de integração com o Supabase
 */
export class TestHelper {
  private supabase;

  constructor() {
    this.supabase = createClient();
  }

  /**
   * Obter status de sincronização para um usuário
   */
  async getSyncStatus(userId: string): Promise<any> {
    const { data, error } = await this.supabase
      .rpc('test_sync_status', { test_user_id: userId });

    if (error) throw new Error(`Erro ao obter status de sincronização: ${error.message}`);
    return data;
  }

  /**
   * Simular alterações feitas offline
   */
  async simulateOfflineChanges(userId: string, deviceId: string): Promise<any> {
    const { data, error } = await this.supabase
      .rpc('simulate_offline_changes', { 
        test_user_id: userId,
        device_id: deviceId
      });

    if (error) throw new Error(`Erro ao simular alterações offline: ${error.message}`);
    return data;
  }

  /**
   * Simular conflito de sincronização
   */
  async simulateSyncConflict(userId: string, itemId: string): Promise<any> {
    const { data, error } = await this.supabase
      .rpc('simulate_sync_conflict', { 
        test_user_id: userId,
        item_id: itemId
      });

    if (error) throw new Error(`Erro ao simular conflito: ${error.message}`);
    return data;
  }

  /**
   * Resolver conflitos de sincronização
   */
  async resolveConflicts(userId: string): Promise<any> {
    const { data, error } = await this.supabase
      .rpc('test_resolve_conflicts', { test_user_id: userId });

    if (error) throw new Error(`Erro ao resolver conflitos: ${error.message}`);
    return data;
  }

  /**
   * Gerar relatório de testes
   */
  async generateTestReport(userId: string): Promise<any> {
    const { data, error } = await this.supabase
      .rpc('generate_test_report', { test_user_id: userId });

    if (error) throw new Error(`Erro ao gerar relatório: ${error.message}`);
    return data;
  }

  /**
   * Obter dados de um usuário de teste
   */
  async getTestUserData(userId: string): Promise<any> {
    const results: any = {};

    // Buscar prioridades
    const { data: priorities, error: prioritiesError } = await this.supabase
      .from('priorities')
      .select('*')
      .eq('user_id', userId);
    
    if (prioritiesError) throw new Error(`Erro ao buscar prioridades: ${prioritiesError.message}`);
    results.priorities = priorities;

    // Buscar registros de sono
    const { data: sleepRecords, error: sleepError } = await this.supabase
      .from('sleep_records')
      .select('*')
      .eq('user_id', userId);
    
    if (sleepError) throw new Error(`Erro ao buscar registros de sono: ${sleepError.message}`);
    results.sleepRecords = sleepRecords;

    // Buscar medicações
    const { data: medications, error: medError } = await this.supabase
      .from('medications')
      .select('*')
      .eq('user_id', userId);
    
    if (medError) throw new Error(`Erro ao buscar medicações: ${medError.message}`);
    results.medications = medications;

    return results;
  }

  /**
   * Limpar dados de teste
   */
  async clearTestData(): Promise<any> {
    const { data, error } = await this.supabase
      .rpc('clear_test_data');

    if (error) throw new Error(`Erro ao limpar dados de teste: ${error.message}`);
    return { success: true, message: 'Dados de teste removidos com sucesso' };
  }

  /**
   * Login com usuário de teste
   * Observação: Esta função é apenas para testes, não use em produção
   */
  async loginWithTestUser(email: string, password: string): Promise<any> {
    const { data, error } = await this.supabase.auth.signInWithPassword({
      email,
      password
    });

    if (error) throw new Error(`Erro ao fazer login com usuário de teste: ${error.message}`);
    return data;
  }

  /**
   * Testar a sincronização entre dispositivos
   */
  async testSyncBetweenDevices(userId: string, numDevices: number = 2): Promise<any> {
    const results: any = { devices: [] };
    
    // Simular alterações em cada dispositivo
    for (let i = 1; i <= numDevices; i++) {
      const deviceId = `test-device-${i}`;
      const deviceChanges = await this.simulateOfflineChanges(userId, deviceId);
      results.devices.push({
        deviceId,
        changes: deviceChanges
      });
    }
    
    // Verificar status após simulações
    results.syncStatus = await this.getSyncStatus(userId);
    
    // Simular um conflito entre os primeiros dois dispositivos
    if (numDevices >= 2) {
      const firstPriorityId = results.devices[0].changes.created_items.priority_id;
      results.conflict = await this.simulateSyncConflict(userId, firstPriorityId);
      
      // Resolver conflitos
      results.resolution = await this.resolveConflicts(userId);
    }
    
    // Gerar relatório final
    results.finalReport = await this.generateTestReport(userId);
    
    return results;
  }
}
</file>

<file path="app/lib/utils.ts">
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

/**
 * Mescla classes do Tailwind de forma eficiente, evitando conflitos
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="app/perfil/ajuda/page.tsx">
'use client';

import { ArrowLeft, HelpCircle, FileDown, FileUp, AlertTriangle } from 'lucide-react';
import Link from 'next/link';

export default function AjudaImportacaoExportacao() {
  return (
    <div className="max-w-4xl mx-auto p-6">
      <Link 
        href="/perfil" 
        className="flex items-center text-blue-600 dark:text-blue-400 mb-6 hover:underline"
      >
        <ArrowLeft size={16} className="mr-1" />
        Voltar para Perfil
      </Link>
      
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-8">
        <div className="flex items-center mb-4">
          <HelpCircle className="text-blue-600 dark:text-blue-400 mr-2" size={24} />
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Ajuda: Importação e Exportação de Dados
          </h1>
        </div>
        
        <div className="prose dark:prose-invert max-w-none">
          <p>
            O StayFocus permite que você faça backup dos seus dados e os restaure quando necessário.
            Isso é útil para transferir seus dados entre dispositivos ou para garantir que você não perca
            suas informações importantes.
          </p>
          
          <h2 className="flex items-center mt-6 mb-3">
            <FileDown className="mr-2 text-green-600 dark:text-green-400" size={20} />
            Exportação de Dados
          </h2>
          
          <p>
            A exportação de dados cria um arquivo JSON contendo todas as suas informações do StayFocus.
            Este arquivo pode ser armazenado com segurança em seu computador ou serviço de armazenamento na nuvem.
          </p>
          
          <h3>Como exportar seus dados:</h3>
          
          <ol className="list-decimal list-inside space-y-2 pl-4">
            <li>Acesse a página de Perfil</li>
            <li>Localize a seção "Importar/Exportar Dados"</li>
            <li>Clique no botão "Exportar Dados"</li>
            <li>Um arquivo chamado <code>stayfocus_backup_DATA.json</code> será baixado automaticamente</li>
            <li>Guarde este arquivo em um local seguro</li>
          </ol>
          
          <p className="text-sm bg-blue-50 dark:bg-blue-900/20 p-3 rounded-md border border-blue-100 dark:border-blue-800 my-4">
            <strong>Dica:</strong> Recomendamos fazer backup dos seus dados regularmente, especialmente antes de fazer
            alterações significativas no seu perfil ou configurações.
          </p>
          
          <h2 className="flex items-center mt-6 mb-3">
            <FileUp className="mr-2 text-amber-600 dark:text-amber-400" size={20} />
            Importação de Dados
          </h2>
          
          <p>
            A importação de dados permite restaurar informações previamente exportadas.
            Ao importar dados, todas as informações atuais serão substituídas pelo conteúdo do arquivo de backup.
          </p>
          
          <h3>Como importar seus dados:</h3>
          
          <ol className="list-decimal list-inside space-y-2 pl-4">
            <li>Acesse a página de Perfil</li>
            <li>Localize a seção "Importar/Exportar Dados"</li>
            <li>Clique no botão "Importar Dados"</li>
            <li>Selecione o arquivo de backup previamente exportado</li>
            <li>Confirme a importação quando solicitado</li>
            <li>Aguarde a mensagem de confirmação</li>
          </ol>
          
          <div className="flex items-start gap-3 bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-md border border-yellow-100 dark:border-yellow-800 my-4">
            <AlertTriangle className="text-yellow-600 dark:text-yellow-400 flex-shrink-0 mt-1" size={20} />
            <div>
              <p className="font-medium text-yellow-800 dark:text-yellow-200">Importante:</p>
              <p className="text-sm text-yellow-700 dark:text-yellow-300">
                A importação de dados <strong>substituirá</strong> todas as suas informações atuais.
                Este processo não pode ser desfeito, então certifique-se de exportar seus dados atuais
                antes de importar um backup, caso queira preservar as informações atuais.
              </p>
            </div>
          </div>
          
          <h2 className="mt-6 mb-3">Perguntas Frequentes</h2>
          
          <div className="space-y-4">
            <div>
              <h3 className="font-medium text-gray-900 dark:text-white">O que acontece com meus dados atuais quando faço uma importação?</h3>
              <p className="text-gray-600 dark:text-gray-300">
                Seus dados atuais serão completamente substituídos pelos dados do arquivo importado.
                Recomendamos fazer um backup dos seus dados atuais antes de importar novos dados.
              </p>
            </div>
            
            <div>
              <h3 className="font-medium text-gray-900 dark:text-white">Posso transferir meus dados entre dispositivos diferentes?</h3>
              <p className="text-gray-600 dark:text-gray-300">
                Sim! Exporte seus dados no dispositivo de origem, transfira o arquivo para o dispositivo
                de destino e então importe os dados nesse novo dispositivo.
              </p>
            </div>
            
            <div>
              <h3 className="font-medium text-gray-900 dark:text-white">É seguro armazenar o arquivo de backup?</h3>
              <p className="text-gray-600 dark:text-gray-300">
                O arquivo de backup contém todas as suas informações do StayFocus. Recomendamos
                armazená-lo em um local seguro e não compartilhá-lo com terceiros, a menos que
                você esteja ciente de que todas as suas informações pessoais estão contidas nele.
              </p>
            </div>
            
            <div>
              <h3 className="font-medium text-gray-900 dark:text-white">Meu backup é compatível com versões futuras do StayFocus?</h3>
              <p className="text-gray-600 dark:text-gray-300">
                Fazemos o possível para manter a compatibilidade com versões anteriores, mas
                ocasionalmente alterações estruturais podem ocorrer. Se encontrar problemas ao
                importar um backup antigo, entre em contato com o suporte.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/perfil/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { usePerfilStore } from '../stores/perfilStore'
import { InformacoesPessoais } from '../components/perfil/InformacoesPessoais'
import { MetasDiarias } from '../components/perfil/MetasDiarias'
import { PreferenciasVisuais } from '../components/perfil/PreferenciasVisuais'
import { DataMigration } from '../components/perfil/DataMigration'
import { ExportarImportarDados } from '../components/ExportarImportarDados'
import { RefreshCw, User } from 'lucide-react'
import { useAuthContext } from '../context/AuthContext'
import { LoadingIndicator } from '../components/ui/LoadingIndicator'

export default function PerfilPage() {
  const { resetarPerfil, preferenciasVisuais } = usePerfilStore()
  const { user, loading } = useAuthContext()
  const [resetConfirmOpen, setResetConfirmOpen] = useState(false)
  
  // Aplicar classes de acessibilidade ao carregar a página
  useEffect(() => {
    if (preferenciasVisuais.altoContraste) {
      document.documentElement.classList.add('alto-contraste')
    }
    
    if (preferenciasVisuais.reducaoEstimulos) {
      document.documentElement.classList.add('reducao-estimulos')
    }
    
    if (preferenciasVisuais.textoGrande) {
      document.documentElement.classList.add('texto-grande')
    }
    
    // Cleanup
    return () => {
      document.documentElement.classList.remove('alto-contraste', 'reducao-estimulos', 'texto-grande')
    }
  }, [preferenciasVisuais])
  
  const confirmarReset = () => {
    resetarPerfil()
    setResetConfirmOpen(false)
  }

  // Mostrar indicador de carregamento enquanto verifica autenticação
  if (loading) {
    return (
      <div className="container max-w-4xl mx-auto px-4 py-8 flex justify-center items-center min-h-[50vh]">
        <LoadingIndicator size="large" text="Carregando perfil..." />
      </div>
    )
  }

  return (
    <div className="container max-w-4xl mx-auto px-4 py-8">
      <div className="flex items-center justify-between mb-8">
        <div className="flex items-center">
          <div className="h-12 w-12 rounded-full bg-perfil-primary flex items-center justify-center text-white text-xl font-bold mr-4">
            <User className="h-6 w-6" />
          </div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            {user ? `Perfil - ${user.email}` : 'Informações Pessoais'}
          </h1>
        </div>
        
        <button
          onClick={() => setResetConfirmOpen(true)}
          className="text-sm flex items-center text-gray-500 hover:text-perfil-primary dark:text-gray-400 dark:hover:text-perfil-secondary focus:outline-none"
          aria-label="Redefinir configurações"
        >
          <RefreshCw className="h-4 w-4 mr-1" />
          Redefinir
        </button>
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2 space-y-6">
          <InformacoesPessoais />
          <MetasDiarias />
          
          {/* Componente de migração de dados apenas para usuários autenticados */}
          {user && <DataMigration />}
        </div>
        
        <div className="space-y-6">
          <PreferenciasVisuais />
          <ExportarImportarDados />
        </div>
      </div>
      
      {/* Modal de confirmação */}
      {resetConfirmOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-lg max-w-md w-full p-6 shadow-xl">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
              Redefinir configurações?
            </h3>
            <p className="text-gray-600 dark:text-gray-300 mb-6">
              Todas as suas preferências, metas e configurações serão restauradas para os valores padrão.
              Esta ação não pode ser desfeita.
            </p>
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => setResetConfirmOpen(false)}
                className="px-4 py-2 text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none"
              >
                Cancelar
              </button>
              <button
                onClick={confirmarReset}
                className="px-4 py-2 text-white bg-red-500 rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500"
              >
                Redefinir
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/roadmap/page.tsx">
'use client'

import React from 'react'
import { Container } from '@/app/components/ui/Container'
import { Card } from '@/app/components/ui/Card'
import { Section } from '@/app/components/ui/Section'
import { CheckCircle2 } from 'lucide-react'

export default function RoadmapPage() {
  return (
    <Container>
      <Section title="Roadmap do StayFocus">
        <Card className="mb-6">
          <h2 className="text-xl font-bold text-blue-600 dark:text-blue-400 mb-4">💭 O conceito</h2>
          <p className="mb-4">
            O StayFocus surge da minha própria experiência com TDAH e da observação de que precisamos de ferramentas que funcionem com nossos cérebros, não contra eles. Cada recurso foi pensado para ser:
          </p>
          <ul className="list-disc pl-6 space-y-2 mb-4">
            <li>Simples e focado - Sem distrações ou complexidades desnecessárias</li>
            <li>Visualmente claro - Feedback visual imediato para todas as ações</li>
            <li>Adaptável às suas necessidades - Reconhecendo que cada cérebro neurodivergente é único</li>
            <li>Persistente - Porque sabemos como é fácil esquecer coisas importantes</li>
          </ul>
        </Card>

        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-green-600 dark:text-green-400 mb-4">🛠️ O que já temos (Sprint 1)</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">📱 Página Inicial</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Painel do Dia - Visualize seu dia em um único lugar</li>
            <li>Lista de Prioridades - Foque no que realmente importa</li>
            <li>Lembretes de Pausas - Porque nossos cérebros precisam descansar!</li>
            <li>Checklist de Medicamentos - Organização por tipo para facilitar o acompanhamento</li>
          </ul>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">🥗 Alimentação</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Planejador de Refeições - Facilite a decisão do que comer</li>
            <li>Registro de Refeições - Acompanhe seus padrões alimentares</li>
            <li>Lembrete de Hidratação - Para não esquecer de beber água (sim, acontece!)</li>
          </ul>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">📚 Estudos</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Temporizador Pomodoro - Técnica adaptada para cérebros neurodivergentes</li>
            <li>Registro de Estudos - Acompanhe seu progresso e celebre pequenas vitórias</li>
          </ul>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">❤️ Saúde</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Registro de Medicamentos - Com sistema de intervalo entre doses para evitar superdosagem acidental</li>
            <li>Monitoramento de Humor - Identifique padrões e gatilhos emocionais</li>
          </ul>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">🎮 Lazer</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Temporizador de Lazer - Para garantir que você também se divirta</li>
            <li>Atividades de Lazer - Registre e acompanhe suas atividades favoritas</li>
            <li>Sugestões de Descanso - Quando seu cérebro precisa de uma pausa, mas você não sabe o que fazer</li>
          </ul>
        </Card>

        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-indigo-600 dark:text-indigo-400 mb-4">⚙️ Sprint 2</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">😴 Gestão do Sono</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Registro de Sono - Acompanhe os horários de dormir e acordar</li>
            <li>Visualizador Semanal - Veja padrões de sono ao longo do tempo</li>
            <li>Lembretes Personalizáveis - Configure alertas para criar uma rotina de sono</li>
            <li>Metas de Sono - Defina objetivos realistas para melhorar sua qualidade de sono</li>
          </ul>
        </Card>

        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-purple-600 dark:text-purple-400 mb-4">⚙️ Sprint 3</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">🧠 Notas de Autoconhecimento</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Seções Organizadas - "Quem sou", "Meus porquês" e "Meus padrões"</li>
            <li>Modo Refúgio - Interface simplificada para momentos de crise</li>
            <li>Sistema de Tags - Categorize suas anotações para encontrá-las facilmente</li>
            <li>Âncoras Visuais - Adicione imagens significativas que te ajudem a se reconectar</li>
          </ul>

          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-3 mb-2">👤 Informações Pessoais</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Perfil Personalizável - Configure seu nome e preferências</li>
            <li>Metas Diárias - Defina objetivos personalizados para sono, tarefas, água e pausas</li>
            <li>Preferências Visuais - Configure opções de acessibilidade como alto contraste, redução de estímulos e texto grande</li>
          </ul>
        </Card>

        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-amber-600 dark:text-amber-400 mb-4">⚙️ Sprint 4</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">🔄 Melhorias de Interface</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Correção de distorções visuais - Garantia de uma experiência mais agradável</li>
            <li>Novos ícones e layout - Design mais intuitivo e acessível</li>
            <li>Atualização do rodapé - Inclusão de provérbio inspirador e acesso ao repositório</li>
            <li>Renomeação para StayFocus - Nova identidade visual</li>
          </ul>
        </Card>

        <Card>
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-rose-600 dark:text-rose-400 mb-4">🔮 Sprint 5 (Final)</h2>
            <div className="ml-2 bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              Planejado
            </div>
          </div>
          
          <div className="mb-4 p-3 border border-amber-200 dark:border-amber-900/50 rounded-lg bg-amber-50 dark:bg-amber-900/20">
            <p className="text-amber-800 dark:text-amber-200 font-medium">⚠️ Aviso importante</p>
            <p className="text-amber-700 dark:text-amber-300 text-sm">
              Para evitar sobrecarga cognitiva, haverá uma pausa de um mês antes do início do desenvolvimento deste sprint final.
            </p>
          </div>

          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">🤖 Assistente de IA</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Assistente pessoal - Ajuda contextual baseada em seu perfil e necessidades</li>
            <li>Análise de padrões - Insights sobre seus hábitos e comportamentos</li>
            <li>Sugestões personalizadas - Recomendações adaptadas ao seu estilo de vida</li>
            <li>Lembretes inteligentes - Notificações contextuais baseadas em seu histórico</li>
            <li>Modo conversa natural - Interface amigável e acolhedora para interação</li>
          </ul>

          <div className="mt-2 mb-4 p-4 border border-blue-200 dark:border-blue-900/50 rounded-lg bg-blue-50 dark:bg-blue-900/20">
            <p className="text-blue-800 dark:text-blue-200 font-medium mb-2">💡 Exemplos de Interações Inteligentes</p>
            <div className="space-y-3">
              <div className="border-l-2 border-blue-300 dark:border-blue-700 pl-3">
                <p className="text-blue-700 dark:text-blue-300 font-medium">Análise de Sono</p>
                <p className="text-sm text-blue-600 dark:text-blue-400">
                  "Notei que você tem dormido mais tarde nos últimos dias. Seus registros mostram que isso coincide com um aumento no uso de telas após as 22h. Que tal experimentarmos um lembrete para começar sua rotina noturna mais cedo?"
                </p>
              </div>
              
              <div className="border-l-2 border-blue-300 dark:border-blue-700 pl-3">
                <p className="text-blue-700 dark:text-blue-300 font-medium">Gestão de Medicamentos</p>
                <p className="text-sm text-blue-600 dark:text-blue-400">
                  "Seus registros indicam que você costuma esquecer o remédio da tarde quando está em reuniões. Posso ajustar os lembretes para 30 minutos antes das suas reuniões agendadas?"
                </p>
              </div>
              
              <div className="border-l-2 border-blue-300 dark:border-blue-700 pl-3">
                <p className="text-blue-700 dark:text-blue-300 font-medium">Suporte Emocional</p>
                <p className="text-sm text-blue-600 dark:text-blue-400">
                  "Percebi pelo seu diário que você tem se sentido sobrecarregado nas segundas-feiras. Com base nas suas anotações de autocuidado, que tal começarmos a semana com aquela meditação que você marcou como favorita?"
                </p>
              </div>
              
              <div className="border-l-2 border-blue-300 dark:border-blue-700 pl-3">
                <p className="text-blue-700 dark:text-blue-300 font-medium">Produtividade Adaptativa</p>
                <p className="text-sm text-blue-600 dark:text-blue-400">
                  "Analisando seus ciclos de foco, você tem melhor desempenho em tarefas criativas pela manhã. Quer que eu reorganize sua lista de prioridades para aproveitar esses momentos de maior criatividade?"
                </p>
              </div>
            </div>
          </div>

          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">🔄 Sincronização e Apps Mobile</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Backend com Supabase - Sincronização de dados entre dispositivos</li>
            <li>Aplicativo para iOS - Acesse sua aplicação em dispositivos Apple</li>
            <li>Aplicativo para Android - Versão para dispositivos Android</li>
            <li>Sincronização offline - Acesse seus dados mesmo sem internet</li>
          </ul>
        </Card>
      </Section>
    </Container>
  )
}
</file>

<file path="app/saude/exportar-dados/page.tsx">
'use client';

import { useAuthContext } from '@/app/context/AuthContext';
import DataExportForm from '@/app/components/saude/DataExportForm';
import { ArrowLeft } from 'lucide-react';
import Link from 'next/link';

/**
 * Página para exportação de dados de saúde
 * Permite ao usuário exportar seus dados para CSV ou PDF
 */
export default function ExportDataPage() {
  const { user } = useAuthContext();
  
  return (
    <div className="container mx-auto max-w-3xl px-4 py-8">
      <div className="mb-6">
        <Link 
          href="/saude"
          className="flex items-center text-blue-600 hover:text-blue-800 mb-4"
        >
          <ArrowLeft size={16} className="mr-1" />
          <span>Voltar para Saúde</span>
        </Link>
        
        <h1 className="text-2xl font-bold mb-2">Exportar Dados de Saúde</h1>
        <p className="text-gray-600 dark:text-gray-300">
          Exporte seus dados de saúde para compartilhar com profissionais ou para backup pessoal
        </p>
      </div>
      
      {!user ? (
        <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg border border-yellow-200 dark:border-yellow-800">
          <p className="text-yellow-800 dark:text-yellow-200">
            Você precisa estar logado para exportar seus dados.
          </p>
        </div>
      ) : (
        <>
          <DataExportForm />
          
          <div className="mt-8 bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
            <h2 className="text-lg font-medium mb-2">Informações Importantes</h2>
            <ul className="list-disc pl-5 space-y-1 text-gray-600 dark:text-gray-300 text-sm">
              <li>Os dados exportados são criptografados durante a transferência.</li>
              <li>Certifique-se de armazenar seus dados exportados em um local seguro.</li>
              <li>PDF é o formato recomendado para compartilhar com profissionais de saúde.</li>
              <li>CSV é ideal para análise em planilhas eletrônicas.</li>
              <li>Seus dados nunca são compartilhados com terceiros sem sua permissão.</li>
            </ul>
          </div>
        </>
      )}
    </div>
  );
}
</file>

<file path="app/saude/page.tsx">
import { RegistroMedicamentos } from '@/app/components/saude/RegistroMedicamentos'
import { MonitoramentoHumor } from '@/app/components/saude/MonitoramentoHumor'
import Link from 'next/link'
import { Download } from 'lucide-react'

export default function SaudePage() {
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center mb-4">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Saúde</h1>
        
        <Link 
          href="/saude/exportar-dados"
          className="inline-flex items-center px-4 py-2 text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
        >
          <Download size={16} className="mr-2" />
          Exportar Dados
        </Link>
      </div>
      
      <div className="grid grid-cols-1 gap-6">
        {/* Registro de Medicamentos */}
        <RegistroMedicamentos />
        
        {/* Monitoramento de Humor */}
        <MonitoramentoHumor />
      </div>
    </div>
  )
}
</file>

<file path="app/sono/page.tsx">
'use client'

import { useState } from 'react'
import { RegistroSono } from '../components/sono/RegistroSono'
import VisualizadorSemanal from '../components/sono/VisualizadorSemanal'
import ConfiguracaoLembretes from '../components/sono/ConfiguracaoLembretes'

export default function SonoPage() {
  const [abaSelecionada, setAbaSelecionada] = useState<'registro' | 'visualizador' | 'lembretes'>('registro')
  
  return (
    <main className="container mx-auto px-4 py-8 max-w-7xl">
      <div className="flex items-center mb-8">
        <div className="text-sono-primary mr-3 font-mono">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="28"
            height="28"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            aria-hidden="true"
          >
            <path d="M2 4v16"></path>
            <path d="M2 8h18a2 2 0 0 1 2 2v10"></path>
            <path d="M2 17h20"></path>
            <path d="M6 8v9"></path>
          </svg>
        </div>
        <h1 className="text-2xl font-bold text-gray-800 dark:text-white">Gestão do Sono</h1>
      </div>
      
      {/* Navegação entre abas */}
      <div className="flex border-b border-gray-200 dark:border-gray-700 mb-6">
        <button
          className={`px-4 py-2 font-medium text-sm rounded-t-lg ${
            abaSelecionada === 'registro'
              ? 'bg-sono-light text-sono-primary border-b-2 border-sono-primary'
              : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
          }`}
          onClick={() => setAbaSelecionada('registro')}
          aria-current={abaSelecionada === 'registro' ? 'page' : undefined}
        >
          Registrar Sono
        </button>
        <button
          className={`px-4 py-2 font-medium text-sm rounded-t-lg ${
            abaSelecionada === 'visualizador'
              ? 'bg-sono-light text-sono-primary border-b-2 border-sono-primary'
              : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
          }`}
          onClick={() => setAbaSelecionada('visualizador')}
          aria-current={abaSelecionada === 'visualizador' ? 'page' : undefined}
        >
          Visualizar Sono
        </button>
        <button
          className={`px-4 py-2 font-medium text-sm rounded-t-lg ${
            abaSelecionada === 'lembretes'
              ? 'bg-sono-light text-sono-primary border-b-2 border-sono-primary'
              : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
          }`}
          onClick={() => setAbaSelecionada('lembretes')}
          aria-current={abaSelecionada === 'lembretes' ? 'page' : undefined}
        >
          Lembretes
        </button>
      </div>
      
      {/* Conteúdo da aba selecionada */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        {abaSelecionada === 'registro' && <RegistroSono />}
        {abaSelecionada === 'visualizador' && <VisualizadorSemanal />}
        {abaSelecionada === 'lembretes' && <ConfiguracaoLembretes />}
      </div>
      
      {/* Informações adicionais */}
      <div className="bg-sono-light bg-opacity-50 dark:bg-gray-700 p-4 rounded-lg text-gray-700 dark:text-gray-300">
        <h3 className="text-lg font-medium mb-2 text-sono-primary">A importância do sono</h3>
        <p className="text-sm mb-2">
          O sono de qualidade é essencial para a saúde cerebral e física, especialmente para pessoas neurodivergentes.
          Regular seus ciclos de sono pode ajudar a reduzir a sobrecarga sensorial e melhorar o funcionamento cognitivo.
        </p>
        <ul className="text-sm list-disc pl-5 space-y-1">
          <li>Tente manter horários regulares para dormir e acordar</li>
          <li>Crie uma rotina relaxante antes de dormir</li>
          <li>Reduza a exposição à luz azul pelo menos 1 hora antes de dormir</li>
          <li>Evite cafeína e estimulantes no período da tarde</li>
        </ul>
      </div>
    </main>
  )
}
</file>

<file path="app/store/index.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipos para o estado global
export type Tarefa = {
  id: string
  texto: string
  concluida: boolean
  categoria: 'inicio' | 'alimentacao' | 'estudos' | 'saude' | 'lazer'
  data: string // formato YYYY-MM-DD
}

export type BlocoTempo = {
  id: string
  hora: string
  atividade: string
  categoria: 'inicio' | 'alimentacao' | 'estudos' | 'saude' | 'lazer' | 'nenhuma'
  data: string // formato YYYY-MM-DD
}

export type Refeicao = {
  id: string
  hora: string
  descricao: string
  foto?: string
  data: string // formato YYYY-MM-DD
}

export type Medicacao = {
  id: string
  nome: string
  horarios: string[]
  tomada: Record<string, boolean> // chave: data-horario, valor: tomada ou não
}

// Novo tipo para medicamentos refatorado
export type Medicamento = {
  id: string
  nome: string
  dosagem: string
  frequencia: string
  horarios: string[]
  observacoes: string
  dataInicio: string
  ultimaTomada: string | null
  intervalo?: number // tempo em minutos entre doses
}

// Novo tipo para registros de humor
export type RegistroHumor = {
  id: string
  data: string
  nivel: number
  fatores: string[]
  notas: string
}

export type ConfiguracaoUsuario = {
  tempoFoco: number // em minutos
  tempoPausa: number // em minutos
  temaEscuro: boolean
  reducaoEstimulos: boolean
}

// Interface do estado global
interface AppState {
  tarefas: Tarefa[]
  blocosTempo: BlocoTempo[]
  refeicoes: Refeicao[]
  medicacoes: Medicacao[]
  configuracao: ConfiguracaoUsuario
  
  // Novos estados para medicamentos e humor refatorados
  medicamentos: Medicamento[]
  registrosHumor: RegistroHumor[]
  
  // Ações para tarefas
  adicionarTarefa: (tarefa: Omit<Tarefa, 'id'>) => void
  removerTarefa: (id: string) => void
  toggleTarefaConcluida: (id: string) => void
  
  // Ações para blocos de tempo
  adicionarBlocoTempo: (bloco: Omit<BlocoTempo, 'id'>) => void
  atualizarBlocoTempo: (id: string, bloco: Partial<BlocoTempo>) => void
  removerBlocoTempo: (id: string) => void
  
  // Ações para refeições
  adicionarRefeicao: (refeicao: Omit<Refeicao, 'id'>) => void
  removerRefeicao: (id: string) => void
  
  // Ações para medicações
  adicionarMedicacao: (medicacao: Omit<Medicacao, 'id'>) => void
  marcarMedicacaoTomada: (id: string, data: string, horario: string, tomada: boolean) => void
  
  // Novas ações para medicamentos refatorados
  adicionarMedicamento: (medicamento: Omit<Medicamento, 'id'>) => void
  atualizarMedicamento: (id: string, medicamento: Partial<Omit<Medicamento, 'id'>>) => void
  removerMedicamento: (id: string) => void
  registrarTomadaMedicamento: (id: string, dataHora: string) => void
  
  // Novas ações para registros de humor
  adicionarRegistroHumor: (registro: Omit<RegistroHumor, 'id'>) => void
  atualizarRegistroHumor: (id: string, registro: Partial<Omit<RegistroHumor, 'id'>>) => void
  removerRegistroHumor: (id: string) => void
  
  // Ações para configurações
  atualizarConfiguracao: (config: Partial<ConfiguracaoUsuario>) => void
}

// Criação da store com persistência local
export const useAppStore = create<AppState>()(
  persist(
    (set) => ({
      // Estado inicial
      tarefas: [],
      blocosTempo: [],
      refeicoes: [],
      medicacoes: [],
      configuracao: {
        tempoFoco: 25,
        tempoPausa: 5,
        temaEscuro: false,
        reducaoEstimulos: false,
      },
      
      // Novos estados iniciais para medicamentos e humor
      medicamentos: [],
      registrosHumor: [],

      // Implementações das ações para tarefas
      adicionarTarefa: (tarefa) =>
        set((state) => ({
          tarefas: [...state.tarefas, { ...tarefa, id: Date.now().toString() }],
        })),
      
      removerTarefa: (id) =>
        set((state) => ({
          tarefas: state.tarefas.filter((t) => t.id !== id),
        })),
      
      toggleTarefaConcluida: (id) =>
        set((state) => ({
          tarefas: state.tarefas.map((t) =>
            t.id === id ? { ...t, concluida: !t.concluida } : t
          ),
        })),

      // Implementações das ações para blocos de tempo
      adicionarBlocoTempo: (bloco) =>
        set((state) => ({
          blocosTempo: [...state.blocosTempo, { ...bloco, id: Date.now().toString() }],
        })),
      
      atualizarBlocoTempo: (id, bloco) =>
        set((state) => ({
          blocosTempo: state.blocosTempo.map((b) =>
            b.id === id ? { ...b, ...bloco } : b
          ),
        })),
      
      removerBlocoTempo: (id) =>
        set((state) => ({
          blocosTempo: state.blocosTempo.filter((b) => b.id !== id),
        })),

      // Implementações das ações para refeições
      adicionarRefeicao: (refeicao) =>
        set((state) => ({
          refeicoes: [...state.refeicoes, { ...refeicao, id: Date.now().toString() }],
        })),
      
      removerRefeicao: (id) =>
        set((state) => ({
          refeicoes: state.refeicoes.filter((r) => r.id !== id),
        })),

      // Implementações das ações para medicações
      adicionarMedicacao: (medicacao) =>
        set((state) => ({
          medicacoes: [
            ...state.medicacoes,
            { ...medicacao, id: Date.now().toString() },
          ],
        })),
      
      marcarMedicacaoTomada: (id, data, horario, tomada) =>
        set((state) => ({
          medicacoes: state.medicacoes.map((med) => {
            if (med.id === id) {
              return {
                ...med,
                tomada: {
                  ...med.tomada,
                  [`${data}-${horario}`]: tomada,
                },
              }
            }
            return med
          }),
        })),
        
      // Implementações das novas ações para medicamentos
      adicionarMedicamento: (medicamento) =>
        set((state) => ({
          medicamentos: [
            ...state.medicamentos,
            {
              ...medicamento,
              id: Date.now().toString(),
            },
          ],
        })),
        
      atualizarMedicamento: (id, medicamento) =>
        set((state) => ({
          medicamentos: state.medicamentos.map((med) =>
            med.id === id ? { ...med, ...medicamento } : med
          ),
        })),
        
      removerMedicamento: (id) =>
        set((state) => ({
          medicamentos: state.medicamentos.filter((med) => med.id !== id),
        })),
        
      registrarTomadaMedicamento: (id, dataHora) =>
        set((state) => ({
          medicamentos: state.medicamentos.map((med) =>
            med.id === id ? { ...med, ultimaTomada: dataHora } : med
          ),
        })),
        
      // Implementações das novas ações para registros de humor
      adicionarRegistroHumor: (registro) =>
        set((state) => ({
          registrosHumor: [
            ...state.registrosHumor,
            {
              ...registro,
              id: Date.now().toString(),
            },
          ],
        })),
        
      atualizarRegistroHumor: (id, registro) =>
        set((state) => ({
          registrosHumor: state.registrosHumor.map((reg) =>
            reg.id === id ? { ...reg, ...registro } : reg
          ),
        })),
        
      removerRegistroHumor: (id) =>
        set((state) => ({
          registrosHumor: state.registrosHumor.filter((reg) => reg.id !== id),
        })),

      // Implementações das ações para configurações
      atualizarConfiguracao: (config) =>
        set((state) => ({
          configuracao: {
            ...state.configuracao,
            ...config,
          },
        })),
    }),
    {
      name: 'painel-neurodivergentes-storage',
      partialize: (state) => ({
        tarefas: state.tarefas,
        blocosTempo: state.blocosTempo,
        refeicoes: state.refeicoes,
        medicacoes: state.medicacoes,
        configuracao: state.configuracao,
        medicamentos: state.medicamentos,
        registrosHumor: state.registrosHumor,
      }),
    }
  )
)
</file>

<file path="app/store/rootReducer.ts">
import { combineReducers } from '@reduxjs/toolkit';

// Importe seus reducers aqui
// import sleepReducer from './sleepSlice';

const rootReducer = combineReducers({
  // Adicione seus reducers aqui
  // sleep: sleepReducer,
});

export default rootReducer;
</file>

<file path="app/store/store.ts">
import { configureStore } from '@reduxjs/toolkit';
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import rootReducer from './rootReducer';

const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production',
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false,
    }),
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

export default store;
</file>

<file path="app/stores/alimentacaoStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipos
export type Refeicao = {
  id: string
  horario: string
  descricao: string
}

export type RegistroRefeicao = {
  id: string
  data: string
  horario: string
  descricao: string
  tipoIcone: string | null
  foto: string | null
}

type AlimentacaoState = {
  // Planejador de Refeições
  refeicoes: Refeicao[]
  adicionarRefeicao: (horario: string, descricao: string) => void
  atualizarRefeicao: (id: string, horario: string, descricao: string) => void
  removerRefeicao: (id: string) => void
  
  // Registro de Refeições
  registros: RegistroRefeicao[]
  adicionarRegistro: (horario: string, descricao: string, tipoIcone: string | null, foto: string | null) => void
  removerRegistro: (id: string) => void
  
  // Hidratação
  coposBebidos: number
  metaDiaria: number
  ultimoRegistro: string | null
  adicionarCopo: () => void
  removerCopo: () => void
  ajustarMeta: (valor: number) => void
}

export const useAlimentacaoStore = create<AlimentacaoState>()(
  persist(
    (set) => ({
      // Planejador de Refeições - Estado Inicial
      refeicoes: [
        { id: '1', horario: '07:30', descricao: 'Café da manhã' },
        { id: '2', horario: '12:00', descricao: 'Almoço' },
        { id: '3', horario: '16:00', descricao: 'Lanche da tarde' },
        { id: '4', horario: '19:30', descricao: 'Jantar' },
      ],
      
      adicionarRefeicao: (horario, descricao) => 
        set((state) => ({
          refeicoes: [
            ...state.refeicoes,
            {
              id: Date.now().toString(),
              horario,
              descricao,
            },
          ],
        })),
      
      atualizarRefeicao: (id, horario, descricao) =>
        set((state) => ({
          refeicoes: state.refeicoes.map((refeicao) =>
            refeicao.id === id ? { ...refeicao, horario, descricao } : refeicao
          ),
        })),
      
      removerRefeicao: (id) =>
        set((state) => ({
          refeicoes: state.refeicoes.filter((refeicao) => refeicao.id !== id),
        })),
      
      // Registro de Refeições - Estado Inicial
      registros: [
        {
          id: '1',
          data: '2025-03-03',
          horario: '08:30',
          descricao: 'Café da manhã',
          tipoIcone: 'cafe',
          foto: null,
        },
      ],
      
      adicionarRegistro: (horario, descricao, tipoIcone, foto) =>
        set((state) => {
          const hoje = new Date().toISOString().split('T')[0]
          return {
            registros: [
              ...state.registros,
              {
                id: Date.now().toString(),
                data: hoje,
                horario,
                descricao,
                tipoIcone,
                foto,
              },
            ],
          }
        }),
      
      removerRegistro: (id) =>
        set((state) => ({
          registros: state.registros.filter((registro) => registro.id !== id),
        })),
      
      // Hidratação - Estado Inicial
      coposBebidos: 0,
      metaDiaria: 8,
      ultimoRegistro: null,
      
      adicionarCopo: () =>
        set((state) => {
          if (state.coposBebidos < state.metaDiaria) {
            return {
              coposBebidos: state.coposBebidos + 1,
              ultimoRegistro: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            }
          }
          return state
        }),
      
      removerCopo: () =>
        set((state) => ({
          coposBebidos: Math.max(0, state.coposBebidos - 1),
        })),
      
      ajustarMeta: (valor) =>
        set((state) => {
          const novaMeta = state.metaDiaria + valor
          if (novaMeta >= 1 && novaMeta <= 15) {
            return { metaDiaria: novaMeta }
          }
          return state
        }),
    }),
    {
      name: 'alimentacao-storage', // nome para o localStorage
    }
  )
)
</file>

<file path="app/stores/atividadesStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

type Atividade = {
  id: string
  nome: string
  categoria: string
  duracao: number // em minutos
  observacoes: string
  data: string
  concluida: boolean
}

interface AtividadesState {
  atividades: Atividade[]
  adicionarAtividade: (atividade: Atividade) => void
  removerAtividade: (id: string) => void
  marcarConcluida: (id: string) => void
}

export const useAtividadesStore = create<AtividadesState>()(
  persist(
    (set) => ({
      atividades: [],
      
      adicionarAtividade: (atividade) => set((state) => ({
        atividades: [...state.atividades, atividade]
      })),
      
      removerAtividade: (id) => set((state) => ({
        atividades: state.atividades.filter(a => a.id !== id)
      })),
      
      marcarConcluida: (id) => set((state) => ({
        atividades: state.atividades.map(a => 
          a.id === id ? { ...a, concluida: true } : a
        )
      })),
    }),
    {
      name: 'atividades-lazer',
      getStorage: () => localStorage
    }
  )
)
</file>

<file path="app/stores/autoconhecimentoStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipo para as notas
export type Nota = {
  id: string
  titulo: string
  conteudo: string
  secao: 'quem-sou' | 'meus-porques' | 'meus-padroes'
  tags: string[]
  dataCriacao: string
  dataAtualizacao: string
  imagemUrl?: string // URL para imagem âncora (opcional)
}

// Tipo para o estado da store
export type AutoconhecimentoState = {
  notas: Nota[]
  modoRefugio: boolean
  // Ações
  adicionarNota: (
    titulo: string,
    conteudo: string,
    secao: 'quem-sou' | 'meus-porques' | 'meus-padroes',
    tags?: string[],
    imagemUrl?: string
  ) => string
  atualizarNota: (
    id: string,
    dados: Partial<Omit<Nota, 'id' | 'dataCriacao'>>
  ) => void
  removerNota: (id: string) => void
  adicionarTag: (id: string, tag: string) => void
  removerTag: (id: string, tag: string) => void
  adicionarImagem: (id: string, imagemUrl: string) => void
  removerImagem: (id: string) => void
  alternarModoRefugio: () => void
  buscarNotas: (termo: string) => Nota[]
}

// Estado inicial
const estadoInicial = {
  notas: [],
  modoRefugio: false
}

// Criação da store com persistência
export const useAutoconhecimentoStore = create<AutoconhecimentoState>()(
  persist(
    (set, get) => ({
      ...estadoInicial,
      
      adicionarNota: (titulo, conteudo, secao, tags = [], imagemUrl) => {
        const id = Date.now().toString()
        const agora = new Date().toISOString()
        
        set((state) => ({
          notas: [
            ...state.notas,
            {
              id,
              titulo,
              conteudo,
              secao,
              tags,
              dataCriacao: agora,
              dataAtualizacao: agora,
              imagemUrl
            }
          ]
        }))
        
        return id
      },
      
      atualizarNota: (id, dados) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id 
            ? { 
                ...nota, 
                ...dados, 
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      removerNota: (id) => set((state) => ({
        notas: state.notas.filter((nota) => nota.id !== id)
      })),
      
      adicionarTag: (id, tag) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id && !nota.tags.includes(tag)
            ? { 
                ...nota, 
                tags: [...nota.tags, tag],
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      removerTag: (id, tag) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id
            ? { 
                ...nota, 
                tags: nota.tags.filter((t) => t !== tag),
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      adicionarImagem: (id, imagemUrl) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id
            ? { 
                ...nota, 
                imagemUrl,
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      removerImagem: (id) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id
            ? { 
                ...nota, 
                imagemUrl: undefined,
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      alternarModoRefugio: () => set((state) => ({
        modoRefugio: !state.modoRefugio
      })),
      
      buscarNotas: (termo) => {
        const { notas } = get()
        if (!termo.trim()) return notas
        
        const termoBusca = termo.toLowerCase()
        return notas.filter((nota) => 
          nota.titulo.toLowerCase().includes(termoBusca) ||
          nota.conteudo.toLowerCase().includes(termoBusca) ||
          nota.tags.some((tag) => tag.toLowerCase().includes(termoBusca))
        )
      }
    }),
    {
      name: 'autoconhecimento-storage',
    }
  )
)
</file>

<file path="app/stores/dataTransferStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

/**
 * Tipos de estado para a transferência de dados
 */
export type TransferenciaStatus = 'idle' | 'exporting' | 'importing' | 'success' | 'error';

interface DataTransferState {
  // Estado
  status: TransferenciaStatus;
  mensagem: string;
  ultimaExportacao: string | null;
  ultimaImportacao: string | null;
  
  // Ações
  setStatus: (status: TransferenciaStatus) => void;
  setMensagem: (mensagem: string) => void;
  registrarExportacao: () => void;
  registrarImportacao: (timestamp?: string) => void;
  limparHistorico: () => void;
}

/**
 * Store para gerenciar o estado da transferência de dados
 */
export const useDataTransferStore = create<DataTransferState>()(
  persist(
    (set) => ({
      // Estado inicial
      status: 'idle',
      mensagem: '',
      ultimaExportacao: null,
      ultimaImportacao: null,
      
      // Ações
      setStatus: (status) => set({ status }),
      
      setMensagem: (mensagem) => set({ mensagem }),
      
      registrarExportacao: () => set({ 
        ultimaExportacao: new Date().toISOString(),
        status: 'success',
        mensagem: 'Dados exportados com sucesso'
      }),
      
      registrarImportacao: (timestamp) => set({ 
        ultimaImportacao: timestamp || new Date().toISOString(),
        status: 'success',
        mensagem: 'Dados importados com sucesso'
      }),
      
      limparHistorico: () => set({ 
        ultimaExportacao: null,
        ultimaImportacao: null
      }),
    }),
    {
      name: 'data-transfer-storage', // nome para o localStorage
    }
  )
);
</file>

<file path="app/stores/financasStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipos
export type Categoria = {
  id: string
  nome: string
  cor: string
  icone: string
}

export type Transacao = {
  id: string
  data: string
  valor: number
  descricao: string
  categoriaId: string
  tipo: 'receita' | 'despesa'
}

export type Envelope = {
  id: string
  nome: string
  cor: string
  valorAlocado: number
  valorUtilizado: number
}

export type PagamentoRecorrente = {
  id: string
  descricao: string
  valor: number
  dataVencimento: string // dia do mês (1-31)
  categoriaId: string
  proximoPagamento: string | null // data do próximo pagamento (YYYY-MM-DD)
  pago: boolean
}

type FinancasState = {
  // Categorias
  categorias: Categoria[]
  adicionarCategoria: (nome: string, cor: string, icone: string) => void
  atualizarCategoria: (id: string, nome: string, cor: string, icone: string) => void
  removerCategoria: (id: string) => void
  
  // Transações
  transacoes: Transacao[]
  adicionarTransacao: (data: string, valor: number, descricao: string, categoriaId: string, tipo: 'receita' | 'despesa') => void
  removerTransacao: (id: string) => void
  
  // Envelopes
  envelopes: Envelope[]
  adicionarEnvelope: (nome: string, cor: string, valorAlocado: number) => void
  atualizarEnvelope: (id: string, nome: string, cor: string, valorAlocado: number) => void
  removerEnvelope: (id: string) => void
  registrarGastoEnvelope: (id: string, valor: number) => void
  
  // Pagamentos Recorrentes
  pagamentosRecorrentes: PagamentoRecorrente[]
  adicionarPagamentoRecorrente: (descricao: string, valor: number, dataVencimento: string, categoriaId: string) => void
  atualizarPagamentoRecorrente: (id: string, descricao: string, valor: number, dataVencimento: string, categoriaId: string) => void
  removerPagamentoRecorrente: (id: string) => void
  marcarPagamentoComoPago: (id: string, pago: boolean) => void
  atualizarProximoPagamento: (id: string, data: string) => void
}

// Cores predefinidas para categorias (com alto contraste)
const CORES_CATEGORIAS = [
  '#FF5252', // Vermelho
  '#4CAF50', // Verde
  '#2196F3', // Azul
  '#FFC107', // Amarelo
  '#9C27B0'  // Roxo
]

// Ícones predefinidos para categorias
const ICONES_CATEGORIAS = [
  'home',    // Casa
  'shopping-cart', // Compras
  'utensils', // Alimentação
  'car',     // Transporte
  'heart'    // Saúde
]

export const useFinancasStore = create<FinancasState>()(
  persist(
    (set) => ({
      // Categorias - Estado Inicial
      categorias: [
        { id: '1', nome: 'Moradia', cor: CORES_CATEGORIAS[0], icone: 'home' },
        { id: '2', nome: 'Alimentação', cor: CORES_CATEGORIAS[1], icone: 'utensils' },
        { id: '3', nome: 'Transporte', cor: CORES_CATEGORIAS[2], icone: 'car' },
        { id: '4', nome: 'Saúde', cor: CORES_CATEGORIAS[3], icone: 'heart' },
        { id: '5', nome: 'Lazer', cor: CORES_CATEGORIAS[4], icone: 'music' },
      ],
      
      adicionarCategoria: (nome, cor, icone) => 
        set((state) => {
          // Limitar a 5 categorias
          if (state.categorias.length >= 5) return state
          
          return {
            categorias: [
              ...state.categorias,
              {
                id: Date.now().toString(),
                nome,
                cor,
                icone,
              },
            ],
          }
        }),
      
      atualizarCategoria: (id, nome, cor, icone) =>
        set((state) => ({
          categorias: state.categorias.map((categoria) =>
            categoria.id === id ? { ...categoria, nome, cor, icone } : categoria
          ),
        })),
      
      removerCategoria: (id) =>
        set((state) => ({
          categorias: state.categorias.filter((categoria) => categoria.id !== id),
          // Remover transações e pagamentos relacionados à categoria
          transacoes: state.transacoes.filter((transacao) => transacao.categoriaId !== id),
          pagamentosRecorrentes: state.pagamentosRecorrentes.filter(
            (pagamento) => pagamento.categoriaId !== id
          ),
        })),
      
      // Transações - Estado Inicial
      transacoes: [],
      
      adicionarTransacao: (data, valor, descricao, categoriaId, tipo) =>
        set((state) => ({
          transacoes: [
            ...state.transacoes,
            {
              id: Date.now().toString(),
              data,
              valor,
              descricao,
              categoriaId,
              tipo,
            },
          ],
        })),
      
      removerTransacao: (id) =>
        set((state) => ({
          transacoes: state.transacoes.filter((transacao) => transacao.id !== id),
        })),
      
      // Envelopes - Estado Inicial
      envelopes: [
        { id: '1', nome: 'Emergências', cor: '#FF5252', valorAlocado: 500, valorUtilizado: 0 },
        { id: '2', nome: 'Férias', cor: '#2196F3', valorAlocado: 300, valorUtilizado: 0 },
        { id: '3', nome: 'Presentes', cor: '#4CAF50', valorAlocado: 100, valorUtilizado: 0 },
      ],
      
      adicionarEnvelope: (nome, cor, valorAlocado) =>
        set((state) => ({
          envelopes: [
            ...state.envelopes,
            {
              id: Date.now().toString(),
              nome,
              cor,
              valorAlocado,
              valorUtilizado: 0,
            },
          ],
        })),
      
      atualizarEnvelope: (id, nome, cor, valorAlocado) =>
        set((state) => ({
          envelopes: state.envelopes.map((envelope) =>
            envelope.id === id ? { ...envelope, nome, cor, valorAlocado } : envelope
          ),
        })),
      
      removerEnvelope: (id) =>
        set((state) => ({
          envelopes: state.envelopes.filter((envelope) => envelope.id !== id),
        })),
      
      registrarGastoEnvelope: (id, valor) =>
        set((state) => ({
          envelopes: state.envelopes.map((envelope) =>
            envelope.id === id
              ? { ...envelope, valorUtilizado: envelope.valorUtilizado + valor }
              : envelope
          ),
        })),
      
      // Pagamentos Recorrentes - Estado Inicial
      pagamentosRecorrentes: [],
      
      adicionarPagamentoRecorrente: (descricao, valor, dataVencimento, categoriaId) => {
        const hoje = new Date()
        const dia = parseInt(dataVencimento)
        const proximoPagamento = new Date(hoje.getFullYear(), hoje.getMonth(), dia)
        
        // Se o dia já passou este mês, avançar para o próximo mês
        if (proximoPagamento.getDate() < hoje.getDate()) {
          proximoPagamento.setMonth(proximoPagamento.getMonth() + 1)
        }
        
        return set((state) => ({
          pagamentosRecorrentes: [
            ...state.pagamentosRecorrentes,
            {
              id: Date.now().toString(),
              descricao,
              valor,
              dataVencimento,
              categoriaId,
              proximoPagamento: proximoPagamento.toISOString().split('T')[0],
              pago: false,
            },
          ],
        }))
      },
      
      atualizarPagamentoRecorrente: (id, descricao, valor, dataVencimento, categoriaId) =>
        set((state) => ({
          pagamentosRecorrentes: state.pagamentosRecorrentes.map((pagamento) =>
            pagamento.id === id
              ? { ...pagamento, descricao, valor, dataVencimento, categoriaId }
              : pagamento
          ),
        })),
      
      removerPagamentoRecorrente: (id) =>
        set((state) => ({
          pagamentosRecorrentes: state.pagamentosRecorrentes.filter(
            (pagamento) => pagamento.id !== id
          ),
        })),
      
      marcarPagamentoComoPago: (id, pago) =>
        set((state) => {
          const pagamentos = state.pagamentosRecorrentes.map((pagamento) => {
            if (pagamento.id !== id) return pagamento
            
            if (pago) {
              // Se marcado como pago, calcular o próximo pagamento
              const dataAtual = new Date()
              const dia = parseInt(pagamento.dataVencimento)
              let proximoMes = dataAtual.getMonth() + 1
              let proximoAno = dataAtual.getFullYear()
              
              if (proximoMes > 11) {
                proximoMes = 0
                proximoAno++
              }
              
              const proximoPagamento = new Date(proximoAno, proximoMes, dia)
              
              return {
                ...pagamento,
                pago,
                proximoPagamento: proximoPagamento.toISOString().split('T')[0],
              }
            }
            
            return { ...pagamento, pago }
          })
          
          return { pagamentosRecorrentes: pagamentos }
        }),
      
      atualizarProximoPagamento: (id, data) =>
        set((state) => ({
          pagamentosRecorrentes: state.pagamentosRecorrentes.map((pagamento) =>
            pagamento.id === id ? { ...pagamento, proximoPagamento: data } : pagamento
          ),
        })),
    }),
    {
      name: 'financas-storage', // nome para o localStorage
    }
  )
)
</file>

<file path="app/stores/hiperfocosStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipos
export type Tarefa = {
  id: string
  texto: string
  concluida: boolean
  cor?: string
}

export type Hiperfoco = {
  id: string
  titulo: string
  descricao: string
  tarefas: Tarefa[]
  subTarefas: Record<string, Tarefa[]> // Id da tarefa pai -> lista de sub-tarefas
  cor: string
  dataCriacao: string
  tempoLimite?: number // em minutos, opcional
}

export type SessaoAlternancia = {
  id: string
  titulo: string
  hiperfocoAtual: string | null // ID do hiperfoco ativo
  hiperfocoAnterior: string | null // ID do hiperfoco anterior
  tempoInicio: string
  duracaoEstimada: number // em minutos
  concluida: boolean
}

type HiperfocosState = {
  // Hiperfocos
  hiperfocos: Hiperfoco[]
  adicionarHiperfoco: (titulo: string, descricao: string, cor: string, tempoLimite?: number) => string
  atualizarHiperfoco: (id: string, titulo: string, descricao: string, cor: string, tempoLimite?: number) => void
  removerHiperfoco: (id: string) => void
  
  // Tarefas
  adicionarTarefa: (hiperfocoId: string, texto: string) => string
  atualizarTarefa: (hiperfocoId: string, tarefaId: string, texto: string) => void
  toggleTarefaConcluida: (hiperfocoId: string, tarefaId: string) => void
  removerTarefa: (hiperfocoId: string, tarefaId: string) => void
  
  // Sub-tarefas
  adicionarSubTarefa: (hiperfocoId: string, tarefaPaiId: string, texto: string) => string
  atualizarSubTarefa: (hiperfocoId: string, tarefaPaiId: string, subTarefaId: string, texto: string) => void
  toggleSubTarefaConcluida: (hiperfocoId: string, tarefaPaiId: string, subTarefaId: string) => void
  removerSubTarefa: (hiperfocoId: string, tarefaPaiId: string, subTarefaId: string) => void
  
  // Alternância
  sessoes: SessaoAlternancia[]
  adicionarSessao: (titulo: string, hiperfocoId: string, duracaoEstimada: number) => string
  atualizarSessao: (id: string, titulo: string, hiperfocoId: string, duracaoEstimada: number) => void
  concluirSessao: (id: string) => void
  removerSessao: (id: string) => void
  alternarHiperfoco: (sessaoId: string, novoHiperfocoId: string) => void
}

// Cores predefinidas para hiperfocos
export const CORES_HIPERFOCOS = [
  '#FF5252', // Vermelho
  '#4CAF50', // Verde
  '#2196F3', // Azul
  '#FF9800', // Laranja
  '#9C27B0', // Roxo
  '#795548', // Marrom
  '#607D8B'  // Azul acinzentado
]

export const useHiperfocosStore = create<HiperfocosState>()(
  persist(
    (set, get) => ({
      // Estado inicial
      hiperfocos: [],
      sessoes: [],
      
      // Ações para hiperfocos
      adicionarHiperfoco: (titulo, descricao, cor, tempoLimite) => {
        const id = Date.now().toString()
        set((state) => ({
          hiperfocos: [
            ...state.hiperfocos,
            {
              id,
              titulo,
              descricao,
              tarefas: [],
              subTarefas: {},
              cor,
              dataCriacao: new Date().toISOString(),
              tempoLimite
            }
          ]
        }))
        return id
      },
      
      atualizarHiperfoco: (id, titulo, descricao, cor, tempoLimite) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) =>
            hiperfoco.id === id
              ? { ...hiperfoco, titulo, descricao, cor, tempoLimite }
              : hiperfoco
          )
        }))
      },
      
      removerHiperfoco: (id) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.filter((hiperfoco) => hiperfoco.id !== id),
          // Também remover as sessões associadas a este hiperfoco
          sessoes: state.sessoes.filter(
            (sessao) => sessao.hiperfocoAtual !== id && sessao.hiperfocoAnterior !== id
          )
        }))
      },
      
      // Ações para tarefas
      adicionarTarefa: (hiperfocoId, texto) => {
        const tarefaId = Date.now().toString()
        
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                tarefas: [
                  ...hiperfoco.tarefas,
                  {
                    id: tarefaId,
                    texto,
                    concluida: false
                  }
                ],
                // Inicializar a entrada de subTarefas para esta tarefa
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaId]: []
                }
              }
            }
            return hiperfoco
          })
        }))
        
        return tarefaId
      },
      
      atualizarTarefa: (hiperfocoId, tarefaId, texto) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                tarefas: hiperfoco.tarefas.map((tarefa) =>
                  tarefa.id === tarefaId ? { ...tarefa, texto } : tarefa
                )
              }
            }
            return hiperfoco
          })
        }))
      },
      
      toggleTarefaConcluida: (hiperfocoId, tarefaId) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                tarefas: hiperfoco.tarefas.map((tarefa) =>
                  tarefa.id === tarefaId
                    ? { ...tarefa, concluida: !tarefa.concluida }
                    : tarefa
                )
              }
            }
            return hiperfoco
          })
        }))
      },
      
      removerTarefa: (hiperfocoId, tarefaId) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              // Filtrar a tarefa e também remover suas subtarefas
              const { [tarefaId]: subTarefasARemover, ...restoSubTarefas } = hiperfoco.subTarefas
              
              return {
                ...hiperfoco,
                tarefas: hiperfoco.tarefas.filter((tarefa) => tarefa.id !== tarefaId),
                subTarefas: restoSubTarefas
              }
            }
            return hiperfoco
          })
        }))
      },
      
      // Ações para sub-tarefas
      adicionarSubTarefa: (hiperfocoId, tarefaPaiId, texto) => {
        const subTarefaId = Date.now().toString()
        
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaPaiId]: [
                    ...(hiperfoco.subTarefas[tarefaPaiId] || []),
                    {
                      id: subTarefaId,
                      texto,
                      concluida: false
                    }
                  ]
                }
              }
            }
            return hiperfoco
          })
        }))
        
        return subTarefaId
      },
      
      atualizarSubTarefa: (hiperfocoId, tarefaPaiId, subTarefaId, texto) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaPaiId]: (hiperfoco.subTarefas[tarefaPaiId] || []).map((subTarefa) =>
                    subTarefa.id === subTarefaId ? { ...subTarefa, texto } : subTarefa
                  )
                }
              }
            }
            return hiperfoco
          })
        }))
      },
      
      toggleSubTarefaConcluida: (hiperfocoId, tarefaPaiId, subTarefaId) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaPaiId]: (hiperfoco.subTarefas[tarefaPaiId] || []).map((subTarefa) =>
                    subTarefa.id === subTarefaId
                      ? { ...subTarefa, concluida: !subTarefa.concluida }
                      : subTarefa
                  )
                }
              }
            }
            return hiperfoco
          })
        }))
      },
      
      removerSubTarefa: (hiperfocoId, tarefaPaiId, subTarefaId) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaPaiId]: (hiperfoco.subTarefas[tarefaPaiId] || []).filter(
                    (subTarefa) => subTarefa.id !== subTarefaId
                  )
                }
              }
            }
            return hiperfoco
          })
        }))
      },
      
      // Ações para sessões de alternância
      adicionarSessao: (titulo, hiperfocoId, duracaoEstimada) => {
        const id = Date.now().toString()
        
        set((state) => ({
          sessoes: [
            ...state.sessoes,
            {
              id,
              titulo,
              hiperfocoAtual: hiperfocoId,
              hiperfocoAnterior: null,
              tempoInicio: new Date().toISOString(),
              duracaoEstimada,
              concluida: false
            }
          ]
        }))
        
        return id
      },
      
      atualizarSessao: (id, titulo, hiperfocoId, duracaoEstimada) => {
        set((state) => ({
          sessoes: state.sessoes.map((sessao) =>
            sessao.id === id
              ? { ...sessao, titulo, hiperfocoAtual: hiperfocoId, duracaoEstimada }
              : sessao
          )
        }))
      },
      
      concluirSessao: (id) => {
        set((state) => ({
          sessoes: state.sessoes.map((sessao) =>
            sessao.id === id ? { ...sessao, concluida: true } : sessao
          )
        }))
      },
      
      removerSessao: (id) => {
        set((state) => ({
          sessoes: state.sessoes.filter((sessao) => sessao.id !== id)
        }))
      },
      
      alternarHiperfoco: (sessaoId, novoHiperfocoId) => {
        set((state) => ({
          sessoes: state.sessoes.map((sessao) => {
            if (sessao.id === sessaoId) {
              return {
                ...sessao,
                hiperfocoAnterior: sessao.hiperfocoAtual,
                hiperfocoAtual: novoHiperfocoId,
                tempoInicio: new Date().toISOString()
              }
            }
            return sessao
          })
        }))
      }
    }),
    {
      name: 'hiperfocos-storage' // nome para o localStorage
    }
  )
)
</file>

<file path="app/stores/painelDiaStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type BlocoTempo = {
  id: string
  hora: string
  atividade: string
  categoria: 'inicio' | 'alimentacao' | 'estudos' | 'saude' | 'lazer' | 'nenhuma'
}

// Dados de exemplo para demonstração
const blocosIniciais: BlocoTempo[] = [
  { id: '1', hora: '08:00', atividade: 'Café da manhã', categoria: 'alimentacao' },
  { id: '2', hora: '09:00', atividade: 'Estudar matemática', categoria: 'estudos' },
  { id: '3', hora: '10:00', atividade: 'Pausa para alongamento', categoria: 'saude' },
  { id: '4', hora: '11:00', atividade: 'Continuar estudos', categoria: 'estudos' },
  { id: '5', hora: '12:00', atividade: 'Almoço', categoria: 'alimentacao' },
  { id: '6', hora: '13:00', atividade: 'Descanso breve', categoria: 'lazer' },
  { id: '7', hora: '14:00', atividade: 'Reunião online', categoria: 'estudos' },
  { id: '8', hora: '15:00', atividade: 'Exercício físico', categoria: 'saude' },
  { id: '9', hora: '16:00', atividade: 'Leitura', categoria: 'lazer' },
  { id: '10', hora: '17:00', atividade: 'Organizar materiais', categoria: 'estudos' },
  { id: '11', hora: '18:00', atividade: 'Jantar', categoria: 'alimentacao' },
  { id: '12', hora: '19:00', atividade: 'Tempo livre', categoria: 'lazer' },
]

interface PainelDiaState {
  blocos: BlocoTempo[]
  editarAtividade: (id: string, atividade: string) => void
  editarCategoria: (id: string, categoria: BlocoTempo['categoria']) => void
  adicionarBloco: (bloco: BlocoTempo) => void
  removerBloco: (id: string) => void
}

export const usePainelDiaStore = create<PainelDiaState>()(
  persist(
    (set) => ({
      blocos: blocosIniciais,
      
      // Editar a atividade de um bloco
      editarAtividade: (id, atividade) => set((state) => ({
        blocos: state.blocos.map(bloco => 
          bloco.id === id ? { ...bloco, atividade } : bloco
        )
      })),
      
      // Editar a categoria de um bloco
      editarCategoria: (id, categoria) => set((state) => ({
        blocos: state.blocos.map(bloco => 
          bloco.id === id ? { ...bloco, categoria } : bloco
        )
      })),
      
      // Adicionar um novo bloco
      adicionarBloco: (bloco) => set((state) => ({
        blocos: [...state.blocos, bloco]
      })),
      
      // Remover um bloco
      removerBloco: (id) => set((state) => ({
        blocos: state.blocos.filter(bloco => bloco.id !== id)
      })),
    }),
    {
      name: 'painel-dia-storage',
      getStorage: () => localStorage
    }
  )
)
</file>

<file path="app/stores/perfilStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type PreferenciasVisuais = {
  altoContraste: boolean
  reducaoEstimulos: boolean
  textoGrande: boolean
}

export type MetasDiarias = {
  horasSono: number         // Horas ideais de sono
  tarefasPrioritarias: number // Número de tarefas prioritárias
  coposAgua: number         // Copos de água por dia
  pausasProgramadas: number // Número de pausas programadas
}

export type PerfilState = {
  nome: string
  preferenciasVisuais: PreferenciasVisuais
  metasDiarias: MetasDiarias
  notificacoesAtivas: boolean
  pausasAtivas: boolean
  // Ações
  atualizarNome: (nome: string) => void
  atualizarPreferenciasVisuais: (preferencias: Partial<PreferenciasVisuais>) => void
  atualizarMetasDiarias: (metas: Partial<MetasDiarias>) => void
  alternarNotificacoes: () => void
  alternarPausas: () => void
  resetarPerfil: () => void
}

const defaultState = {
  nome: 'Usuário',
  preferenciasVisuais: {
    altoContraste: false,
    reducaoEstimulos: false,
    textoGrande: false
  },
  metasDiarias: {
    horasSono: 8,
    tarefasPrioritarias: 3,
    coposAgua: 8,
    pausasProgramadas: 4
  },
  notificacoesAtivas: true,
  pausasAtivas: true
}

export const usePerfilStore = create<PerfilState>()(
  persist(
    (set) => ({
      ...defaultState,
      
      atualizarNome: (nome) => set({
        nome
      }),
      
      atualizarPreferenciasVisuais: (preferencias) => set((state) => ({
        preferenciasVisuais: {
          ...state.preferenciasVisuais,
          ...preferencias
        }
      })),
      
      atualizarMetasDiarias: (metas) => set((state) => ({
        metasDiarias: {
          ...state.metasDiarias,
          ...metas
        }
      })),
      
      alternarNotificacoes: () => set((state) => ({
        notificacoesAtivas: !state.notificacoesAtivas
      })),
      
      alternarPausas: () => set((state) => ({
        pausasAtivas: !state.pausasAtivas
      })),
      
      resetarPerfil: () => set(defaultState)
    }),
    {
      name: 'perfil-storage',
    }
  )
)
</file>

<file path="app/stores/pomodoroStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

type CicloPomodoro = 'foco' | 'pausa' | 'longapausa'

interface ConfiguracaoPomodoro {
  tempoFoco: number        // em minutos
  tempoPausa: number       // em minutos
  tempoLongapausa: number  // em minutos
  ciclosAntesLongapausa: number
}

interface PomodoroState {
  // Configuração do pomodoro
  configuracao: ConfiguracaoPomodoro
  atualizarConfiguracao: (config: Partial<ConfiguracaoPomodoro>) => void
  
  // Estatísticas
  ciclosCompletos: number
  incrementarCiclosCompletos: () => void
  resetarCiclosCompletos: () => void
}

export const usePomodoroStore = create<PomodoroState>()(
  persist(
    (set) => ({
      // Configuração padrão
      configuracao: {
        tempoFoco: 25,
        tempoPausa: 5,
        tempoLongapausa: 15,
        ciclosAntesLongapausa: 4,
      },
      
      // Atualizar configuração
      atualizarConfiguracao: (config) => set((state) => ({
        configuracao: {
          ...state.configuracao,
          ...config,
        }
      })),
      
      // Estatísticas
      ciclosCompletos: 0,
      
      incrementarCiclosCompletos: () => set((state) => ({
        ciclosCompletos: state.ciclosCompletos + 1
      })),
      
      resetarCiclosCompletos: () => set({
        ciclosCompletos: 0
      }),
    }),
    {
      name: 'pomodoro-storage',
      getStorage: () => localStorage
    }
  )
)
</file>

<file path="app/stores/prioridadesStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type Prioridade = {
  id: string
  texto: string
  concluida: boolean
  data: string // formato ISO: YYYY-MM-DD
}

interface PrioridadesState {
  prioridades: Prioridade[]
  adicionarPrioridade: (prioridade: Omit<Prioridade, 'id' | 'data'>) => void
  editarPrioridade: (id: string, texto: string) => void
  removerPrioridade: (id: string) => void
  toggleConcluida: (id: string) => void
  getHistoricoPorData: (data?: string) => Prioridade[]
  getDatasPrioridades: () => string[]
}

export const usePrioridadesStore = create<PrioridadesState>()(
  persist(
    (set, get) => ({
      prioridades: [],
      
      adicionarPrioridade: (prioridade) => set((state) => {
        // Obter a data atual em formato ISO (YYYY-MM-DD)
        const dataAtual = new Date().toISOString().split('T')[0]
        
        return {
          prioridades: [
            ...state.prioridades,
            {
              ...prioridade,
              id: crypto.randomUUID(),
              data: dataAtual
            }
          ]
        }
      }),
      
      editarPrioridade: (id, texto) => set((state) => ({
        prioridades: state.prioridades.map(p => 
          p.id === id ? { ...p, texto } : p
        )
      })),
      
      removerPrioridade: (id) => set((state) => ({
        prioridades: state.prioridades.filter(p => p.id !== id)
      })),
      
      toggleConcluida: (id) => set((state) => ({
        prioridades: state.prioridades.map(p => 
          p.id === id ? { ...p, concluida: !p.concluida } : p
        )
      })),
      
      getHistoricoPorData: (data) => {
        const dataFiltro = data || new Date().toISOString().split('T')[0]
        return get().prioridades.filter(p => p.data === dataFiltro)
      },
      
      getDatasPrioridades: () => {
        // Retorna array de datas únicas (sem repetições)
        const datas = get().prioridades.map(p => p.data)
        return Array.from(new Set(datas)).sort().reverse() // Mais recentes primeiro
      }
    }),
    {
      name: 'prioridades-diarias',
      getStorage: () => localStorage
    }
  )
)
</file>

<file path="app/stores/registroEstudosStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type SessaoEstudo = {
  id: string
  titulo: string
  descricao: string
  duracao: number // em minutos
  data: string
  completo: boolean
}

// Dados iniciais para demonstração
const sessoesIniciais: SessaoEstudo[] = [
  {
    id: '1',
    titulo: 'Matemática - Álgebra Linear',
    descricao: 'Revisão de matrizes e determinantes',
    duracao: 45,
    data: '2023-03-03',
    completo: true,
  },
  {
    id: '2',
    titulo: 'Inglês - Vocabulário',
    descricao: 'Praticar vocabulário técnico',
    duracao: 30,
    data: '2023-03-04',
    completo: false,
  },
]

interface RegistroEstudosState {
  sessoes: SessaoEstudo[]
  adicionarSessao: (sessao: Omit<SessaoEstudo, 'id' | 'data' | 'completo'>) => void
  removerSessao: (id: string) => void
  alternarCompletar: (id: string) => void
  editarSessao: (id: string, dados: Pick<SessaoEstudo, 'titulo' | 'descricao' | 'duracao'>) => void
}

export const useRegistroEstudosStore = create<RegistroEstudosState>()(
  persist(
    (set) => ({
      sessoes: sessoesIniciais,
      
      adicionarSessao: (sessao) => set((state) => {
        const hoje = new Date().toISOString().split('T')[0]
        
        return {
          sessoes: [
            ...state.sessoes,
            {
              id: Date.now().toString(),
              titulo: sessao.titulo,
              descricao: sessao.descricao,
              duracao: sessao.duracao,
              data: hoje,
              completo: false,
            },
          ],
        }
      }),
      
      removerSessao: (id) => set((state) => ({
        sessoes: state.sessoes.filter((sessao) => sessao.id !== id)
      })),
      
      alternarCompletar: (id) => set((state) => ({
        sessoes: state.sessoes.map((sessao) =>
          sessao.id === id ? { ...sessao, completo: !sessao.completo } : sessao
        )
      })),
      
      editarSessao: (id, dados) => set((state) => ({
        sessoes: state.sessoes.map((sessao) =>
          sessao.id === id
            ? {
                ...sessao,
                titulo: dados.titulo,
                descricao: dados.descricao,
                duracao: dados.duracao,
              }
            : sessao
        )
      })),
    }),
    {
      name: 'registro-estudos-storage',
      getStorage: () => localStorage
    }
  )
)
</file>

<file path="app/stores/sonoStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type RegistroSono = {
  id: string
  inicio: string // ISO date string
  fim: string | null // ISO date string ou null se ainda não acordou
  qualidade: number | null // 1-5, onde 5 é a melhor qualidade
  notas: string
}

export type ConfiguracaoLembrete = {
  id: string
  tipo: 'dormir' | 'acordar'
  horario: string // Formato HH:MM
  diasSemana: number[] // 0-6, onde 0 é domingo
  ativo: boolean
}

export type SonoState = {
  registros: RegistroSono[]
  lembretes: ConfiguracaoLembrete[]
  // Ações
  adicionarRegistroSono: (inicio: string, fim?: string | null, qualidade?: number | null, notas?: string) => void
  atualizarRegistroSono: (id: string, dados: Partial<Omit<RegistroSono, 'id'>>) => void
  removerRegistroSono: (id: string) => void
  adicionarLembrete: (tipo: 'dormir' | 'acordar', horario: string, diasSemana: number[]) => void
  atualizarLembrete: (id: string, dados: Partial<Omit<ConfiguracaoLembrete, 'id'>>) => void
  removerLembrete: (id: string) => void
  alternarAtivoLembrete: (id: string) => void
}

export const useSonoStore = create<SonoState>()(
  persist(
    (set) => ({
      registros: [],
      lembretes: [],
      
      adicionarRegistroSono: (inicio, fim = null, qualidade = null, notas = '') => set((state) => ({
        registros: [
          ...state.registros,
          {
            id: Date.now().toString(),
            inicio,
            fim,
            qualidade,
            notas
          }
        ]
      })),
      
      atualizarRegistroSono: (id, dados) => set((state) => ({
        registros: state.registros.map((registro) => 
          registro.id === id 
            ? { ...registro, ...dados } 
            : registro
        )
      })),
      
      removerRegistroSono: (id) => set((state) => ({
        registros: state.registros.filter((registro) => registro.id !== id)
      })),
      
      adicionarLembrete: (tipo, horario, diasSemana) => set((state) => ({
        lembretes: [
          ...state.lembretes,
          {
            id: Date.now().toString(),
            tipo,
            horario,
            diasSemana,
            ativo: true
          }
        ]
      })),
      
      atualizarLembrete: (id, dados) => set((state) => ({
        lembretes: state.lembretes.map((lembrete) => 
          lembrete.id === id 
            ? { ...lembrete, ...dados } 
            : lembrete
        )
      })),
      
      removerLembrete: (id) => set((state) => ({
        lembretes: state.lembretes.filter((lembrete) => lembrete.id !== id)
      })),
      
      alternarAtivoLembrete: (id) => set((state) => ({
        lembretes: state.lembretes.map((lembrete) =>
          lembrete.id === id
            ? { ...lembrete, ativo: !lembrete.ativo }
            : lembrete
        )
      }))
    }),
    {
      name: 'sono-storage',
    }
  )
)
</file>

<file path="app/stores/store.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { PriorityItem, MedicationItem, MoodRecordItem, SleepRecordItem } from '../types/supabase'

interface AppState {
  prioridades: PriorityItem[]
  medicamentos: MedicationItem[]
  registrosHumor: MoodRecordItem[]
  registrosSono: SleepRecordItem[]
  setPrioridades: (prioridades: PriorityItem[]) => void
  setMedicamentos: (medicamentos: MedicationItem[]) => void
  setRegistrosHumor: (registros: MoodRecordItem[]) => void
  setRegistrosSono: (registros: SleepRecordItem[]) => void
}

export const useStore = create<AppState>()(
  persist(
    (set) => ({
      prioridades: [],
      medicamentos: [],
      registrosHumor: [],
      registrosSono: [],
      setPrioridades: (prioridades) => set({ prioridades }),
      setMedicamentos: (medicamentos) => set({ medicamentos }),
      setRegistrosHumor: (registros) => set({ registrosHumor: registros }),
      setRegistrosSono: (registros) => set({ registrosSono: registros })
    }),
    {
      name: 'app-storage'
    }
  )
)
</file>

<file path="app/stores/sugestoesStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface SugestoesState {
  sugestoesFavoritas: string[]
  adicionarFavorita: (sugestao: string) => void
  removerFavorita: (sugestao: string) => void
}

export const useSugestoesStore = create<SugestoesState>()(
  persist(
    (set) => ({
      sugestoesFavoritas: [],
      
      adicionarFavorita: (sugestao) => set((state) => {
        // Evitar duplicatas
        if (state.sugestoesFavoritas.includes(sugestao)) {
          return state
        }
        return {
          sugestoesFavoritas: [...state.sugestoesFavoritas, sugestao]
        }
      }),
      
      removerFavorita: (sugestao) => set((state) => ({
        sugestoesFavoritas: state.sugestoesFavoritas.filter(s => s !== sugestao)
      })),
    }),
    {
      name: 'sugestoes-favoritas',
      getStorage: () => localStorage
    }
  )
)
</file>

<file path="app/test/auth/auth-test.tsx">
'use client';

import { useState } from 'react';
import { createClient } from '@/app/lib/supabase';
import { Card, CardHeader, CardTitle, CardContent } from '@/app/components/ui/Card';
import { Button } from '@/app/components/ui/Button';
import { Input } from '@/app/components/ui/Input';
import { Label } from '@/app/components/ui/Label';

export default function AuthenticationTest() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
  const [currentUser, setCurrentUser] = useState<any>(null);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [log, setLog] = useState<string[]>([]);

  const addLog = (message: string) => {
    setLog((prev) => [...prev, `[${new Date().toISOString()}] ${message}`]);
  };

  const clearLog = () => setLog([]);

  const signUp = async () => {
    setStatus('loading');
    clearLog();
    setErrorMessage(null);
    
    try {
      addLog(`Tentando criar usuário: ${email}`);
      const supabase = createClient();
      
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            full_name: name
          }
        }
      });
      
      if (error) throw error;
      
      addLog('Usuário criado com sucesso!');
      addLog('Verifique seu email para confirmar o cadastro');
      setStatus('success');
      
      // Verificar se o usuário foi criado ou se é apenas um email confirmado
      if (data.user) {
        setCurrentUser(data.user);
        addLog(`ID do usuário: ${data.user.id}`);
      } else {
        addLog('Email de confirmação enviado.');
      }
    } catch (err: any) {
      setStatus('error');
      setErrorMessage(err.message);
      addLog(`ERRO: ${err.message}`);
    }
  };

  const signIn = async () => {
    setStatus('loading');
    clearLog();
    setErrorMessage(null);
    
    try {
      addLog(`Tentando autenticar: ${email}`);
      const supabase = createClient();
      
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password
      });
      
      if (error) throw error;
      
      setCurrentUser(data.user);
      setStatus('success');
      addLog('Autenticação bem-sucedida!');
      addLog(`ID do usuário: ${data.user.id}`);
      
      // Verificar o perfil
      const { data: profileData, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', data.user.id)
        .single();
      
      if (profileError) {
        addLog(`Erro ao buscar perfil: ${profileError.message}`);
      } else if (profileData) {
        addLog(`Perfil encontrado: ${JSON.stringify(profileData)}`);
      } else {
        addLog('Perfil não encontrado.');
      }
    } catch (err: any) {
      setStatus('error');
      setErrorMessage(err.message);
      addLog(`ERRO: ${err.message}`);
    }
  };

  const signOut = async () => {
    setStatus('loading');
    
    try {
      addLog('Finalizando sessão...');
      const supabase = createClient();
      
      const { error } = await supabase.auth.signOut();
      
      if (error) throw error;
      
      setCurrentUser(null);
      setStatus('idle');
      addLog('Sessão finalizada com sucesso');
    } catch (err: any) {
      setStatus('error');
      setErrorMessage(err.message);
      addLog(`ERRO: ${err.message}`);
    }
  };

  const checkSession = async () => {
    setStatus('loading');
    clearLog();
    
    try {
      addLog('Verificando sessão atual...');
      const supabase = createClient();
      
      const { data, error } = await supabase.auth.getSession();
      
      if (error) throw error;
      
      if (data.session) {
        setCurrentUser(data.session.user);
        addLog('Sessão ativa encontrada');
        addLog(`Usuário: ${data.session.user.email}`);
        addLog(`ID: ${data.session.user.id}`);
        
        // Verificar o perfil
        const { data: profileData, error: profileError } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', data.session.user.id)
          .single();
        
        if (profileError) {
          addLog(`Erro ao buscar perfil: ${profileError.message}`);
        } else if (profileData) {
          addLog(`Perfil encontrado: ${JSON.stringify(profileData)}`);
        } else {
          addLog('Perfil não encontrado.');
        }
      } else {
        setCurrentUser(null);
        addLog('Nenhuma sessão ativa');
      }
      
      setStatus('idle');
    } catch (err: any) {
      setStatus('error');
      setErrorMessage(err.message);
      addLog(`ERRO: ${err.message}`);
    }
  };

  const createTestUser = async () => {
    setStatus('loading');
    clearLog();
    setErrorMessage(null);
    
    const testEmail = `teste.${Date.now()}@neurodivergente.app`;
    const testPassword = 'Teste@123456';
    const testName = 'Usuário de Teste';
    
    try {
      addLog(`Criando usuário de teste: ${testEmail}`);
      const supabase = createClient();
      
      const { data, error } = await supabase.auth.signUp({
        email: testEmail,
        password: testPassword,
        options: {
          data: {
            full_name: testName
          }
        }
      });
      
      if (error) throw error;
      
      setEmail(testEmail);
      setPassword(testPassword);
      setName(testName);
      
      setStatus('success');
      
      if (data.user) {
        setCurrentUser(data.user);
        addLog('Usuário de teste criado com sucesso!');
        addLog(`Email: ${testEmail}`);
        addLog(`Senha: ${testPassword}`);
        addLog(`ID: ${data.user.id}`);
      } else {
        addLog('Email de confirmação enviado para o usuário de teste.');
      }
    } catch (err: any) {
      setStatus('error');
      setErrorMessage(err.message);
      addLog(`ERRO: ${err.message}`);
    }
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Teste de Autenticação</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {/* Formulário de login/cadastro */}
            <div className="grid gap-4">
              <div className="grid gap-2">
                <Label htmlFor="email">Email</Label>
                <Input
                  id="email"
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="seu@email.com"
                />
              </div>
              
              <div className="grid gap-2">
                <Label htmlFor="password">Senha</Label>
                <Input
                  id="password"
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="********"
                />
              </div>
              
              <div className="grid gap-2">
                <Label htmlFor="name">Nome (apenas para cadastro)</Label>
                <Input
                  id="name"
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="Seu nome completo"
                />
              </div>
            </div>
            
            {/* Botões de ação */}
            <div className="flex flex-wrap gap-2">
              <Button
                onClick={signIn}
                disabled={status === 'loading' || !email || !password}
                className="bg-blue-600 hover:bg-blue-700"
              >
                {status === 'loading' ? 'Processando...' : 'Entrar'}
              </Button>
              
              <Button
                onClick={signUp}
                disabled={status === 'loading' || !email || !password || !name}
                className="bg-green-600 hover:bg-green-700"
              >
                Cadastrar
              </Button>
              
              <Button
                onClick={signOut}
                disabled={status === 'loading' || !currentUser}
                className="bg-red-600 hover:bg-red-700"
              >
                Sair
              </Button>
              
              <Button
                onClick={checkSession}
                disabled={status === 'loading'}
                className="bg-gray-600 hover:bg-gray-700"
              >
                Verificar Sessão
              </Button>
              
              <Button
                onClick={createTestUser}
                disabled={status === 'loading'}
                className="bg-purple-600 hover:bg-purple-700"
              >
                Criar Usuário de Teste
              </Button>
            </div>
            
            {/* Status atual */}
            {currentUser && (
              <div className="bg-green-100 p-4 rounded-md">
                <h3 className="font-medium">Usuário atual:</h3>
                <p>Email: {currentUser.email}</p>
                <p>ID: {currentUser.id}</p>
              </div>
            )}
            
            {errorMessage && (
              <div className="bg-red-100 p-4 rounded-md text-red-700">
                <h3 className="font-medium">Erro:</h3>
                <p>{errorMessage}</p>
              </div>
            )}
          </div>
        </CardContent>
      </Card>
      
      {/* Log de execução */}
      <Card>
        <CardHeader>
          <CardTitle>Log de Execução</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="bg-gray-100 p-4 rounded h-60 overflow-y-auto font-mono text-sm">
            {log.map((entry, index) => (
              <div key={index} className="mb-1">{entry}</div>
            ))}
            {log.length === 0 && <div className="text-gray-500">Nenhum log disponível</div>}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="app/test/auth/page.tsx">
import AuthenticationTest from './auth-test';

export const metadata = {
  title: 'Teste de Autenticação',
  description: 'Ferramenta para testar a autenticação de usuários no Supabase',
};

export default function AuthTestPage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-blue-800 text-white p-4">
        <div className="max-w-7xl mx-auto flex justify-between items-center">
          <h1 className="text-2xl font-bold">Teste de Autenticação</h1>
        </div>
      </header>
      
      <main className="max-w-7xl mx-auto py-8 px-4">
        <AuthenticationTest />
      </main>
    </div>
  );
}
</file>

<file path="app/test/supabase/page.tsx">
import SupabaseConnectionTest from '../supabase-connection-test';

export const metadata = {
  title: 'Teste de Conexão Supabase',
  description: 'Ferramenta de diagnóstico para verificar a conexão com o Supabase e existência de tabelas',
};

export default function SupabaseTestPage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-blue-800 text-white p-4">
        <div className="max-w-7xl mx-auto flex justify-between items-center">
          <h1 className="text-2xl font-bold">Teste do Supabase</h1>
        </div>
      </header>
      
      <main className="max-w-7xl mx-auto py-8 px-4">
        <SupabaseConnectionTest />
      </main>
    </div>
  );
}
</file>

<file path="app/test/integration-test.tsx">
'use client';

import { useState, useEffect } from 'react';
import { TestHelper } from '../lib/testHelper';
import { createClient } from '../lib/supabase';

export default function IntegrationTest() {
  const [testStatus, setTestStatus] = useState<'idle' | 'running' | 'complete' | 'error'>('idle');
  const [results, setResults] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);
  const [testUserId, setTestUserId] = useState<string>('test-user-1');
  const [log, setLog] = useState<string[]>([]);

  const addLog = (message: string) => {
    setLog((prev) => [...prev, `[${new Date().toISOString()}] ${message}`]);
  };

  const clearLog = () => setLog([]);

  const runTest = async () => {
    clearLog();
    setTestStatus('running');
    setResults(null);
    setError(null);
    
    const testHelper = new TestHelper();
    
    try {
      addLog('Iniciando testes de integração...');
      
      // Teste 1: Verificar status de sincronização inicial
      addLog('Verificando status de sincronização inicial...');
      const initialStatus = await testHelper.getSyncStatus(testUserId);
      addLog(`Status inicial: ${JSON.stringify(initialStatus)}`);
      
      // Teste 2: Simular alterações offline em dois dispositivos
      addLog('Simulando alterações offline em diferentes dispositivos...');
      const syncTest = await testHelper.testSyncBetweenDevices(testUserId, 2);
      addLog(`Teste de sincronização completo: ${JSON.stringify(syncTest.finalReport)}`);
      
      // Teste 3: Criar um conflito e resolver
      addLog('Verificando a resolução de conflitos...');
      const conflicts = syncTest.resolution;
      addLog(`Resolução de conflitos: ${JSON.stringify(conflicts)}`);
      
      // Teste 4: Obter dados do usuário de teste
      addLog('Obtendo dados do usuário de teste...');
      const userData = await testHelper.getTestUserData(testUserId);
      
      // Montar resultados completos
      const testResults = {
        initialStatus,
        syncTest,
        userData: {
          priorities: userData.priorities?.length || 0,
          sleepRecords: userData.sleepRecords?.length || 0,
          medications: userData.medications?.length || 0
        },
        timestamp: new Date().toISOString()
      };
      
      addLog('Testes concluídos com sucesso!');
      setResults(testResults);
      setTestStatus('complete');
    } catch (err: any) {
      addLog(`ERRO: ${err.message}`);
      setError(err.message);
      setTestStatus('error');
    }
  };

  const resetTestData = async () => {
    setTestStatus('running');
    const testHelper = new TestHelper();
    
    try {
      addLog('Limpando dados de teste...');
      const result = await testHelper.clearTestData();
      addLog(`Limpeza concluída: ${JSON.stringify(result)}`);
      setTestStatus('idle');
    } catch (err: any) {
      addLog(`ERRO durante limpeza: ${err.message}`);
      setError(err.message);
      setTestStatus('error');
    }
  };

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Teste de Integração com Backend</h1>
      
      <div className="mb-6">
        <label className="block text-sm font-medium mb-2">
          ID do Usuário de Teste:
          <input 
            type="text" 
            value={testUserId} 
            onChange={(e) => setTestUserId(e.target.value)}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm"
          />
        </label>
      </div>
      
      <div className="flex gap-4 mb-6">
        <button
          onClick={runTest}
          disabled={testStatus === 'running'}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400"
        >
          {testStatus === 'running' ? 'Executando...' : 'Executar Testes'}
        </button>
        
        <button
          onClick={resetTestData}
          disabled={testStatus === 'running'}
          className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 disabled:bg-gray-400"
        >
          Limpar Dados de Teste
        </button>
      </div>
      
      {/* Status dos testes */}
      {testStatus !== 'idle' && (
        <div className={`p-4 mb-6 rounded ${
          testStatus === 'running' ? 'bg-yellow-100' : 
          testStatus === 'complete' ? 'bg-green-100' : 
          'bg-red-100'
        }`}>
          <h2 className="font-bold mb-2">
            {testStatus === 'running' ? 'Executando testes...' : 
             testStatus === 'complete' ? 'Testes concluídos com sucesso!' : 
             'Erro durante os testes'}
          </h2>
          
          {error && <p className="text-red-600">{error}</p>}
        </div>
      )}
      
      {/* Log de execução */}
      <div className="mb-6">
        <h2 className="text-xl font-semibold mb-2">Log de Execução:</h2>
        <div className="bg-gray-100 p-4 rounded h-60 overflow-y-auto font-mono text-sm">
          {log.map((entry, index) => (
            <div key={index} className="mb-1">{entry}</div>
          ))}
          {log.length === 0 && <div className="text-gray-500">Nenhum log disponível</div>}
        </div>
      </div>
      
      {/* Resultados */}
      {results && (
        <div className="mt-6">
          <h2 className="text-xl font-semibold mb-2">Resultados:</h2>
          <div className="bg-white p-4 border rounded shadow">
            <pre className="whitespace-pre-wrap">{JSON.stringify(results, null, 2)}</pre>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/test/page.tsx">
import Link from 'next/link';
import IntegrationTest from './integration-test';

export const metadata = {
  title: 'Testes de Integração',
  description: 'Ambiente de teste para integração com backend Supabase',
};

export default function TestPage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-blue-800 text-white p-4">
        <div className="max-w-7xl mx-auto flex justify-between items-center">
          <h1 className="text-2xl font-bold">Modo de Teste</h1>
          <nav>
            <ul className="flex space-x-4">
              <li>
                <Link href="/" className="hover:text-blue-200">
                  Início
                </Link>
              </li>
              <li>
                <Link href="/dashboard" className="hover:text-blue-200">
                  Dashboard
                </Link>
              </li>
              <li>
                <Link href="/test/supabase" className="hover:text-blue-200">
                  Teste Supabase
                </Link>
              </li>
              <li>
                <Link href="/test/auth" className="hover:text-blue-200">
                  Teste Autenticação
                </Link>
              </li>
            </ul>
          </nav>
        </div>
      </header>
      
      <main className="max-w-7xl mx-auto py-8 px-4">
        <div className="bg-white shadow-md rounded-lg overflow-hidden mb-8">
          <div className="p-6">
            <h2 className="text-xl font-semibold mb-4">Ambiente de Testes</h2>
            <p className="text-gray-600 mb-4">
              Esta página contém ferramentas para testar a integração entre o frontend e o backend no Supabase.
              Use os testes abaixo para validar a sincronização de dados, tratamento de conflitos e outras funcionalidades.
            </p>
            
            <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
              <div className="flex">
                <div className="flex-shrink-0">
                  <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                  </svg>
                </div>
                <div className="ml-3">
                  <p className="text-sm text-yellow-700">
                    <strong>Atenção:</strong> Estes testes manipulam dados reais no banco de dados. 
                    Use apenas em ambientes de desenvolvimento ou teste.
                  </p>
                </div>
              </div>
            </div>
            
            <div className="mb-6">
              <h3 className="font-medium text-lg mb-2">Testes Disponíveis</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <Link href="/test/supabase" className="bg-blue-50 border border-blue-200 p-4 rounded-md hover:bg-blue-100 transition-colors">
                  <div className="font-semibold text-blue-800">Teste de Conexão Supabase</div>
                  <p className="text-sm text-gray-600">Verifique a conexão com o Supabase e a existência das tabelas necessárias</p>
                </Link>
                
                <Link href="/test/auth" className="bg-green-50 border border-green-200 p-4 rounded-md hover:bg-green-100 transition-colors">
                  <div className="font-semibold text-green-800">Teste de Autenticação</div>
                  <p className="text-sm text-gray-600">Teste o registro e login de usuários no Supabase</p>
                </Link>
                
                <div className="bg-gray-50 border border-gray-200 p-4 rounded-md">
                  <div className="font-semibold text-gray-800">Teste de Sincronização</div>
                  <p className="text-sm text-gray-600">Disponível abaixo - Valide a sincronização de dados entre dispositivos</p>
                </div>
              </div>
            </div>
          </div>
          
          <div className="border-t border-gray-200">
            <IntegrationTest />
          </div>
        </div>
        
        <div className="bg-white shadow-md rounded-lg overflow-hidden">
          <div className="p-6">
            <h2 className="text-xl font-semibold mb-4">Documentação dos Testes</h2>
            
            <h3 className="font-medium text-lg mt-6 mb-2">Schema de Teste</h3>
            <p className="text-gray-600 mb-2">
              O arquivo <code className="bg-gray-100 px-1 py-0.5 rounded">sql/test_data.sql</code> contém:
            </p>
            <ul className="list-disc pl-6 mb-4 text-gray-600">
              <li>Inserções de dados para perfis de teste</li>
              <li>Dados de prioridades, registros de sono, lembretes</li>
              <li>Registros de humor e medicações de teste</li>
              <li>Função para criar usuários de teste automaticamente</li>
              <li>Função para limpar todos os dados de teste</li>
            </ul>
            
            <h3 className="font-medium text-lg mt-6 mb-2">Funções de Teste</h3>
            <p className="text-gray-600 mb-2">
              O arquivo <code className="bg-gray-100 px-1 py-0.5 rounded">sql/test_functions.sql</code> contém:
            </p>
            <ul className="list-disc pl-6 mb-4 text-gray-600">
              <li>Função para verificar o status de sincronização</li>
              <li>Função para simular operações offline</li>
              <li>Função para simular conflitos de sincronização</li>
              <li>Função para resolver conflitos</li>
              <li>Função para gerar relatórios de teste</li>
            </ul>
            
            <h3 className="font-medium text-lg mt-6 mb-2">Helper de Testes</h3>
            <p className="text-gray-600 mb-2">
              O arquivo <code className="bg-gray-100 px-1 py-0.5 rounded">app/lib/testHelper.ts</code> contém:
            </p>
            <ul className="list-disc pl-6 text-gray-600">
              <li>Métodos para interagir com as funções SQL de teste</li>
              <li>Utilitários para simulação de sincronização</li>
              <li>Função para testar sincronização entre dispositivos</li>
              <li>Método para limpar dados de teste</li>
            </ul>
          </div>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="app/test/supabase-connection-test.tsx">
'use client';

import { useState, useEffect } from 'react';
import { createClient } from '@/app/lib/supabase';
import { Card, CardHeader, CardTitle, CardContent } from '@/app/components/ui/Card';
import { Button } from '@/app/components/ui/Button';

export default function SupabaseConnectionTest() {
  const [connectionStatus, setConnectionStatus] = useState<'idle' | 'testing' | 'success' | 'error'>('idle');
  const [tableCheckResults, setTableCheckResults] = useState<{table: string, exists: boolean}[]>([]);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [log, setLog] = useState<string[]>([]);

  const addLog = (message: string) => {
    setLog((prev) => [...prev, `[${new Date().toISOString()}] ${message}`]);
  };

  const clearLog = () => setLog([]);

  const testConnection = async () => {
    clearLog();
    setConnectionStatus('testing');
    setTableCheckResults([]);
    setErrorMessage(null);
    
    try {
      const supabase = createClient();
      addLog('Iniciando teste de conexão com o Supabase...');
      
      // Teste básico de conexão
      const { data, error } = await supabase.from('profiles').select('count()', { count: 'exact', head: true });
      
      if (error) {
        throw new Error(`Erro na conexão: ${error.message}`);
      }
      
      addLog('Conexão com o Supabase estabelecida com sucesso!');
      setConnectionStatus('success');
      
      // Verificar existência das tabelas
      const tables = [
        'profiles',
        'priorities',
        'sleep_records',
        'sleep_reminders',
        'mood_records',
        'medications',
        'medication_doses',
        'meals',
        'meal_plans',
        'hydration',
        'expenses',
        'envelopes',
        'payments',
        'hyperfocuses',
        'hyperfocus_tasks',
        'study_sessions',
        'leisure_activities',
        'leisure_sessions',
        'self_knowledge_notes'
      ];
      
      addLog('Verificando existência das tabelas...');
      
      for (const table of tables) {
        try {
          // Tenta fazer uma consulta na tabela
          const { count, error: tableError } = await supabase
            .from(table)
            .select('*', { count: 'exact', head: true });
          
          const exists = !tableError;
          setTableCheckResults(prev => [...prev, { table, exists }]);
          
          if (exists) {
            addLog(`✅ Tabela '${table}' existe`);
          } else {
            addLog(`❌ Tabela '${table}' não existe: ${tableError.message}`);
          }
        } catch (err: any) {
          setTableCheckResults(prev => [...prev, { table, exists: false }]);
          addLog(`❌ Erro ao verificar tabela '${table}': ${err.message}`);
        }
      }
      
    } catch (err: any) {
      setConnectionStatus('error');
      setErrorMessage(err.message);
      addLog(`ERRO: ${err.message}`);
    }
  };

  const testCreateTable = async () => {
    setConnectionStatus('testing');
    try {
      const supabase = createClient();
      addLog('Tentando criar tabelas prioritárias...');
      
      // Verificar se pode executar operações de DDL
      const { data: rpcResult, error: rpcError } = await supabase.rpc(
        'create_test_tables',
        {}
      );
      
      if (rpcError) {
        // Se não conseguir usar RPC, tenta consultar diretamente
        addLog(`Erro ao usar RPC: ${rpcError.message}`);
        addLog('Verificando permissões para criar tabelas...');
        
        const { data: authData } = await supabase.auth.getSession();
        addLog(`Status de autenticação: ${authData.session ? 'Autenticado' : 'Não autenticado'}`);
        
        if (authData.session) {
          addLog(`Usuário: ${authData.session.user.email}`);
          addLog(`Perfil: ${authData.session.user.id}`);
        }
        
        throw new Error('Sem permissão para criar tabelas diretamente. Um administrador deve criar as tabelas no painel do Supabase.');
      }
      
      addLog('Tabelas criadas com sucesso!');
      setConnectionStatus('success');
      
      // Verificar novamente as tabelas
      testConnection();
      
    } catch (err: any) {
      setErrorMessage(err.message);
      addLog(`ERRO: ${err.message}`);
      setConnectionStatus('error');
    }
  };

  return (
    <div className="space-y-6 p-4">
      <Card>
        <CardHeader>
          <CardTitle>Teste de Conexão com Supabase</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col gap-4">
            <div className="flex gap-4">
              <Button 
                onClick={testConnection}
                disabled={connectionStatus === 'testing'}
                className="bg-blue-600 hover:bg-blue-700"
              >
                {connectionStatus === 'testing' ? 'Testando...' : 'Testar Conexão'}
              </Button>
              
              <Button 
                onClick={testCreateTable}
                disabled={connectionStatus === 'testing'}
                className="bg-green-600 hover:bg-green-700"
              >
                Tentar Criar Tabelas
              </Button>
            </div>
            
            {/* Status da conexão */}
            {connectionStatus !== 'idle' && (
              <div className={`p-4 rounded ${
                connectionStatus === 'testing' ? 'bg-yellow-100' : 
                connectionStatus === 'success' ? 'bg-green-100' : 
                'bg-red-100'
              }`}>
                <h2 className="font-bold mb-2">
                  {connectionStatus === 'testing' ? 'Testando conexão...' : 
                   connectionStatus === 'success' ? 'Conexão estabelecida com sucesso!' : 
                   'Erro na conexão'}
                </h2>
                
                {errorMessage && <p className="text-red-600">{errorMessage}</p>}
              </div>
            )}
            
            {/* Log de execução */}
            <div>
              <h2 className="text-lg font-semibold mb-2">Log de Execução:</h2>
              <div className="bg-gray-100 p-4 rounded h-60 overflow-y-auto font-mono text-sm">
                {log.map((entry, index) => (
                  <div key={index} className="mb-1">{entry}</div>
                ))}
                {log.length === 0 && <div className="text-gray-500">Nenhum log disponível</div>}
              </div>
            </div>
            
            {/* Resultados da verificação de tabelas */}
            {tableCheckResults.length > 0 && (
              <div>
                <h2 className="text-lg font-semibold mb-2">Status das Tabelas:</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                  {tableCheckResults.map(({ table, exists }, index) => (
                    <div 
                      key={index} 
                      className={`p-2 rounded ${exists ? 'bg-green-100' : 'bg-red-100'}`}
                    >
                      <span className="font-medium">{table}:</span> {exists ? '✅ Existe' : '❌ Não existe'}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader>
          <CardTitle>Solução de Problemas</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div>
              <h3 className="font-medium text-lg">Tabelas não existem?</h3>
              <p className="text-gray-600">
                Se as tabelas não existem, há duas soluções possíveis:
              </p>
              <ul className="list-disc pl-6 mt-2 text-gray-600">
                <li>Acesse o painel de administração do Supabase e execute os scripts SQL para criar as tabelas</li>
                <li>Verifique se a aplicação tem as permissões necessárias para criar tabelas via RPC</li>
                <li>Confirme que está usando a URL e a chave anônima corretas do Supabase</li>
              </ul>
            </div>
            
            <div>
              <h3 className="font-medium text-lg">Erro de conexão?</h3>
              <p className="text-gray-600">
                Se houver erro na conexão, verifique:
              </p>
              <ul className="list-disc pl-6 mt-2 text-gray-600">
                <li>Valores corretos de NEXT_PUBLIC_SUPABASE_URL e NEXT_PUBLIC_SUPABASE_ANON_KEY no arquivo .env</li>
                <li>Se o projeto Supabase está ativo e acessível</li>
                <li>Se há restrições de CORS que impedem a conexão</li>
              </ul>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="app/types/index.ts">
// Tipos compartilhados para todo o aplicativo

// Categorias principais do aplicativo
export type Categoria = 'inicio' | 'alimentacao' | 'estudos' | 'saude' | 'lazer' | 'nenhuma'

// Opções de humor para o monitor de humor
export type OpcaoHumor = 'otimo' | 'bom' | 'neutro' | 'baixo' | 'ruim'

// Interface para atividades de lazer
export type AtividadeLazer = {
  id: string
  nome: string
  descricao: string
  duracao: number // em minutos
  categoria: 'ativo' | 'passivo' | 'criativo' | 'social'
}

// Interface para materiais de estudo
export type MaterialEstudo = {
  id: string
  titulo: string
  tipo: 'livro' | 'video' | 'artigo' | 'exercicio' | 'outro'
  url?: string
  progresso: number // 0-100
  notas?: string
}

// Interface para registro de humor
export type RegistroHumor = {
  id: string
  data: string // formato YYYY-MM-DD
  humor: OpcaoHumor
  notas?: string
}

// Interface para lembretes
export type Lembrete = {
  id: string
  titulo: string
  descricao?: string
  data: string // formato YYYY-MM-DD
  hora: string // formato HH:MM
  recorrente: boolean
  diasRecorrencia?: ('seg' | 'ter' | 'qua' | 'qui' | 'sex' | 'sab' | 'dom')[]
  categoria: Categoria
  completado: boolean
}

// Interface para registro de hidratação
export type RegistroHidratacao = {
  id: string
  data: string // formato YYYY-MM-DD
  quantidade: number // em ml
  hora: string // formato HH:MM
}

// Interface para sessão de estudo
export type SessaoEstudo = {
  id: string
  data: string // formato YYYY-MM-DD
  inicio: string // formato HH:MM
  fim: string // formato HH:MM
  materia: string
  tecnica: 'pomodoro' | 'blocos' | 'livre'
  produtividade: 1 | 2 | 3 | 4 | 5 // escala de 1 a 5
  notas?: string
}
</file>

<file path="app/types/supabase.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      priorities: {
        Row: {
          id: string
          user_id: string
          content: string
          completed: boolean
          due_date: string | null
          created_at: string
          category: string | null
          updated_at: string | null
          version: number
          device_id: string | null
          last_synced_at: string | null
        }
        Insert: {
          id?: string
          user_id: string
          content: string
          completed?: boolean
          due_date?: string | null
          created_at?: string
          category?: string | null
          updated_at?: string | null
          version?: number
          device_id?: string | null
          last_synced_at?: string | null
        }
        Update: {
          id?: string
          user_id?: string
          content?: string
          completed?: boolean
          due_date?: string | null
          created_at?: string
          category?: string | null
          updated_at?: string | null
          version?: number
          device_id?: string | null
          last_synced_at?: string | null
        }
      }
      profiles: {
        Row: {
          id: string
          updated_at: string | null
          username: string | null
          full_name: string | null
          email: string
          preferences: Json | null
        }
        Insert: {
          id: string
          updated_at?: string | null
          username?: string | null
          full_name?: string | null
          email: string
          preferences?: Json | null
        }
        Update: {
          id?: string
          updated_at?: string | null
          username?: string | null
          full_name?: string | null
          email?: string
          preferences?: Json | null
        }
      }
      sleep_records: {
        Row: {
          id: string
          user_id: string
          start_time: string
          end_time: string | null
          quality: number | null
          notes: string | null
          created_at: string
          updated_at: string | null
        }
        Insert: {
          id?: string
          user_id: string
          start_time: string
          end_time?: string | null
          quality?: number | null
          notes?: string | null
          created_at?: string
          updated_at?: string | null
        }
        Update: {
          id?: string
          user_id?: string
          start_time?: string
          end_time?: string | null
          quality?: number | null
          notes?: string | null
          created_at?: string
          updated_at?: string | null
        }
      }
      sleep_reminders: {
        Row: {
          id: string
          user_id: string
          type: string
          time: string
          days_of_week: number[]
          active: boolean
          created_at: string
          updated_at: string | null
        }
        Insert: {
          id?: string
          user_id: string
          type: string
          time: string
          days_of_week: number[]
          active?: boolean
          created_at?: string
          updated_at?: string | null
        }
        Update: {
          id?: string
          user_id?: string
          type?: string
          time?: string
          days_of_week?: number[]
          active?: boolean
          created_at?: string
          updated_at?: string | null
        }
      }
      mood_records: {
        Row: {
          id: string
          user_id: string
          record_date: string
          mood_level: number
          factors: string[]
          notes: string | null
          created_at: string
          updated_at: string | null
        }
        Insert: {
          id?: string
          user_id: string
          record_date: string
          mood_level: number
          factors?: string[]
          notes?: string | null
          created_at?: string
          updated_at?: string | null
        }
        Update: {
          id?: string
          user_id?: string
          record_date?: string
          mood_level?: number
          factors?: string[]
          notes?: string | null
          created_at?: string
          updated_at?: string | null
        }
      }
      medications: {
        Row: {
          id: string
          user_id: string
          name: string
          dosage: string | null
          frequency: string
          schedule: string[]
          start_date: string | null
          notes: string | null
          last_taken: string | null
          interval_minutes: number | null
          observation: string | null
          created_at: string
          updated_at: string | null
        }
        Insert: {
          id?: string
          user_id: string
          name: string
          dosage?: string | null
          frequency: string
          schedule?: string[]
          start_date?: string | null
          notes?: string | null
          last_taken?: string | null
          interval_minutes?: number | null
          observation?: string | null
          created_at?: string
          updated_at?: string | null
        }
        Update: {
          id?: string
          user_id?: string
          name?: string
          dosage?: string | null
          frequency?: string
          schedule?: string[]
          start_date?: string | null
          notes?: string | null
          last_taken?: string | null
          interval_minutes?: number | null
          observation?: string | null
          created_at?: string
          updated_at?: string | null
        }
      }
      medication_doses: {
        Row: {
          id: string
          medication_id: string
          user_id: string
          taken_at: string
          scheduled_time: string | null
          notes: string | null
          created_at: string
        }
        Insert: {
          id?: string
          medication_id: string
          user_id: string
          taken_at: string
          scheduled_time?: string | null
          notes?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          medication_id?: string
          user_id?: string
          taken_at?: string
          scheduled_time?: string | null
          notes?: string | null
          created_at?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
  }
}

export type Tables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Row'];

export type InsertTables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Insert'];
  
export type UpdateTables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Update'];

export type Profile = Tables<'profiles'>;
export type Priority = Tables<'priorities'>;
export type SleepRecord = Tables<'sleep_records'>;
export type SleepReminder = Tables<'sleep_reminders'>;
export type MoodRecord = Tables<'mood_records'>;
export type Medication = Tables<'medications'>;
export type MedicationDose = Tables<'medication_doses'>;

export type NewPriority = Omit<InsertTables<'priorities'>, 'id' | 'user_id' | 'created_at' | 'updated_at'>;
export type PriorityUpdate = Partial<Omit<UpdateTables<'priorities'>, 'id' | 'user_id' | 'created_at'>>;

export type NewSleepRecord = Omit<InsertTables<'sleep_records'>, 'id' | 'user_id' | 'created_at' | 'updated_at'>;
export type SleepRecordUpdate = Partial<Omit<UpdateTables<'sleep_records'>, 'id' | 'user_id' | 'created_at'>>;

export type NewSleepReminder = Omit<InsertTables<'sleep_reminders'>, 'id' | 'user_id' | 'created_at' | 'updated_at'>;
export type SleepReminderUpdate = Partial<Omit<UpdateTables<'sleep_reminders'>, 'id' | 'user_id' | 'created_at'>>;

export type NewMoodRecord = Omit<InsertTables<'mood_records'>, 'id' | 'user_id' | 'created_at' | 'updated_at'>;
export type MoodRecordUpdate = Partial<Omit<UpdateTables<'mood_records'>, 'id' | 'user_id' | 'created_at'>>;

export type NewMedication = Omit<InsertTables<'medications'>, 'id' | 'user_id' | 'created_at' | 'updated_at'>;
export type MedicationUpdate = Partial<Omit<UpdateTables<'medications'>, 'id' | 'user_id' | 'created_at'>>;

export type NewMedicationDose = Omit<InsertTables<'medication_doses'>, 'id' | 'user_id' | 'created_at'>;
export type MedicationDoseUpdate = Partial<Omit<UpdateTables<'medication_doses'>, 'id' | 'user_id' | 'created_at'>>;

export interface BaseItem {
  id: string
  created_at: string
  updated_at: string
  user_id: string
  version: number
  is_deleted: boolean
}

export interface PriorityItem extends BaseItem {
  title: string
  description: string
  due_date: string
  status: 'pending' | 'completed'
  priority: 'low' | 'medium' | 'high'
}

export interface MedicationItem extends BaseItem {
  name: string
  dosage: string
  frequency: string
  time: string
  notes: string
  status: 'active' | 'inactive'
}

export interface MoodRecordItem extends BaseItem {
  mood: 'great' | 'good' | 'neutral' | 'bad' | 'terrible'
  notes: string
  date: string
  energy_level: number
  anxiety_level: number
  sleep_quality: number
}

export interface SleepRecordItem extends BaseItem {
  start_time: string
  end_time: string
  duration: number
  quality: number
  notes: string
  date: string
}

// Tipos para migração de dados
export interface MigrationResult {
  success: boolean;
  count: number;
  duplicates?: number;
  error?: string;
}
</file>

<file path="app/config.ts">
export const dynamic = 'force-dynamic'
export const runtime = 'edge'
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
  }

  body {
    @apply text-gray-900 dark:text-white;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
  
  /* Estilos para acessibilidade */
  .alto-contraste {
    --contrast-factor: 1.5;
  }
  
  .alto-contraste .text-gray-500,
  .alto-contraste .text-gray-400,
  .alto-contraste .text-gray-300 {
    @apply text-gray-900 dark:text-white;
  }
  
  .alto-contraste .bg-gray-50,
  .alto-contraste .bg-gray-100,
  .alto-contraste .bg-gray-200 {
    @apply bg-white dark:bg-gray-900;
  }
  
  .reducao-estimulos * {
    transition: none !important;
    animation: none !important;
  }
  
  .reducao-estimulos .bg-opacity-90,
  .reducao-estimulos .bg-opacity-80,
  .reducao-estimulos .bg-opacity-70 {
    @apply bg-opacity-100;
  }
  
  .texto-grande {
    font-size: 1.1rem;
  }
  
  .texto-grande h1 {
    font-size: 2.5rem;
  }
  
  .texto-grande h2 {
    font-size: 2rem;
  }
  
  .texto-grande h3 {
    font-size: 1.5rem;
  }
  
  .texto-grande input,
  .texto-grande button {
    font-size: 1.1rem;
  }
  
  /* Animações para o Toast */
  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(1rem);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  .animate-fade-in-up {
    animation: fadeInUp 0.3s ease-out;
  }
}

@layer components {
  .focus-ring {
    @apply focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-blue-500 dark:focus-visible:ring-blue-400;
  }
  
  .card {
    @apply bg-white dark:bg-gray-800 rounded-xl shadow-md p-4 transition-all duration-200;
  }
  
  .btn {
    @apply px-4 py-2 rounded-lg font-medium transition-colors duration-200 focus-ring;
  }
  
  .btn-primary {
    @apply bg-blue-600 hover:bg-blue-700 text-white;
  }
  
  .btn-secondary {
    @apply bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-900 dark:text-gray-100;
  }
  
  .input {
    @apply px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg focus-ring;
  }
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from 'next'
import './globals.css'
import { Header } from '@/app/components/layout/Header'
import { Footer } from '@/app/components/layout/Footer'
import { Providers } from '@/app/providers'
import { SpeedInsights } from '@vercel/speed-insights/next'

export const metadata: Metadata = {
  title: 'StayFocus',
  description: 'Aplicativo para ajudar pessoas neurodivergentes com organização e produtividade',
  icons: {
    icon: [
      { url: '/favicon.svg', type: 'image/svg+xml' },
      { url: '/favicon.ico', sizes: 'any' },
      { url: '/favicon.png', type: 'image/png' }
    ],
    apple: '/images/logo.svg',
  },
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="pt-BR" suppressHydrationWarning>
      <body className="bg-gray-50 dark:bg-gray-900">
        <Providers>
          <div className="flex h-screen overflow-hidden">
            <div className="flex flex-col flex-1 overflow-hidden">
              <Header />
              <main className="flex-1 overflow-y-auto p-4">
                {children}
                <Footer />
              </main>
            </div>
          </div>
        </Providers>
        <SpeedInsights />
      </body>
    </html>
  )
}
</file>

<file path="app/page.tsx">
export const dynamic = 'force-dynamic';

import { Card, CardHeader, CardTitle, CardContent } from '@/app/components/ui/Card'
import { PainelDia } from '@/app/components/inicio/PainelDia'
import { ListaPrioridades } from '@/app/components/inicio/ListaPrioridades'
import { LembretePausas } from '@/app/components/inicio/LembretePausas'
import { ChecklistMedicamentos } from '@/app/components/inicio/ChecklistMedicamentos'

export default function HomePage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Início</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* Painel Visual do Dia */}
        <div className="md:col-span-2">
          <Card>
            <CardHeader>
              <CardTitle>Painel do Dia</CardTitle>
            </CardHeader>
            <CardContent>
              <PainelDia />
            </CardContent>
          </Card>
        </div>
        
        {/* Lista de Prioridades */}
        <div>
          <Card>
            <CardHeader>
              <CardTitle>Prioridades do Dia</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-6">
                <ListaPrioridades />
                
                {/* Separador */}
                <div className="border-t border-gray-200 dark:border-gray-700 my-2"></div>
                
                {/* Checklist de Medicamentos Diários */}
                <ChecklistMedicamentos />
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
      
      {/* Lembretes de Pausas */}
      <Card>
        <CardHeader>
          <CardTitle>Lembretes de Pausas</CardTitle>
        </CardHeader>
        <CardContent>
          <LembretePausas />
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/providers.tsx">
'use client'

import { StrictMode } from 'react'
import { ThemeProvider as NextThemesProvider } from 'next-themes'
import { type ThemeProviderProps } from 'next-themes/dist/types'
import { AuthProvider } from './context/AuthContext'
import { ToastProvider } from './context/ToastContext'
import { SupabaseProvider } from './components/providers/supabase-provider'
import { ReactNode } from 'react'

type ProvidersProps = ThemeProviderProps & {
  children: ReactNode
}

export function Providers({ children, ...props }: ProvidersProps) {
  return (
    <StrictMode>
      <SupabaseProvider>
        <NextThemesProvider attribute="class" defaultTheme="system" enableSystem {...props}>
          <AuthProvider>
            <ToastProvider>
              {children}
            </ToastProvider>
          </AuthProvider>
        </NextThemesProvider>
      </SupabaseProvider>
    </StrictMode>
  )
}
</file>

<file path="memory-bank/core/activeContext.md">
# Contexto Ativo - MyNeuroApp

**Status**: [CURRENT] | Última atualização: 23/09/2023 | Versão: 1.2

## Introdução
Este documento contém o contexto atual de desenvolvimento do MyNeuroApp, destacando o foco de trabalho atual, decisões recentes, e próximos passos planejados.

## Resumo Executivo
Atualmente, o foco principal é a migração do armazenamento de dados do localStorage para o Supabase, permitindo sincronização entre dispositivos e melhor segurança dos dados dos usuários neurodivergentes. A migração progrediu satisfatoriamente, com os módulos de Prioridades, Sono e Humor já migrados. O próximo passo é a migração do módulo de Medicamentos, seguida pela implementação de funcionalidades de exportação de dados.

## Pontos-Chave
- Migração para Supabase alcançou 75% de conclusão, com três dos quatro módulos já migrados
- Módulo de Medicamentos selecionado como foco atual para completar a migração
- Planejamento para funcionalidades de exportação de dados iniciado
- Necessidade de refatoração identificada para reduzir duplicação de código nos hooks
- Experiência offline comprometida pela migração, necessitando implementação posterior

## Foco Atual

### Migração para Supabase
Estamos implementando a migração do armazenamento local para o Supabase, seguindo o plano documentado em `specialized/migracao_supabase.md`. O trabalho atual concentra-se nas seguintes fases:

#### Concluído:
- ✅ **Fase 1: Configuração Inicial**
  - Projeto criado no Supabase
  - Dependências instaladas no projeto
  - Variáveis de ambiente configuradas

- ✅ **Fase 2: Estruturação do Banco de Dados**
  - Tabelas principais criadas
  - Políticas de segurança RLS implementadas
  - Triggers para criação automática de perfil configurados

- ✅ **Fase 3: Implementação da Autenticação**
  - Páginas de login e registro implementadas
  - Middleware para proteção de rotas configurado
  - Provider de autenticação implementado

- ✅ **Fase 4: Adaptação dos Componentes**
  - Componentes atualizados para refletir estado de autenticação
  - Feedback visual para operações assíncronas implementado
  - Navegação adaptada para usuários autenticados/não autenticados

- ✅ **Fase 5: Migração de Dados - Módulo de Prioridades**
  - Hook `usePriorities` implementado
  - Componente de migração de dados criado
  - Interfaces adaptadas para usar Supabase

- ✅ **Fase 5b: Migração de Dados - Módulo de Sono**
  - Hook `useSleep` implementado
  - Componente `SleepDataMigration` criado
  - Interfaces adaptadas para usar Supabase

- ✅ **Fase 5c: Migração de Dados - Módulo de Humor**
  - Hook `useHumor` implementado
  - Componente `MoodDataMigration` criado
  - Interfaces adaptadas para usar Supabase
  - Análise e estatísticas de humor implementadas

#### Em Progresso:
- 🔄 **Fase 5d: Migração de Dados - Módulo de Medicamentos**
  - Definição da estrutura da tabela no Supabase
  - Implementação do hook `useMedications`
  - Desenvolvimento do componente de migração de dados

#### Próximos:
- 📅 **Fase 6: Implementação de Exportação de Dados**
  - Exportação de histórico em CSV e PDF
  - Interface para seleção de período e formato

- 📅 **Fase 7: Refatoração e Otimização**
  - Criação de hook base para redução de duplicação
  - Implementação de estratégia para experiência offline
  - Melhoria de performance para conexões lentas

### Decisões Recentes

1. **Padrão de Análise de Dados** (03/10/2023)
   - Implementação de funções de análise e estatísticas no hook `useHumor`
   - Decisão de aplicar padrão semelhante aos demais módulos
   - Benefício: Valor agregado para usuários e insights sobre seus padrões

2. **Abordagem para Exportação de Dados** (01/10/2023)
   - Decisão por exportação em múltiplos formatos (CSV, PDF)
   - Foco na facilidade de uso para compartilhamento com profissionais de saúde
   - Implementação prevista após conclusão de todas as migrações

3. **Estratégia para Experiência Offline** (27/09/2023)
   - Reconhecimento da necessidade de restaurar funcionalidade offline
   - Decisão por implementação de PWA com sincronização
   - Priorização após conclusão das migrações principais

## Desafios Atuais

1. **Duplicação de Código nos Hooks**
   - Desafio: Padrões semelhantes implementados em cada hook resultam em duplicação
   - Abordagem: Criar hook base genérico que possa ser estendido pelos hooks específicos
   - Status: Planejado para início em 15/10/2023

2. **Migração de Medicamentos com Esquema Complexo**
   - Desafio: O módulo de medicamentos possui estrutura de dados mais complexa
   - Abordagem: Modelagem cuidadosa da tabela e estratégia de migração específica
   - Status: Em análise e desenvolvimento

3. **Testes Insuficientes**
   - Desafio: Cobertura de testes automatizados abaixo da meta
   - Abordagem: Implementar testes para hooks e componentes críticos
   - Status: Planejado para após conclusão das migrações

## Próximos Passos

1. **Completar a Migração do Módulo de Medicamentos** (Prazo: 10/10/2023)
   - Definir esquema da tabela
   - Implementar hook `useMedications`
   - Criar componente `MedicationDataMigration`
   - Adaptar interfaces de usuário

2. **Iniciar Implementação da Exportação de Dados** (Prazo: 15/10/2023)
   - Definir formatos e estrutura dos dados exportados
   - Criar interfaces de seleção e configuração
   - Implementar geração de arquivos e download

3. **Planejar Refatoração dos Hooks** (Prazo: 18/10/2023)
   - Analisar código comum entre hooks
   - Projetar hook base genérico
   - Documentar estratégia de refatoração

4. **Iniciar Testes de Usabilidade** (Prazo: 20/10/2023)
   - Preparar cenários de teste
   - Recrutar usuários para testes
   - Elaborar questionários de feedback

## Feedback e Iteração

Estamos coletando feedback contínuo sobre:
- Experiência de migração (clareza e facilidade)
- Performance das operações com Supabase
- Utilidade das estatísticas e análises implementadas
- Problemas técnicos encontrados durante migração

## Histórico de Revisões

| Data | Versão | Autor | Aprovador | Alterações |
|------|--------|-------|-----------|------------|
| 03/10/2023 | 1.3 | DevTeam | TechLead | Atualização com conclusão da migração do módulo de Humor |
| 23/09/2023 | 1.2 | DevTeam | TechLead | Atualização com progresso da migração Supabase |
| 15/09/2023 | 1.1 | DevTeam | TechLead | Adicionados módulos de sono e medicamentos |
| 01/09/2023 | 1.0 | DevTeam | TechLead | Versão inicial do documento |

## Changelog

- 2023-10-03: Atualização com foco na migração do módulo de Medicamentos (v1.3)
- 2023-09-23: Atualização com foco na migração Supabase (v1.2)
- 2023-09-15: Adição de informações sobre novos módulos (v1.1)
- 2023-09-01: Criação do documento (v1.0)
</file>

<file path="memory-bank/core/architecture.md">
# Arquitetura da Migração para Supabase

## Introdução
Este documento descreve a arquitetura técnica da migração do MyNeuroApp para Supabase, incluindo a estrutura de dados, fluxos de autenticação e padrões de acesso.

## Resumo Executivo
A arquitetura da migração envolve a transição de um modelo de armazenamento local (localStorage) para um sistema de banco de dados relacional gerenciado pelo Supabase, com autenticação de usuários e políticas de segurança em nível de linha (RLS).

## Pontos-Chave
- Autenticação baseada em JWT com Supabase Auth
- Políticas de segurança RLS para proteção de dados
- Hooks React personalizados para acesso a dados
- Migração transparente de dados locais para a nuvem
- Suporte para sincronização offline/online

## Arquitetura de Dados

### Modelo de Dados

```
┌─────────────┐       ┌──────────────┐       ┌───────────────┐
│   profiles  │       │ user_settings │       │   priorities  │
├─────────────┤       ├──────────────┤       ├───────────────┤
│ id (PK)     │───┐   │ id (PK)      │       │ id (PK)       │
│ user_id (FK)│   └──>│ user_id (FK) │       │ user_id (FK)  │
│ name        │       │ theme        │       │ title         │
│ avatar_url  │       │ notifications│       │ description   │
│ created_at  │       │ created_at   │       │ status        │
└─────────────┘       └──────────────┘       │ created_at    │
                                             └───────────────┘
      ┌────────────────┐       ┌───────────────┐
      │  sleep_records  │       │  medications  │
      ├────────────────┤       ├───────────────┤
      │ id (PK)         │       │ id (PK)       │
      │ user_id (FK)    │       │ user_id (FK)  │
      │ date            │       │ name          │
      │ duration        │       │ dosage        │
      │ quality         │       │ frequency     │
      │ notes           │       │ time          │
      │ created_at      │       │ created_at    │
      └────────────────┘       └───────────────┘
                  
      ┌────────────────┐       ┌───────────────┐
      │  mood_records   │       │     studies   │
      ├────────────────┤       ├───────────────┤
      │ id (PK)         │       │ id (PK)       │
      │ user_id (FK)    │       │ user_id (FK)  │
      │ date            │       │ title         │
      │ mood            │       │ description   │
      │ notes           │       │ duration      │
      │ created_at      │       │ completed     │
      └────────────────┘       │ created_at    │
                              └───────────────┘
```

### Políticas de Segurança (RLS)

Todas as tabelas terão as seguintes políticas:

1. **Leitura**: Usuários podem ler apenas seus próprios dados
   ```sql
   CREATE POLICY "Usuários podem ler seus próprios dados" ON [tabela]
   FOR SELECT USING (auth.uid() = user_id);
   ```

2. **Inserção**: Usuários podem inserir apenas seus próprios dados
   ```sql
   CREATE POLICY "Usuários podem inserir seus próprios dados" ON [tabela]
   FOR INSERT WITH CHECK (auth.uid() = user_id);
   ```

3. **Atualização**: Usuários podem atualizar apenas seus próprios dados
   ```sql
   CREATE POLICY "Usuários podem atualizar seus próprios dados" ON [tabela]
   FOR UPDATE USING (auth.uid() = user_id);
   ```

4. **Exclusão**: Usuários podem excluir apenas seus próprios dados
   ```sql
   CREATE POLICY "Usuários podem excluir seus próprios dados" ON [tabela]
   FOR DELETE USING (auth.uid() = user_id);
   ```

## Arquitetura de Autenticação

### Fluxo de Autenticação

```
┌─────────────┐     ┌───────────────┐     ┌─────────────┐
│ Login/Signup│────>│ Supabase Auth │────>│ JWT + User  │
└─────────────┘     └───────────────┘     └─────────────┘
                           │                     │
                           v                     v
                    ┌───────────────┐    ┌──────────────┐
                    │ Auth Provider │───>│ Auth Context │
                    └───────────────┘    └──────────────┘
                                                │
                                                v
                                         ┌──────────────┐
                                         │  Protected   │
                                         │   Routes     │
                                         └──────────────┘
```

### Middleware de Autenticação

O middleware de autenticação protegerá rotas específicas, redirecionando usuários não autenticados:

```typescript
// middleware.ts
export const middleware = async (req: NextRequest) => {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });
  
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session && req.nextUrl.pathname.startsWith('/app')) {
    return NextResponse.redirect(new URL('/auth/login', req.url));
  }

  return res;
};
```

## Arquitetura de Acesso a Dados

### Padrão de Hook

Todos os hooks seguirão o mesmo padrão estrutural:

```typescript
// Exemplo de hook para Prioridades
export function usePriorities() {
  const { supabase, user } = useSupabase();
  const [priorities, setPriorities] = useState<Priority[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  // Carregar dados
  const fetchPriorities = async () => {
    setLoading(true);
    try {
      const { data, error } = await supabase
        .from('priorities')
        .select('*')
        .order('created_at', { ascending: false });
        
      if (error) throw error;
      setPriorities(data || []);
    } catch (e) {
      setError(e as Error);
    } finally {
      setLoading(false);
    }
  };
  
  // Criar item
  const createPriority = async (priority: Omit<Priority, 'id' | 'user_id'>) => {
    try {
      const { data, error } = await supabase
        .from('priorities')
        .insert({ ...priority, user_id: user?.id })
        .select()
        .single();
        
      if (error) throw error;
      setPriorities([data, ...priorities]);
      return data;
    } catch (e) {
      setError(e as Error);
      throw e;
    }
  };
  
  // Atualizar item
  // Excluir item
  
  useEffect(() => {
    if (user) fetchPriorities();
  }, [user]);
  
  return {
    priorities,
    loading,
    error,
    fetchPriorities,
    createPriority,
    updatePriority,
    deletePriority
  };
}
```

### Sincronização Offline/Online

O hook `useSync` gerenciará a sincronização entre dados locais e Supabase:

```typescript
export function useSync() {
  const { supabase, user } = useSupabase();
  const [online, setOnline] = useState<boolean>(typeof window !== 'undefined' ? navigator.onLine : true);
  const [syncQueue, setSyncQueue] = useState<SyncOperation[]>([]);
  
  // Lógica de sincronização 
  // ...
}
```

## Estratégia de Migração de Dados

O processo de migração ocorrerá quando um usuário se registrar ou fizer login pela primeira vez:

1. Obter todos os dados do localStorage
2. Criar usuário e perfil no Supabase
3. Migrar cada tipo de dado (prioridades, sono, medicamentos, etc.)
4. Atualizar localStorage com flag `migrated: true`
5. Redirecionar para o aplicativo

## Considerações de Performance

- Implementação de paginação para tabelas com muitos registros
- Uso de funções RPC para operações complexas
- Cache de dados frequentemente usados
- Estratégia de refetching otimizada

## Feedback e Revisão

Este documento deve ser revisado pela equipe técnica antes da implementação. Ajustes na arquitetura podem ser necessários durante o desenvolvimento.

## Histórico de Revisões

| Versão | Data | Autor | Descrição |
|--------|------|-------|-----------|
| 1.0 | [DATA ATUAL] | [AUTOR] | Versão inicial da arquitetura |
</file>

<file path="memory-bank/core/productContext.md">
# Contexto do Produto

## Status: [CURRENT] | Última Atualização: Data Atual | Versão: 1.0

## Introdução
Este documento esclarece o contexto, a motivação e a proposta de valor do MyNeuroApp, explicando por que ele existe e quais problemas visa resolver para pessoas neurodivergentes.

## Resumo Executivo
O MyNeuroApp foi desenvolvido para preencher uma lacuna significativa no mercado de aplicativos de produtividade, oferecendo uma solução específica para as necessidades de pessoas neurodivergentes. Em vez de adaptar ferramentas genéricas, o MyNeuroApp foi construído desde o início considerando os desafios cognitivos, sensoriais e organizacionais enfrentados por esse público.

## Pontos-Chave [IMPORTANTE]
- Produto criado especificamente para pessoas neurodivergentes
- Baseado em evidências científicas e feedback de usuários
- Abordagem holística para organização e bem-estar
- Interface desenhada para minimizar sobrecarga sensorial
- Funcionalidades modulares para necessidades específicas
- Desenvolvimento guiado pela experiência do usuário

## 1. Problema e Oportunidade

### Problema Fundamental
Pessoas neurodivergentes frequentemente enfrentam desafios únicos na organização de rotinas, gerenciamento de tarefas e autocuidado, incluindo:

- **Sobrecarga Cognitiva**: Dificuldade em processar múltiplas informações simultaneamente
- **Disfunção Executiva**: Desafios no planejamento, iniciação e conclusão de tarefas
- **Regulação Sensorial**: Sensibilidade a estímulos visuais, auditivos ou outros
- **Hiperfoco/Distração**: Dificuldades em alternar entre tarefas ou manter atenção adequada
- **Memória Prospectiva**: Dificuldade em lembrar de executar ações planejadas

### Oportunidade de Mercado
- 15-20% da população mundial apresenta alguma forma de neurodivergência
- Crescente consciência e diagnóstico de condições neurodivergentes em adultos
- Falta de soluções digitais especificamente projetadas para este público
- Aumento na demanda por ferramentas de saúde mental e bem-estar digital

## 2. Proposta de Valor

### Para o Usuário
- **Redução da Carga Cognitiva**: Interface simplificada com foco no essencial
- **Estrutura Adaptável**: Rotinas e visualizações customizáveis
- **Suporte à Função Executiva**: Lembretes contextuais e decomposição de tarefas
- **Autoconhecimento**: Ferramentas para identificar padrões e necessidades pessoais
- **Design Sensorial**: Adaptações visuais e interativas para diferentes preferências

### Diferenciação
- **Especialização**: Foco exclusivo em neurodivergência vs. apps genéricos
- **Abordagem Holística**: Integração de múltiplas áreas da vida vs. ferramentas isoladas
- **Personalização Profunda**: Adaptação a diferentes perfis neurocognitivos
- **Base Científica**: Fundamentado em pesquisas sobre processamento neurodivergente
- **Comunidade**: Espaço para compartilhamento de estratégias entre usuários

## 3. Personas e Casos de Uso

### Carlos (TDAH)
- **Contexto**: Programador, 28 anos, diagnóstico recente
- **Dores**: Esquece compromissos, dificuldade para iniciar tarefas importantes, procrastina
- **Necessidades**: Lembretes eficazes, técnicas para iniciar tarefas, gestão de hiperfoco
- **Caso de Uso**: Usa o MyNeuroApp para planejar seu dia com blocos de tempo, recebe lembretes de pausas durante hiperfoco, e utiliza técnicas de gerenciamento de energia

### Ana (Autismo)
- **Contexto**: Estudante universitária, 19 anos, sensível a mudanças
- **Dores**: Sobrecarga sensorial em ambientes acadêmicos, ansiedade com imprevistos
- **Necessidades**: Rotinas previsíveis, preparação para transições, regulação sensorial
- **Caso de Uso**: Utiliza o módulo de estudos para estruturar sessões, planeja refeições com antecedência, e consulta estratégias de autorregulação em momentos de sobrecarga

## 4. Ambiente de Mercado

### Análise da Concorrência
- **Aplicativos Genéricos** (Todoist, Notion): Poderosos, mas frequentemente sobrecarregados e não específicos
- **Apps de Saúde Mental** (Calm, Headspace): Focados em bem-estar, mas não em produtividade
- **Soluções para TDAH** (Focusmate, Forest): Abordam aspectos específicos, mas não oferecem solução completa
- **Apps de Acessibilidade**: Geralmente focados em deficiências físicas, não neurodivergência

### Tendências Relevantes
- Aumento de 300% nas buscas relacionadas a "produtividade TDAH" nos últimos 2 anos
- Crescimento do movimento de neurodiversidade e autoaceitação
- Movimento "tech for good" priorizando soluções para populações específicas
- Maior adoção de funcionalidades de acessibilidade em produtos digitais

## 5. Visão de Longo Prazo

### Evolução do Produto
- **Fase 1**: Foco em ferramentas essenciais de organização e bem-estar
- **Fase 2**: Expansão com funcionalidades de análise de padrões e personalização avançada
- **Fase 3**: Integração com dispositivos vestíveis e assistentes digitais para suporte contínuo
- **Fase 4**: Funcionalidades sociais e recursos de comunidade para compartilhamento de estratégias

### Modelo de Negócio Futuro
- Freemium com funcionalidades básicas gratuitas e recursos avançados pagos
- Planos para profissionais de saúde mental trabalhando com pacientes neurodivergentes
- Potenciais parcerias com organizações de saúde e educação

## Feedback

Este documento está aberto a sugestões e melhorias. Por favor, forneça feedback sobre:
- Outras necessidades não contempladas de pessoas neurodivergentes
- Oportunidades adicionais de mercado
- Tendências emergentes relevantes para o produto

## Histórico de Revisões

| Data | Versão | Autor | Mudanças |
|------|--------|-------|----------|
| Data Atual | 1.0 | Equipe | Versão inicial |

## Changelog

- **DOC-20230322-1.0**: Criação do documento com análise inicial de contexto e proposta de valor
</file>

<file path="memory-bank/core/projectbrief.md">
# PRD: MyNeuroApp - Aplicativo de Gestão para Neurodivergentes

## Status: [CURRENT] | Última Atualização: Data Atual | Versão: 1.0

## Introdução
Este documento define os requisitos e objetivos fundamentais do MyNeuroApp, uma aplicação web destinada a pessoas neurodivergentes para auxiliar na gestão de rotinas diárias e reduzir a sobrecarga cognitiva.

## Resumo Executivo
MyNeuroApp é uma plataforma centrada no usuário que oferece ferramentas para organização de rotinas, gestão de tarefas, monitoramento de saúde e bem-estar, com foco nas necessidades específicas de pessoas neurodivergentes, incluindo aquelas com TDAH, autismo, dislexia e outras condições.

## Pontos-Chave [IMPORTANTE]
- Aplicação destinada especificamente para pessoas neurodivergentes
- Foco na redução de sobrecarga cognitiva e estímulos
- Design minimalista e acessível
- Organização em módulos especializados
- Implementação gradual de funcionalidades
- Priorização da experiência do usuário e acessibilidade

## 1. Visão do Produto

**Propósito:** Fornecer uma solução digital abrangente para pessoas neurodivergentes gerenciarem diversos aspectos de sua vida diária, incluindo rotinas, saúde, bem-estar e produtividade, através de uma interface adaptada às suas necessidades específicas.

**Missão:** Reduzir a sobrecarga cognitiva e melhorar a qualidade de vida de pessoas neurodivergentes através de uma plataforma digital acessível, personalizável e inclusiva.

## 2. Módulos Principais

### Página Inicial
- Visão consolidada do dia
- Lista de prioridades limitada
- Lembretes de pausas
- Checklist de medicamentos

### Alimentação
- Planejador de refeições visual
- Registro simplificado
- Lembretes de hidratação
- Bibliotecas de refeições favoritas

### Estudos
- Gerenciador de sessões de estudo
- Técnicas de estudo adaptadas
- Registro de progressos
- Gestão de recursos de aprendizagem

### Saúde
- Rastreador de medicamentos
- Registro de sintomas
- Monitoramento de humor
- Histórico médico simplificado

### Lazer
- Sugestões de atividades de relaxamento
- Rastreador de hobbies
- Técnicas de autorregulação
- Planejador de tempo livre

### Sono
- Registro de padrões de sono
- Rotinas personalizáveis pré-sono
- Análise de qualidade do sono
- Sugestões para melhorar o sono

### Autoconhecimento
- Diário de gatilhos e soluções
- Rastreador de energia e foco
- Biblioteca de estratégias de regulação
- Registro de necessidades sensoriais

### Perfil
- Configurações de personalização
- Preferências de acessibilidade
- Gestão de conta
- Configurações de sincronização

## 3. Requisitos Técnicos

### Tecnologias
- Frontend: Next.js com TypeScript
- Estilização: Tailwind CSS
- Backend: Supabase (PostgreSQL)
- Autenticação: Supabase Auth
- Armazenamento: Combinação de localStorage e banco de dados remoto
- Hospedagem: Vercel

### Requisitos Não-Funcionais
- Acessibilidade: Conformidade com WCAG 2.1 AA
- Performance: Tempo de carregamento inicial < 2 segundos
- Responsividade: Adaptação para desktop, tablet e mobile
- Segurança: Criptografia de dados sensíveis
- Disponibilidade: Uptime de 99.9%
- Usabilidade: Interface simplificada e intuitiva

## 4. Público-Alvo

**Usuários Primários:**
- Adultos e adolescentes neurodivergentes (TDAH, autismo, dislexia, etc.)
- Idade: 16-45 anos
- Familiaridade tecnológica: Básica a avançada
- Necessidades: Estrutura, lembretes, redução de sobrecarga cognitiva

**Personas Principais:**
1. Carlos, 28 anos, TDAH, profissional de tecnologia
2. Ana, 19 anos, autista, estudante universitária
3. Miguel, 35 anos, dislexia e TDAH, empreendedor
4. Júlia, 42 anos, sensibilidade sensorial, professora

## 5. Cronograma de Alto Nível

**Fase 1: MVP (3 meses)**
- Desenvolvimento de módulos essenciais: Página Inicial, Alimentação, Saúde
- Implementação de autenticação básica
- Armazenamento local com sincronização limitada

**Fase 2: Expansão (3 meses)**
- Adição de módulos: Estudos, Sono, Lazer
- Migração completa para Supabase
- Melhorias de acessibilidade
- Funcionalidades de personalização

**Fase 3: Refinamento (2 meses)**
- Implementação dos módulos finais: Autoconhecimento, Perfil avançado
- Análises e insights baseados em dados
- Otimizações de performance
- Testes de usabilidade e ajustes finais

## 6. Métricas de Sucesso

- Retenção de usuários: 70% após 30 dias
- NPS (Net Promoter Score): >40
- Satisfação do usuário: >4.2/5
- Tempo médio de uso diário: >10 minutos
- Redução reportada em sobrecarga cognitiva: >30%

## Feedback

Este documento está aberto a sugestões e melhorias. Por favor, forneça feedback sobre:
- Funcionalidades adicionais relevantes
- Considerações específicas para diferentes tipos de neurodivergência
- Experiências similares e lições aprendidas

## Histórico de Revisões

| Data | Versão | Autor | Mudanças |
|------|--------|-------|----------|
| Data Atual | 1.0 | Equipe | Versão inicial |

## Changelog

- **DOC-20230322-1.0**: Criação do documento com definição inicial do projeto
</file>

<file path="memory-bank/navigation/changelog.md">
# Changelog do Memory Bank

**Status**: [CURRENT] | Última atualização: 23/09/2023 | Versão: 1.1

## Introdução
Este documento registra todas as alterações significativas feitas à documentação do Memory Bank do MyNeuroApp, mantendo um histórico cronológico das atualizações.

## Resumo Executivo
O registro de alterações permite rastrear a evolução da documentação, identificar quando informações foram adicionadas ou modificadas, e entender o desenvolvimento do projeto ao longo do tempo.

## Pontos-Chave
- Manter todas as alterações em ordem cronológica (mais recentes primeiro)
- Incluir data, versão do documento, autor e descrição da alteração
- Categorizar as alterações para facilitar filtragem
- Garantir que todas as atualizações importantes sejam registradas

## Registro de Alterações

### 23 de Setembro de 2023

- **[NOVO]** Criado documento `specialized/hooks_supabase.md` (v1.0) - Padrões para implementação de hooks no Supabase
- **[NOVO]** Criado documento `specialized/migracao_supabase.md` (v1.0) - Plano detalhado de migração para Supabase
- **[ATUALIZADO]** Documento `core/activeContext.md` (v1.2) - Atualizado com progresso da migração para Supabase

### 15 de Setembro de 2023

- **[ATUALIZADO]** Documento `core/activeContext.md` (v1.1) - Adicionados módulos de sono e medicamentos
- **[ATUALIZADO]** Documento `modules/sono.md` (v1.1) - Atualização com nova estrutura de dados
- **[ATUALIZADO]** Documento `modules/medicamentos.md` (v1.1) - Atualização com nova estrutura de dados

### 10 de Setembro de 2023

- **[ATUALIZADO]** Documento `core/systemPatterns.md` (v1.1) - Adicionado diagrama de arquitetura
- **[ATUALIZADO]** Documento `core/techContext.md` (v1.1) - Atualizado com novas decisões técnicas
- **[ATUALIZADO]** Documento `modules/prioridades.md` (v1.1) - Refinamento da documentação do módulo

### 5 de Setembro de 2023

- **[NOVO]** Criado documento `navigation/knowledgeGraph.md` (v0.1) - Draft inicial do mapa de conhecimento
- **[NOVO]** Criado documento `navigation/timeline.md` (v0.1) - Draft inicial da linha do tempo do projeto
- **[NOVO]** Criados documentos iniciais para os módulos em `modules/`

### 1 de Setembro de 2023

- **[NOVO]** Criação inicial da estrutura do Memory Bank
- **[NOVO]** Criado documento `README.md` (v1.0) - Guia de uso do Memory Bank
- **[NOVO]** Criado documento `navigation/index.md` (v1.0) - Índice de navegação
- **[NOVO]** Criado documento `core/projectbrief.md` (v1.0) - Visão geral do projeto
- **[NOVO]** Criado documento `core/productContext.md` (v1.0) - Contexto do produto
- **[NOVO]** Criado documento `core/activeContext.md` (v1.0) - Foco atual do desenvolvimento
- **[NOVO]** Criado documento `core/systemPatterns.md` (v1.0) - Padrões arquiteturais
- **[NOVO]** Criado documento `core/techContext.md` (v1.0) - Contexto tecnológico
- **[NOVO]** Criado documento `core/progress.md` (v1.0) - Status de implementação
- **[NOVO]** Criado documento `templates/document_template.md` (v1.0) - Template para documentos

## Formato para Novas Entradas

Ao adicionar novas entradas ao changelog, seguir o formato:

```
### [DATA]

- **[TIPO]** Documento `caminho/arquivo.md` (vX.Y) - Breve descrição da alteração
```

Onde **[TIPO]** pode ser:
- **[NOVO]** - Novo documento criado
- **[ATUALIZADO]** - Documento existente atualizado
- **[REMOVIDO]** - Documento removido
- **[MIGRADO]** - Documento migrado para outra localização

## Semântica de Versão

Usar o seguinte formato para versões:
- Incrementar o primeiro número (X.0) para mudanças significativas/estruturais
- Incrementar o segundo número (1.X) para atualizações de conteúdo
- Usar v0.X para documentos em fase de rascunho

## Histórico de Revisões

| Data | Versão | Autor | Aprovador | Alterações |
|------|--------|-------|-----------|------------|
| 23/09/2023 | 1.1 | DevTeam | TechLead | Adicionadas entradas para documentação de migração Supabase |
| 01/09/2023 | 1.0 | DevTeam | TechLead | Versão inicial do changelog |

## Changelog

- 2023-09-23: Atualização com entradas para documentação de migração Supabase (v1.1)
- 2023-09-01: Criação do documento changelog (v1.0)
</file>

<file path="memory-bank/navigation/index.md">
# Índice de Navegação do Memory Bank

## Introdução
Este documento serve como ponto central de navegação para toda a documentação do MyNeuroApp, facilitando a localização de informações específicas sobre o projeto.

## Resumo Executivo
O Memory Bank contém documentação estruturada sobre todos os aspectos do MyNeuroApp, desde a visão geral do produto até detalhes técnicos específicos, incluindo o plano de migração para Supabase.

## Pontos-Chave
- Mantenha este índice atualizado quando adicionar ou modificar documentos
- Use os links diretos para navegar rapidamente para informações específicas
- Verifique os status dos documentos para avaliar a confiabilidade das informações

## Documentos Principais

### Documentos Essenciais

| Documento | Caminho | Status | Última Atualização |
|-----------|---------|--------|-------------------|
| Visão Geral do Projeto | [/core/projectbrief.md](/memory-bank/core/projectbrief.md) | Atualizado | [DATA] |
| Contexto do Produto | [/core/productContext.md](/memory-bank/core/productContext.md) | Atualizado | [DATA] |
| Contexto Atual | [/core/activeContext.md](/memory-bank/core/activeContext.md) | Atualizado | [DATA] |
| Arquitetura | [/core/architecture.md](/memory-bank/core/architecture.md) | Atualizado | [DATA] |
| Changelog | [/navigation/changelog.md](/memory-bank/navigation/changelog.md) | Atualizado | [DATA] |

### Plano de Migração Supabase

| Documento | Caminho | Status | Última Atualização |
|-----------|---------|--------|-------------------|
| Plano de Migração | [/specialized/migracao_supabase.md](/memory-bank/specialized/migracao_supabase.md) | Atualizado | [DATA] |
| Arquitetura da Migração | [/core/architecture.md](/memory-bank/core/architecture.md) | Atualizado | [DATA] |
| Estratégia de Testes | [/specialized/test_strategy.md](/memory-bank/specialized/test_strategy.md) | Atualizado | [DATA] |
| Solução de Problemas | [/specialized/troubleshooting.md](/memory-bank/specialized/troubleshooting.md) | Atualizado | [DATA] |

### Documentos por Módulo

| Módulo | Documento Principal | Documentos Relacionados | Status |
|--------|---------------------|-------------------------|--------|
| Prioridades | [/modules/prioridades.md](/memory-bank/modules/prioridades.md) | - | Pendente |
| Sono | [/modules/sono.md](/memory-bank/modules/sono.md) | - | Pendente |
| Medicamentos | [/modules/medicamentos.md](/memory-bank/modules/medicamentos.md) | - | Pendente |
| Humor | [/modules/humor.md](/memory-bank/modules/humor.md) | - | Pendente |
| Estudos | [/modules/estudos.md](/memory-bank/modules/estudos.md) | - | Pendente |
| Autoconhecimento | [/modules/autoconhecimento.md](/memory-bank/modules/autoconhecimento.md) | - | Pendente |
| Alimentação | [/modules/alimentacao.md](/memory-bank/modules/alimentacao.md) | - | Pendente |
| Lazer | [/modules/lazer.md](/memory-bank/modules/lazer.md) | - | Pendente |

### Documentos Técnicos

| Documento | Caminho | Status | Última Atualização |
|-----------|---------|--------|-------------------|
| Padrões de Código | [/specialized/code_standards.md](/memory-bank/specialized/code_standards.md) | Pendente | - |
| Guia de Estilo | [/specialized/style_guide.md](/memory-bank/specialized/style_guide.md) | Pendente | - |
| Acessibilidade | [/specialized/accessibility.md](/memory-bank/specialized/accessibility.md) | Pendente | - |

## Templates

| Template | Caminho | Propósito |
|----------|---------|-----------|
| Documento Base | [/templates/document_template.md](/memory-bank/templates/document_template.md) | Template para novos documentos |

## Modos de Operação

### Modo Architect

Documentos úteis para compreender a arquitetura geral:
- [/core/architecture.md](/memory-bank/core/architecture.md)
- [/specialized/migracao_supabase.md](/memory-bank/specialized/migracao_supabase.md)

### Modo Code

Documentos úteis para implementar código:
- [/specialized/code_standards.md](/memory-bank/specialized/code_standards.md) (Pendente)
- [/core/architecture.md](/memory-bank/core/architecture.md)

### Modo Debug

Documentos úteis para solucionar problemas:
- [/specialized/troubleshooting.md](/memory-bank/specialized/troubleshooting.md)

### Modo Test

Documentos úteis para testes:
- [/specialized/test_strategy.md](/memory-bank/specialized/test_strategy.md)

### Modo Ask

Documentos para responder perguntas comuns:
- [/core/projectbrief.md](/memory-bank/core/projectbrief.md)
- [/specialized/troubleshooting.md](/memory-bank/specialized/troubleshooting.md)

## Histórico de Revisões

| Versão | Data | Autor | Descrição |
|--------|------|-------|-----------|
| 1.0 | [DATA ATUAL] | [AUTOR] | Versão inicial do índice de navegação |
</file>

<file path="memory-bank/specialized/codeDocMap.md">
# Mapa de Documentação de Código

**Status**: [CURRENT] | Última atualização: 24/09/2023 | Versão: 1.2

## Introdução
Este documento mapeia os arquivos de código do MyNeuroApp para a documentação relevante no Memory Bank, ajudando a manter a sincronização entre implementação e documentação.

## Estrutura Principal

| Caminho | Descrição | Documentação Relacionada |
|---------|-----------|--------------------------|
| `app/` | Diretório principal da aplicação | `productContext.md`, `systemPatterns.md` |
| `app/components/` | Componentes reutilizáveis | `systemPatterns.md` - Seção Componentes |
| `app/context/` | React Context APIs | `systemPatterns.md` - Seção Gerenciamento de Estado |
| `app/hooks/` | Custom React Hooks | `systemPatterns.md` - Seção Hooks |
| `app/lib/` | Bibliotecas e utilidades | `techContext.md` |
| `app/styles/` | Estilos globais | `systemPatterns.md` - Seção UI |
| `app/types/` | Definições de tipos TypeScript | `techContext.md` |
| `app/store/` | Gerenciamento de estado local | `systemPatterns.md` - Seção Gerenciamento de Estado |
| `public/` | Arquivos estáticos | - |

## Componentes

| Componente | Caminho | Documentação Relacionada |
|------------|---------|--------------------------|
| `Header` | `app/components/Header.tsx` | `systemPatterns.md` - Seção Navegação |
| `Footer` | `app/components/Footer.tsx` | `systemPatterns.md` - Seção Navegação |
| `UserMenu` | `app/components/UserMenu.tsx` | `systemPatterns.md` - Seção Autenticação |
| `LoadingIndicator` | `app/components/LoadingIndicator.tsx` | `systemPatterns.md` - Seção Feedback Visual |
| `Toast` | `app/components/Toast.tsx` | `systemPatterns.md` - Seção Feedback Visual |
| `DataMigration` | `app/components/perfil/DataMigration.tsx` | `migracao_supabase.md` - Seção Interface de Migração |

## Contextos

| Contexto | Caminho | Documentação Relacionada |
|----------|---------|--------------------------|
| `AuthContext` | `app/context/AuthContext.tsx` | `systemPatterns.md` - Seção Autenticação |
| `ToastContext` | `app/context/ToastContext.tsx` | `systemPatterns.md` - Seção Feedback Visual |

## Hooks

| Hook | Caminho | Documentação Relacionada |
|------|---------|--------------------------|
| `useAuth` | `app/hooks/useAuth.ts` | `systemPatterns.md` - Seção Autenticação |
| `usePriorities` | `app/hooks/usePriorities.ts` | `migracao_supabase.md` - Seção Hooks |
| `useSleep` | `app/hooks/useSleep.ts` | `migracao_supabase.md` - Seção Hooks |
| `useHumor` | `app/hooks/useHumor.ts` | `migracao_supabase.md` - Seção Hooks |
| `useToast` | `app/hooks/useToast.ts` | `systemPatterns.md` - Seção Feedback Visual |

## Utilidades e Configurações

| Arquivo | Caminho | Documentação Relacionada |
|---------|---------|--------------------------|
| Cliente Supabase | `app/lib/supabase.ts` | `migracao_supabase.md` - Seção Configuração Inicial |
| Tipos Supabase | `app/types/supabase.ts` | `migracao_supabase.md` - Seção Estruturação do Banco de Dados |
| Middleware | `middleware.ts` | `migracao_supabase.md` - Seção Implementação da Autenticação |

## Módulos por Funcionalidade

### Autenticação

| Arquivo | Caminho | Documentação Relacionada |
|---------|---------|--------------------------|
| Página de Login | `app/auth/login/page.tsx` | `migracao_supabase.md` - Seção Implementação da Autenticação |
| Página de Cadastro | `app/auth/cadastro/page.tsx` | `migracao_supabase.md` - Seção Implementação da Autenticação |
| Rota de Callback | `app/auth/callback/route.ts` | `migracao_supabase.md` - Seção Implementação da Autenticação |

### Prioridades

| Arquivo | Caminho | Documentação Relacionada |
|---------|---------|--------------------------|
| Página de Prioridades | `app/prioridades/page.tsx` | `progress.md` - Seção Módulos |
| Hook de Prioridades | `app/hooks/usePriorities.ts` | `migracao_supabase.md` - Seção Hooks |
| Lista de Prioridades | `app/components/prioridades/PriorityList.tsx` | `systemPatterns.md` - Seção Componentes |
| Item de Prioridade | `app/components/prioridades/PriorityItem.tsx` | `systemPatterns.md` - Seção Componentes |
| Formulário de Prioridade | `app/components/prioridades/PriorityForm.tsx` | `systemPatterns.md` - Seção Componentes |

### Sono

| Arquivo | Caminho | Documentação Relacionada |
|---------|---------|--------------------------|
| Página de Sono | `app/sono/page.tsx` | `progress.md` - Seção Módulos |
| Hook de Sono | `app/hooks/useSleep.ts` | `migracao_supabase.md` - Seção Hooks |
| Lista de Registros de Sono | `app/components/sono/SleepRecordList.tsx` | `systemPatterns.md` - Seção Componentes |
| Item de Registro de Sono | `app/components/sono/SleepRecordItem.tsx` | `systemPatterns.md` - Seção Componentes |
| Formulário de Sono | `app/components/sono/SleepForm.tsx` | `systemPatterns.md` - Seção Componentes |
| Migração de Dados de Sono | `app/components/sono/SleepDataMigration.tsx` | `migracao_supabase.md` - Seção Interface de Migração |

### Humor

| Arquivo | Caminho | Documentação Relacionada |
|---------|---------|--------------------------|
| Página de Humor | `app/humor/page.tsx` | `progress.md` - Seção Módulos |
| Hook de Humor | `app/hooks/useHumor.ts` | `migracao_supabase.md` - Seção Hooks |
| Lista de Registros de Humor | `app/components/humor/MoodRecordList.tsx` | `systemPatterns.md` - Seção Componentes |
| Item de Registro de Humor | `app/components/humor/MoodRecordItem.tsx` | `systemPatterns.md` - Seção Componentes |
| Formulário de Humor | `app/components/humor/MoodForm.tsx` | `systemPatterns.md` - Seção Componentes |
| Migração de Dados de Humor | `app/components/humor/MoodDataMigration.tsx` | `migracao_supabase.md` - Seção Interface de Migração |
| SQL de Criação da Tabela | `scripts/mood_records_table.sql` | `migracao_supabase.md` - Seção Estruturação do Banco de Dados |

### Medicamentos

| Arquivo | Caminho | Documentação Relacionada |
|---------|---------|--------------------------|
| Página de Medicamentos | `app/medicamentos/page.tsx` | `progress.md` - Seção Módulos |
| Hook de Medicamentos | `app/hooks/useMedications.ts` | `migracao_supabase.md` - Seção Hooks |
| Lista de Medicamentos | `app/components/saude/MedicationList.tsx` | `systemPatterns.md` - Seção Componentes |
| Item de Medicamento | `app/components/saude/MedicationItem.tsx` | `systemPatterns.md` - Seção Componentes |
| Formulário de Medicamento | `app/components/saude/MedicationForm.tsx` | `systemPatterns.md` - Seção Componentes |
| Migração de Dados de Medicamentos | `app/components/saude/MedicationDataMigration.tsx` | `migracao_supabase.md` - Seção Interface de Migração |
| SQL de Criação da Tabela | `scripts/medications_table.sql` | `migracao_supabase.md` - Seção Estruturação do Banco de Dados |

### Perfil de Usuário

| Arquivo | Caminho | Documentação Relacionada |
|---------|---------|--------------------------|
| Página de Perfil | `app/perfil/page.tsx` | `migracao_supabase.md` - Seção Migração de Dados |
| Componente de Migração | `app/components/perfil/DataMigration.tsx` | `migracao_supabase.md` - Seção Interface de Migração |
| Detalhes do Usuário | `app/components/perfil/UserDetails.tsx` | `systemPatterns.md` - Seção Componentes |

## Histórico de Revisões

| Data | Versão | Autor | Aprovador | Alterações |
|------|--------|-------|-----------|------------|
| 04/10/2023 | 1.3 | DevTeam | TechLead | Adicionados componentes do módulo de Medicamentos |
| 24/09/2023 | 1.2 | DevTeam | TechLead | Adicionados componentes de migração e feedback visual |
| 23/09/2023 | 1.1 | DevTeam | TechLead | Atualização com componentes de autenticação |
| 15/09/2023 | 1.0 | DevTeam | TechLead | Versão inicial do documento |
</file>

<file path="memory-bank/specialized/hooks_supabase.md">
# Hooks Supabase: Padrões e Implementação

**Status**: [CURRENT] | Última atualização: 23/09/2023 | Versão: 1.1

## Introdução
Este documento define os padrões para a criação e utilização de hooks React para acesso a dados no Supabase no MyNeuroApp. Estes hooks seguem uma estrutura consistente para garantir uniformidade e facilidade de manutenção.

## Resumo Executivo
Para facilitar o acesso aos dados do Supabase no MyNeuroApp, utilizamos hooks React personalizados que encapsulam a lógica de acesso a dados e gerenciamento de estado. Cada módulo do aplicativo tem seu próprio hook especializado que segue um padrão comum.

## Pontos-Chave
- Hooks encapsulam lógica de acesso ao Supabase
- Estrutura padronizada para funções CRUD
- Tratamento de erros consistente
- Estado de carregamento centralizado
- Suporte para migração de dados do localStorage

## Estrutura do Hook Padrão

Todos os hooks do Supabase seguem a estrutura básica:

```typescript
export function useEntity() {
  const supabase = createClient();
  const { user } = useAuthContext();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const resetError = useCallback(() => {
    setError(null);
  }, []);
  
  // Funções CRUD...
  
  return {
    // Estado
    isLoading,
    error,
    resetError,
    
    // Operações CRUD
    getItems,
    getItem,
    addItem,
    updateItem,
    deleteItem,
    
    // Funções específicas da entidade
    // ...
    
    // Migração (se aplicável)
    migrateFromLocalStorage
  };
}
```

## Hooks Implementados

### `useAuth`

Hook para gerenciamento de autenticação:

```typescript
export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Métodos de autenticação (signIn, signUp, signOut, etc.)
  
  return {
    user,
    session,
    isLoading,
    error,
    signIn,
    signUp,
    signOut,
    // ...
  };
}
```

### `usePriorities`

Hook para gerenciamento de prioridades:

```typescript
export function usePriorities() {
  const supabase = createClient();
  const { user } = useAuthContext();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // Funções CRUD para prioridades
  const getPriorities = async (): Promise<Priority[]> => {
    if (!user) return [];
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('priorities')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });
        
      if (error) throw new Error(error.message);
      
      return data || [];
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar prioridades';
      setError(new Error(errorMessage));
      return [];
    } finally {
      setIsLoading(false);
    }
  };
  
  // Outras funções CRUD...
  
  // Migração de prioridades do localStorage
  const migrateFromLocalStorage = async (): Promise<{ success: boolean; count: number; error?: string }> => {
    // Implementação da migração...
  };
  
  return {
    isLoading,
    error,
    resetError,
    getPriorities,
    getPriority,
    addPriority,
    updatePriority,
    togglePriorityCompletion,
    deletePriority,
    migrateFromLocalStorage
  };
}
```

## Padrões de Nomenclatura

### Nomes de Hooks
- Sempre prefixado com `use` (convenção React)
- Nome no plural para hooks que lidam com coleções (`usePriorities`, `useMedications`)
- Nome no singular para hooks que lidam com uma única entidade (`useUser`, `useProfile`)

### Nomes de Métodos
- `getItems`: Buscar todos os itens (plural)
- `getItem`: Buscar um item específico (singular)
- `addItem`: Adicionar um novo item
- `updateItem`: Atualizar um item existente
- `deleteItem`: Excluir um item
- `toggleItemFeature`: Alternar uma propriedade booleana
- `migrateFromLocalStorage`: Migrar dados do localStorage para o Supabase

## Tratamento de Erros

Todos os hooks seguem o mesmo padrão de tratamento de erros:

1. Centralização do estado de erro em um único `useState`
2. Try/catch em todas as operações assíncronas
3. Formatação consistente de mensagens de erro
4. Método `resetError` para limpar o estado de erro

```typescript
try {
  // Operação com Supabase
  if (error) throw new Error(error.message);
  return data;
} catch (err) {
  const errorMessage = err instanceof Error ? err.message : 'Erro genérico';
  setError(new Error(errorMessage));
  return null; // ou array vazio, dependendo do contexto
} finally {
  setIsLoading(false);
}
```

## Estado de Carregamento

Para controlar o estado de carregamento, seguimos o padrão:

1. Iniciar o `isLoading` como `false`
2. Definir como `true` no início de cada operação assíncroma
3. Definir como `false` no bloco `finally`
4. Expor `isLoading` no retorno do hook

## Migração de Dados

Para hooks que oferecem funcionalidade de migração:

1. Acessar dados do localStorage
2. Transformar para o formato do Supabase
3. Validar dados antes da migração
4. Inserir no Supabase
5. Retornar resultado com contagem e status

```typescript
const migrateFromLocalStorage = async () => {
  // Verificar autenticação
  if (!user) return { success: false, count: 0, error: 'Usuário não autenticado' };
  
  setIsLoading(true);
  setError(null);
  
  try {
    // Obter dados do localStorage
    const localData = localStorage.getItem('key');
    if (!localData) return { success: true, count: 0 };
    
    // Transformar dados
    const parsedData = JSON.parse(localData);
    // Validação e transformação...
    
    // Inserir no Supabase
    // ...
    
    return { success: true, count: items.length };
  } catch (err) {
    // Tratamento de erro...
  } finally {
    setIsLoading(false);
  }
};
```

## Uso com Context API

Para compartilhar estados em toda a aplicação, combinamos hooks com Context API:

```typescript
// No provedor de contexto (simplificado)
const AuthProvider = ({ children }) => {
  const auth = useAuth();
  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;
};

// Em um componente
const { user, signIn } = useAuthContext();
```

## Próximos Hooks Planejados

À medida que a migração avança, os seguintes hooks serão implementados:

1. `useSleep` - Gerenciamento de dados de sono
2. `useMedications` - Gerenciamento de medicamentos
3. `useMood` - Gerenciamento de registros de humor
4. `useStudy` - Gerenciamento de sessões de estudo

## Melhores Práticas

1. **Sempre verificar autenticação** no início de cada função
2. **Centralizar tratamento de erros** para facilitar depuração
3. **Usar tipos TypeScript** para melhorar a experiência de desenvolvimento
4. **Separar lógica de UI** da lógica de acesso a dados
5. **Documentar hooks** com JSDoc para melhor intellisense
6. **Testes unitários** para validar comportamento dos hooks

## Histórico de Revisões

| Data | Versão | Autor | Aprovador | Alterações |
|------|--------|-------|-----------|------------|
| 23/09/2023 | 1.1 | DevTeam | TechLead | Adição do hook usePriorities e padrões atualizados |
| 15/09/2023 | 1.0 | DevTeam | TechLead | Versão inicial |

## Changelog

- 2023-09-23: Criação do documento de padrões de hooks (v1.0)
</file>

<file path="memory-bank/specialized/migracao_supabase.md">
# Migração para Supabase

**Status**: [CURRENT] | Última atualização: 24/09/2023 | Versão: 1.2

## Introdução
Este documento descreve o plano de migração para transferir o armazenamento de dados do MyNeuroApp do localStorage para o Supabase, permitindo persistência de dados entre dispositivos e recursos avançados como autenticação e compartilhamento.

## Resumo Executivo
A migração para o Supabase está sendo realizada de forma gradual, módulo por módulo, começando com o módulo de Prioridades como piloto. A implementação segue uma abordagem em fases para minimizar o impacto na experiência do usuário e garantir uma transição suave.

## Pontos-Chave
- Implementação modular, começando pelo módulo de Prioridades
- Autenticação integrada com opções de email/senha e OAuth (Google)
- Migração de dados existentes do localStorage para o Supabase
- Políticas de segurança no nível do banco de dados (Row Level Security)
- Componentes reutilizáveis para consistência entre módulos

## Plano de Migração

### Fase 1: Configuração Inicial ✅
- **Objetivo**: Configurar o projeto Supabase e integrar com o aplicativo
- **Tarefas**:
  - Criar projeto no Supabase
  - Instalar dependências no projeto (`@supabase/supabase-js`, `@supabase/auth-helpers-nextjs`)
  - Configurar variáveis de ambiente (`.env.local`)
  - Configurar cliente Supabase no projeto (`app/lib/supabase.ts`)

### Fase 2: Estruturação do Banco de Dados ✅
- **Objetivo**: Criar tabelas e políticas de segurança
- **Tarefas**:
  - Criar tabela `profiles` para dados de usuário
  - Criar tabela `priorities` para o módulo piloto
  - Configurar Políticas de Segurança (RLS)
  - Definir triggers para criação automática de perfil
  - Criar tipos TypeScript correspondentes (`app/types/supabase.ts`)

### Fase 3: Implementação da Autenticação ✅
- **Objetivo**: Implementar autenticação de usuário
- **Tarefas**:
  - Criar hook `useAuth` para gerenciar sessões (`app/hooks/useAuth.ts`)
  - Implementar Context Provider para autenticação (`app/context/AuthContext.tsx`)
  - Criar páginas de login e registro (`app/auth/login` e `app/auth/cadastro`)
  - Configurar rota para callback de OAuth (`app/auth/callback/route.ts`)
  - Implementar middleware para proteção de rotas (`middleware.ts`)

### Fase 4: Adaptação dos Componentes ✅
- **Objetivo**: Adaptar componentes existentes para utilizar Supabase
- **Tarefas**:
  - Atualizar Header para mostrar estado de autenticação
  - Criar componente de menu de usuário
  - Implementar feedback visual para estados de carregamento
  - Criar componentes Toast e LoadingIndicator para feedback de operações
  - Implementar ToastContext para gerenciamento de notificações

### Fase 5: Migração de Dados ⏳
- **Objetivo**: Migrar dados existentes do localStorage para o Supabase
- **Tarefas**:
  - Implementar função de migração para o módulo de Prioridades ✅
  - Criar UI para migração assistida ✅
  - Adicionar opção para manter ou limpar dados locais após migração ✅
  - Implementar verificação de dados duplicados
  - Testar migração em diferentes cenários

### Fase 6: Criação de Hooks para Acesso a Dados ✅
- **Objetivo**: Criar hooks reutilizáveis para acesso a dados
- **Tarefas**:
  - Criar hook `usePriorities` para o módulo piloto
  - Implementar funções CRUD padronizadas
  - Adicionar tratamento de erros robusto
  - Criar tipos TypeScript para os hooks
  - Documentar padrões para outros hooks

## Interface de Migração de Dados

A interface de migração implementada em `app/components/perfil/DataMigration.tsx` oferece uma experiência de migração intuitiva para o usuário:

1. **Detecção automática de dados** - Verifica se existem dados no localStorage para migrar
2. **Opção de limpeza** - Permite ao usuário escolher se deseja remover os dados locais após a migração
3. **Feedback visual** - Mostra o progresso da migração e notifica sobre o sucesso ou falha
4. **Resumo de resultados** - Exibe quantos itens foram migrados com sucesso

```typescript
// Trecho simplificado da implementação
const startMigration = async () => {
  setIsMigrating(true);
  
  try {
    const result = await migrateFromLocalStorage();
    
    if (result.success) {
      setShowSuccess(true);
      setMigrationCount(result.count);
      showToast(`${result.count} prioridades migradas com sucesso`, 'success');
      
      if (shouldClearLocal && result.count > 0) {
        clearLocalData();
      }
    } else {
      showToast(`Erro na migração: ${result.error}`, 'error');
    }
  } catch (error) {
    showToast('Erro ao migrar dados', 'error');
  } finally {
    setIsMigrating(false);
  }
};
```

## Estrutura do Banco de Dados

### Tabela `profiles`
```sql
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  username text,
  full_name text,
  email text not null,
  preferences jsonb
);

-- Criar automaticamente um perfil para novos usuários
create function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
```

### Tabela `priorities`
```sql
create table priorities (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references auth.users not null,
  content text not null,
  completed boolean default false,
  due_date date,
  created_at timestamp with time zone default now(),
  category text,
  updated_at timestamp with time zone
);

-- Habilitar RLS
alter table priorities enable row level security;

-- Criar políticas
create policy "Usuários podem ver apenas suas próprias prioridades"
  on priorities for select
  using (auth.uid() = user_id);

create policy "Usuários podem inserir suas próprias prioridades"
  on priorities for insert
  with check (auth.uid() = user_id);

create policy "Usuários podem atualizar suas próprias prioridades"
  on priorities for update
  using (auth.uid() = user_id);

create policy "Usuários podem deletar suas próprias prioridades"
  on priorities for delete
  using (auth.uid() = user_id);
```

## Estratégia de Migração de Dados

Para migrar dados do localStorage para o Supabase, usamos a seguinte abordagem:

1. **Verificação** - Verificar se há dados no localStorage
2. **Extração** - Extrair e transformar dados para o formato do Supabase
3. **Validação** - Validar dados antes da migração
4. **Inserção** - Inserir dados no Supabase
5. **Confirmação** - Confirmar sucesso e oferecer opção de limpar localStorage

```typescript
// Exemplo simplificado da função de migração
const migratePriorities = async () => {
  // Verificar autenticação
  if (!user) return { success: false, error: 'Usuário não autenticado' };
  
  // Obter dados do localStorage
  const localData = localStorage.getItem('prioridades-diarias');
  if (!localData) return { success: true, count: 0 };
  
  // Transformar dados
  const parsedData = JSON.parse(localData);
  const priorities = parsedData.state.prioridades.map(p => ({
    content: p.texto,
    completed: p.concluida,
    due_date: p.data,
    user_id: user.id
  }));
  
  // Inserir no Supabase
  const { error } = await supabase.from('priorities').insert(priorities);
  
  if (error) return { success: false, error };
  return { success: true, count: priorities.length };
};
```

## Benefícios da Migração

1. **Sincronização entre dispositivos** - Dados acessíveis de qualquer dispositivo
2. **Segurança** - Dados protegidos por autenticação e políticas de segurança
3. **Backup automático** - Dados armazenados no servidor com backup
4. **Funcionalidades sociais** - Possibilidade de compartilhamento e colaboração
5. **Escalabilidade** - Suporte para grandes volumes de dados

## Próximos Passos

Após a conclusão da Fase 5, seguiremos com:

1. **Fase de Validação** - Testar a migração em diferentes cenários e com diferentes volumes de dados
2. **Expansão para outros módulos** - Aplicar a mesma estratégia para outros módulos, começando pelo módulo de Sono
3. **Melhorias de UX** - Refinar a experiência de migração com base no feedback dos usuários
4. **Monitoramento** - Implementar ferramentas para monitorar o sucesso da migração e resolver problemas 

## Histórico de Revisões

| Data | Versão | Autor | Aprovador | Alterações |
|------|--------|-------|-----------|------------|
| 24/09/2023 | 1.2 | DevTeam | TechLead | Atualização sobre implementação da interface de migração |
| 23/09/2023 | 1.1 | DevTeam | TechLead | Atualização sobre progresso da Fase 3 |
| 15/09/2023 | 1.0 | DevTeam | TechLead | Versão inicial do documento |

## Changelog

- 2023-09-24: Atualização sobre a implementação da interface de migração (v1.2)
- 2023-09-23: Atualização sobre a implementação da autenticação (v1.1)
- 2023-09-15: Criação do documento de migração (v1.0)
</file>

<file path="memory-bank/specialized/test_strategy.md">
# Estratégia de Testes para Migração Supabase

## Introdução
Este documento detalha a estratégia de testes para garantir que a migração do MyNeuroApp para Supabase seja realizada de forma segura e confiável.

## Resumo Executivo
A estratégia de testes abrange testes unitários, de integração e de ponta a ponta para validar todos os aspectos da migração, incluindo autenticação, acesso a dados e migração de dados locais.

## Pontos-Chave
- Testes unitários para hooks e funções de migração
- Testes de integração para validar interações com Supabase
- Testes de ponta a ponta para fluxos completos
- Testes de migração para validar preservação de dados
- Testes de segurança para validar políticas RLS

## Plano de Testes

### 1. Testes Unitários

#### 1.1 Hooks de Acesso a Dados
Todos os hooks de acesso a dados serão testados com Jest e React Testing Library:

```typescript
// Exemplo de teste para usePriorities
describe('usePriorities', () => {
  it('deve carregar prioridades corretamente', async () => {
    // Mock do retorno do Supabase
    mockSupabaseQuery.mockResolvedValueOnce({
      data: [{ id: 1, title: 'Prioridade 1', user_id: 'user-123' }],
      error: null
    });
    
    const { result, waitForNextUpdate } = renderHook(() => usePriorities());
    
    expect(result.current.loading).toBe(true);
    await waitForNextUpdate();
    
    expect(result.current.priorities).toHaveLength(1);
    expect(result.current.priorities[0].title).toBe('Prioridade 1');
    expect(result.current.loading).toBe(false);
  });
  
  // Testes para criar, atualizar e excluir
  // ...
});
```

#### 1.2 Funções de Migração
Testes para funções de migração de dados do localStorage para Supabase:

```typescript
describe('migrateData', () => {
  it('deve migrar prioridades corretamente', async () => {
    // Mock do localStorage
    localStorage.setItem('priorities', JSON.stringify([
      { id: 'local-1', title: 'Prioridade Local' }
    ]));
    
    // Mock do Supabase
    mockSupabaseInsert.mockResolvedValueOnce({
      data: { id: 'supabase-1', title: 'Prioridade Local', user_id: 'user-123' },
      error: null
    });
    
    const result = await migratePriorities('user-123');
    
    expect(result.success).toBe(true);
    expect(result.migratedCount).toBe(1);
    expect(mockSupabaseInsert).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Prioridade Local'
    }));
  });
});
```

#### 1.3 Componentes de Interface
Testes para componentes com interações de autenticação:

```typescript
describe('Header', () => {
  it('deve mostrar botão de login quando usuário não estiver autenticado', () => {
    const { getByText } = render(<Header />);
    expect(getByText('Entrar')).toBeInTheDocument();
  });
  
  it('deve mostrar perfil do usuário quando autenticado', () => {
    mockUseUser.mockReturnValueOnce({ 
      user: { id: 'user-123', email: 'user@example.com' }, 
      loading: false 
    });
    
    const { getByText } = render(<Header />);
    expect(getByText('user@example.com')).toBeInTheDocument();
  });
});
```

### 2. Testes de Integração

#### 2.1 Autenticação com Supabase
Testes para fluxo de autenticação real com o Supabase:

```typescript
describe('Autenticação', () => {
  // Usar um banco de teste ou Supabase emulado
  beforeEach(() => {
    // Configurar banco de teste
  });
  
  it('deve registrar um novo usuário', async () => {
    const result = await supabase.auth.signUp({
      email: 'test@example.com',
      password: 'password123'
    });
    
    expect(result.error).toBeNull();
    expect(result.data.user).toBeDefined();
    expect(result.data.user.email).toBe('test@example.com');
  });
  
  it('deve fazer login com credenciais válidas', async () => {
    // Criar usuário primeiro
    // ...
    
    const result = await supabase.auth.signInWithPassword({
      email: 'test@example.com',
      password: 'password123'
    });
    
    expect(result.error).toBeNull();
    expect(result.data.session).toBeDefined();
  });
});
```

#### 2.2 Políticas RLS
Testes para validar políticas de segurança:

```typescript
describe('Políticas RLS', () => {
  let userAClient, userBClient;
  
  beforeEach(async () => {
    // Criar dois usuários e clientes Supabase separados
  });
  
  it('usuário deve acessar apenas seus próprios dados', async () => {
    // Inserir dados para usuário A
    const { data: priorityA } = await userAClient
      .from('priorities')
      .insert({ title: 'Prioridade A' })
      .select()
      .single();
      
    // Inserir dados para usuário B
    const { data: priorityB } = await userBClient
      .from('priorities')
      .insert({ title: 'Prioridade B' })
      .select()
      .single();
      
    // Usuário A tenta ler todos os dados
    const { data: prioritiesForA } = await userAClient
      .from('priorities')
      .select('*');
      
    expect(prioritiesForA).toHaveLength(1);
    expect(prioritiesForA[0].id).toBe(priorityA.id);
  });
});
```

### 3. Testes de Ponta a Ponta (E2E)

Utilizando Cypress para testes de ponta a ponta:

```javascript
describe('Fluxo de Migração', () => {
  beforeEach(() => {
    // Configurar dados de teste no localStorage
    cy.window().then(win => {
      win.localStorage.setItem('priorities', JSON.stringify([
        { id: 'local-1', title: 'Prioridade local' }
      ]));
    });
  });
  
  it('deve migrar dados ao fazer login pela primeira vez', () => {
    // Visitar página de login
    cy.visit('/auth/login');
    
    // Preencher formulário de login
    cy.get('input[name="email"]').type('test@example.com');
    cy.get('input[name="password"]').type('password123');
    cy.get('button[type="submit"]').click();
    
    // Verificar se foi redirecionado para página de migração
    cy.url().should('include', '/migrate');
    
    // Verificar se mostra progresso de migração
    cy.contains('Migrando seus dados');
    
    // Aguardar conclusão e verificar se dados foram migrados
    cy.contains('Migração concluída', { timeout: 10000 });
    
    // Navegar para prioridades e verificar se dados locais estão presentes
    cy.visit('/app/priorities');
    cy.contains('Prioridade local');
  });
});
```

### 4. Testes de Segurança

#### 4.1 Penetration Testing
Testes manuais para tentar acessar dados de outros usuários:

- Tentar modificar IDs nas requisições
- Tentar manipular tokens JWT
- Verificar headers HTTP para evitar vazamentos

#### 4.2 Auditoria de Configuração
Verificação das configurações do Supabase:

- Validar configuração de CORS
- Verificar configurações de autenticação
- Confirmar que todas as tabelas têm RLS ativo

## Ambientes de Teste

### Ambiente de Desenvolvimento
- Instância Supabase de desenvolvimento
- Banco de dados com dados de teste
- Usuários pré-configurados para testes

### Ambiente de Staging
- Instância Supabase separada para staging
- Dados mais próximos do ambiente de produção
- Testes de performance e carga

## Métricas de Qualidade

- **Cobertura de código**: Mínimo de 80% para hooks e funções de migração
- **Testes passando**: 100% dos testes devem passar antes da implantação
- **Tempo de migração**: A migração de dados não deve levar mais de 30 segundos
- **Performance**: Tempo de resposta médio não deve exceder 300ms

## Cronograma de Testes

| Semana | Atividade |
|--------|-----------|
| Semana 1 | Configuração do ambiente de testes e implementação de testes unitários |
| Semana 2 | Implementação de testes de integração |
| Semana 3 | Implementação de testes E2E e execução de testes de segurança |
| Semana 4 | Correção de bugs e ajustes finais |

## Feedback e Revisão

Este documento deve ser revisado pela equipe técnica para garantir que todos os cenários críticos estejam cobertos pelos testes.

## Histórico de Revisões

| Versão | Data | Autor | Descrição |
|--------|------|-------|-----------|
| 1.0 | [DATA ATUAL] | [AUTOR] | Versão inicial da estratégia de testes |
</file>

<file path="memory-bank/specialized/troubleshooting.md">
# Solução de Problemas - Migração Supabase

**Status**: [CURRENT] | Última atualização: 23/09/2023 | Versão: 1.0

## Introdução
Este documento cataloga problemas comuns que podem ocorrer durante a migração do MyNeuroApp para o Supabase, junto com suas soluções e estratégias de mitigação.

## Resumo Executivo
Durante a migração do armazenamento local para o Supabase, vários desafios técnicos podem surgir. Este guia fornece respostas rápidas para problemas frequentes, minimizando o tempo de resolução e garantindo consistência nas abordagens da equipe.

## Pontos-Chave
- Soluções para problemas comuns de autenticação
- Estratégias para lidar com erros de migração de dados
- Abordagens para resolver questões de RLS (Row Level Security)
- Otimizações para melhorar a performance
- Alternativas para funcionalidades offline

## Problemas de Autenticação

### Erro: "Não foi possível fazer login com essas credenciais"

**Sintoma**: Usuário não consegue fazer login apesar de ter credenciais corretas.

**Possíveis Causas**:
1. Email ou senha incorretos no sistema
2. Conta criada com outro método (ex: Google OAuth vs. email/senha)
3. Problemas com a configuração do provedor de autenticação

**Soluções**:
```typescript
// Verificar o método de autenticação usado
const { data, error } = await supabase
  .from('profiles')
  .select('auth_provider')
  .eq('email', email)
  .single();

if (data?.auth_provider !== 'email') {
  // Informar o usuário sobre o método correto
  showMessage(`Você se registrou usando ${data?.auth_provider}. Por favor, use este método para login.`);
}
```

### Erro: "Token expirado ou inválido"

**Sintoma**: Usuário é desconectado inesperadamente ou não consegue acessar rotas protegidas.

**Possíveis Causas**:
1. Token JWT expirado
2. Token armazenado incorretamente
3. Problemas com o middleware de autenticação

**Soluções**:
1. Implementar refresh automático de token:
```typescript
// No middleware.ts
export const middleware = async (req: NextRequest) => {
  const { supabase, response } = createRouteHandlerClient(req);
  
  try {
    // Tenta refreshar o token automaticamente
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session && req.nextUrl.pathname.startsWith('/app')) {
      return NextResponse.redirect(new URL('/auth/login', req.url));
    }
    
    return response;
  } catch (error) {
    console.error('Erro de autenticação:', error);
    return NextResponse.redirect(new URL('/auth/login', req.url));
  }
};
```

2. Limpar localStorage e redirecionar para login:
```typescript
const handleTokenError = () => {
  localStorage.removeItem('supabase.auth.token');
  window.location.href = '/auth/login';
};
```

## Problemas de Migração de Dados

### Erro: "Violação de chave única"

**Sintoma**: A migração de dados falha com erro de duplicação.

**Possíveis Causas**:
1. Dados sendo migrados já existem no Supabase
2. Tentativas repetidas de migração
3. Índices únicos configurados no banco de dados

**Soluções**:
```typescript
// Verificar existência antes de inserir
async function migrateWithUpsert(userId, items, tableName) {
  // Para cada item a ser migrado
  for (const item of items) {
    // Tenta encontrar item existente
    const { data: existing } = await supabase
      .from(tableName)
      .select('id')
      .eq('user_id', userId)
      .eq('external_id', item.id) // ID original do localStorage
      .single();
      
    if (existing) {
      // Atualiza item existente
      await supabase
        .from(tableName)
        .update({ ...item, updated_at: new Date().toISOString() })
        .eq('id', existing.id);
    } else {
      // Insere novo item
      await supabase
        .from(tableName)
        .insert([{ ...item, user_id: userId }]);
    }
  }
}
```

### Erro: "Dados inconsistentes após migração"

**Sintoma**: Após a migração, os dados não correspondem ao estado original.

**Possíveis Causas**:
1. Transformação incorreta de dados
2. Migração parcial devido a erros
3. Problemas de concorrência durante a migração

**Soluções**:
1. Implementar verificação pós-migração:
```typescript
async function validateMigration(userId, tableName, localItems) {
  // Obter todos os itens migrados
  const { data: migrated } = await supabase
    .from(tableName)
    .select('*')
    .eq('user_id', userId);
    
  // Verificar contagem
  if (localItems.length !== migrated.length) {
    console.error(`Migração incompleta. Local: ${localItems.length}, Migrado: ${migrated.length}`);
    return false;
  }
  
  // Verificar dados críticos
  for (const local of localItems) {
    const migrated = migrated.find(m => m.external_id === local.id);
    if (!migrated || migrated.content !== local.content) {
      console.error(`Inconsistência nos dados: ${local.id}`);
      return false;
    }
  }
  
  return true;
}
```

2. Implementar migração em transação (usando funções PostgreSQL):
```sql
-- Função no Supabase SQL Editor
CREATE OR REPLACE FUNCTION migrate_user_data(
  p_user_id UUID,
  p_priorities JSONB,
  p_sleep_records JSONB,
  p_medications JSONB
) RETURNS BOOLEAN AS $$
BEGIN
  -- Deletar dados existentes
  DELETE FROM priorities WHERE user_id = p_user_id;
  DELETE FROM sleep_records WHERE user_id = p_user_id;
  DELETE FROM medications WHERE user_id = p_user_id;
  
  -- Inserir novos dados
  INSERT INTO priorities 
    SELECT * FROM jsonb_populate_recordset(null::priorities, p_priorities);
  
  INSERT INTO sleep_records 
    SELECT * FROM jsonb_populate_recordset(null::sleep_records, p_sleep_records);
    
  INSERT INTO medications 
    SELECT * FROM jsonb_populate_recordset(null::medications, p_medications);
    
  RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
  -- Rollback acontece automaticamente
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql;
```

## Problemas com Row Level Security (RLS)

### Erro: "Permissão negada para tabela X"

**Sintoma**: Operações CRUD falham com erro de permissão, apesar do usuário estar autenticado.

**Possíveis Causas**:
1. Políticas RLS mal configuradas
2. Token de autenticação não está sendo enviado corretamente
3. Usuário tentando acessar dados de outro usuário

**Soluções**:
1. Verificar e corrigir políticas RLS:
```sql
-- Exemplo de política RLS correta para tabela priorities
CREATE POLICY "Usuários podem ler suas próprias prioridades" 
ON priorities FOR SELECT 
USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem inserir suas próprias prioridades" 
ON priorities FOR INSERT 
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem atualizar suas próprias prioridades" 
ON priorities FOR UPDATE 
USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem deletar suas próprias prioridades" 
ON priorities FOR DELETE 
USING (auth.uid() = user_id);
```

2. Garantir que o user_id está sendo definido corretamente:
```typescript
const addPriority = async (priority) => {
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user) {
    throw new Error('Usuário não autenticado');
  }
  
  const { data, error } = await supabase
    .from('priorities')
    .insert({
      ...priority,
      user_id: user.id // Garantir que user_id é o ID do usuário autenticado
    });
    
  // Resto da implementação...
};
```

## Problemas de Performance

### Problema: "Carregamento lento de dados"

**Sintoma**: As operações de leitura estão demorando muito mais que no localStorage.

**Possíveis Causas**:
1. Consultas ineficientes
2. Muitos dados sendo retornados
3. Conexão de rede lenta
4. Falta de índices no banco de dados

**Soluções**:
1. Otimizar consultas para selecionar apenas os campos necessários:
```typescript
// Antes
const { data } = await supabase.from('priorities').select('*');

// Depois - selecionar apenas campos necessários
const { data } = await supabase
  .from('priorities')
  .select('id, content, due_date, completed')
  .order('created_at', { ascending: false })
  .limit(20); // Limitar número de resultados
```

2. Implementar paginação:
```typescript
const PAGE_SIZE = 10;

const getPrioritiesPaginated = async (page = 0) => {
  const { data, error } = await supabase
    .from('priorities')
    .select('*')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false })
    .range(page * PAGE_SIZE, (page + 1) * PAGE_SIZE - 1);
    
  return { data, error, hasMore: data?.length === PAGE_SIZE };
};
```

3. Adicionar índices no banco de dados:
```sql
-- Adicionar índice para melhorar performance de consultas por user_id
CREATE INDEX idx_priorities_user_id ON priorities(user_id);

-- Índice para ordenação por data
CREATE INDEX idx_priorities_created_at ON priorities(created_at DESC);

-- Índice composto para consultas frequentes
CREATE INDEX idx_priorities_user_completed ON priorities(user_id, completed);
```

## Problemas de Funcionalidade Offline

### Problema: "Perda de dados ao usar offline"

**Sintoma**: Dados inseridos offline não são sincronizados quando o usuário volta a ficar online.

**Possíveis Causas**:
1. Lógica de sincronização não implementada
2. Falha na detecção do estado da conexão
3. Conflitos entre dados offline e online

**Soluções**:
1. Implementar uma solução robusta de detecção de conexão:
```typescript
function useNetworkStatus() {
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' && typeof navigator.onLine === 'boolean' 
      ? navigator.onLine 
      : true
  );
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return { isOnline };
}
```

2. Armazenar alterações offline em IndexedDB e sincronizar quando online:
```typescript
// Usando Dexie.js para IndexedDB
const db = new Dexie('MyNeuroAppOffline');
db.version(1).stores({
  pendingOperations: '++id, table, operation, data, timestamp'
});

// Executar ou enfileirar operações
async function executeOrQueue(operation, table, data) {
  const { isOnline } = useNetworkStatus();
  
  if (isOnline) {
    // Executar online
    return await executeOperation(operation, table, data);
  } else {
    // Enfileirar para execução posterior
    await db.pendingOperations.add({
      table,
      operation,
      data,
      timestamp: new Date().toISOString()
    });
    
    return { success: true, isOffline: true };
  }
}

// Sincronizar quando online
async function syncPendingOperations() {
  const pendingOps = await db.pendingOperations.toArray();
  
  for (const op of pendingOps) {
    try {
      await executeOperation(op.operation, op.table, op.data);
      await db.pendingOperations.delete(op.id);
    } catch (error) {
      console.error('Erro ao sincronizar:', error);
      // Tenta novamente na próxima sincronização
    }
  }
}

// Detectar quando volta a ficar online
useEffect(() => {
  if (isOnline) {
    syncPendingOperations();
  }
}, [isOnline]);
```

## Problemas com Supabase SDK

### Erro: "Incompatibilidade de versão do SDK"

**Sintoma**: Erros de tipo ou funções não encontradas ao usar o Supabase SDK.

**Possíveis Causas**:
1. Versões incompatíveis de pacotes Supabase
2. Uso de APIs obsoletas
3. Atualizações recentes do SDK que quebram compatibilidade

**Soluções**:
1. Garantir que todas as dependências Supabase tenham versões compatíveis:
```json
// package.json
{
  "dependencies": {
    "@supabase/supabase-js": "^2.32.0",
    "@supabase/auth-helpers-nextjs": "^0.7.4",
    "@supabase/auth-helpers-react": "^0.4.2"
  }
}
```

2. Seguir o padrão recomendado para criar clientes em Next.js:
```typescript
// lib/supabase.ts - Cliente do navegador
import { createBrowserClient } from '@supabase/auth-helpers-nextjs';

export const createClient = () => {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
};

// No middleware.ts e route handlers
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

export async function POST(request: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  // ...
}
```

## Resolução de Conflitos

### Problema: "Conflitos ao editar em múltiplos dispositivos"

**Sintoma**: Alterações feitas em um dispositivo sobrescrevem alterações feitas em outro dispositivo.

**Possíveis Causas**:
1. Falta de estratégia de resolução de conflitos
2. Ausência de versionamento de dados
3. Falta de timestamp para controle de modificações

**Soluções**:
1. Implementar sistema de versionamento otimista:
```typescript
async function updateWithVersion(tableName, id, updates) {
  // Obter versão atual
  const { data: current } = await supabase
    .from(tableName)
    .select('version, updated_at')
    .eq('id', id)
    .single();
    
  if (!current) return { error: 'Item não encontrado' };
  
  // Verificar se a versão local é a mais recente
  if (updates.version && updates.version < current.version) {
    return { 
      error: 'Conflito de versão', 
      conflictType: 'version',
      serverData: current 
    };
  }
  
  // Atualizar com incremento de versão
  const { data, error } = await supabase
    .from(tableName)
    .update({
      ...updates,
      version: (current.version || 0) + 1,
      updated_at: new Date().toISOString()
    })
    .eq('id', id)
    .select();
    
  return { data, error };
}
```

2. Implementar merge de dados em caso de conflito:
```typescript
function mergeChanges(localData, serverData) {
  // Estratégia simples: usar o mais recente por campo
  const merged = { ...localData };
  
  for (const key in serverData) {
    // Se o servidor tem dados mais recentes para este campo
    if (serverData[key + '_updated_at'] > localData[key + '_updated_at']) {
      merged[key] = serverData[key];
      merged[key + '_updated_at'] = serverData[key + '_updated_at'];
    }
  }
  
  return merged;
}
```

## Feedback e Melhorias

Este documento será atualizado continuamente à medida que novos problemas e soluções forem identificados. Toda a equipe de desenvolvimento deve contribuir com novos problemas encontrados e suas respectivas soluções.

## Histórico de Revisões

| Data | Versão | Autor | Aprovador | Alterações |
|------|--------|-------|-----------|------------|
| 23/09/2023 | 1.0 | DevTeam | TechLead | Versão inicial do documento |

## Changelog

- 2023-09-23: Criação do documento de solução de problemas (v1.0)
</file>

<file path="memory-bank/templates/document_template.md">
# [Título do Documento]

## Status: [STATUS] | Última Atualização: [DATA] | Versão: [X.Y]

## Introdução
[Breve descrição do propósito deste documento - 2-3 frases que explicam o que este documento contém e por que ele existe]

## Resumo Executivo
[Um parágrafo conciso (4-6 frases) resumindo os pontos mais importantes do documento para leitura rápida]

## Pontos-Chave [IMPORTANTE]
- [Ponto-chave 1]
- [Ponto-chave 2]
- [Ponto-chave 3]
- [Ponto-chave 4]
- [Ponto-chave 5]
- [Ponto-chave 6]

## [Seção 1]

### [Subseção 1.1]
[Conteúdo da subseção]

### [Subseção 1.2]
[Conteúdo da subseção]

## [Seção 2]

### [Subseção 2.1]
[Conteúdo da subseção]

### [Subseção 2.2]
[Conteúdo da subseção]

## [Seção 3]

### [Subseção 3.1]
[Conteúdo da subseção]

### [Subseção 3.2]
[Conteúdo da subseção]

## Feedback

Este documento está aberto a sugestões e melhorias. Por favor, forneça feedback sobre:
- [Aspecto específico para feedback 1]
- [Aspecto específico para feedback 2]
- [Aspecto específico para feedback 3]

## Histórico de Revisões

| Data | Versão | Autor | Mudanças |
|------|--------|-------|----------|
| [Data] | [X.Y] | [Autor] | [Descrição das mudanças] |

## Changelog

- **DOC-[AAAAMMDD]-[X.Y]**: [Descrição concisa da mudança]
</file>

<file path="memory-bank/activeContext.md">
# Contexto Ativo

**Status**: [CURRENT] | Última atualização: 22/03/2025 | Versão: 2.5

## Introdução
Este documento mantém o contexto atual do projeto, incluindo o trabalho em andamento, decisões recentes e próximos passos.

## Resumo Executivo
Concluímos a migração do módulo de Medicamentos para o Supabase (Fase 5d) e implementamos a funcionalidade de exportação de dados (Fase 6), permitindo aos usuários exportarem seus registros em formato CSV e PDF para compartilhamento com profissionais de saúde ou para backup pessoal.

## Situação Atual

### Fase de Desenvolvimento
Concluímos a migração de todos os módulos principais para Supabase (Fases 5a-5d): Prioridades, Sono, Humor e Medicamentos. Também implementamos a Fase 6 (Exportação de Dados do Supabase), que permite aos usuários baixar seus dados em diferentes formatos.

### Funcionalidades Recentemente Implementadas
1. ✅ Hook `useMedications` para interação com tabelas `medications` e `medication_doses`
2. ✅ Componente `MedicationDataMigration` para migração de dados de medicamentos
3. ✅ Adaptação dos componentes de medicamentos para usar dados do Supabase
4. ✅ Implementação do serviço `supabaseExport.ts` para exportação de dados
5. ✅ Componente `DataExportForm` para interface de exportação
6. ✅ Página de exportação de dados (/saude/exportar-dados)

### Componentes em Foco

#### Módulo de Exportação de Dados
- **supabaseExport.ts**: Serviço implementado para exportação de dados do Supabase em formatos CSV e PDF.
- **DataExportForm.tsx**: Componente de interface desenvolvido para permitir ao usuário selecionar módulos e formato de exportação.
- **exportar-dados/page.tsx**: Página criada para centralizar a funcionalidade de exportação.

#### Componentes de Suporte
- **jsPDF e jsPDF-autotable**: Bibliotecas integradas para geração de documentos PDF formatados.
- **Toast.tsx**: Componente para feedback visual durante a exportação.
- **AuthGuard.tsx**: Proteção da página de exportação para usuários autenticados.

### Decisões Recentes
- [DEC-010](./decisions.md#dec-010-formatos-de-exportação): Optamos por suportar dois formatos de exportação: CSV para análise em planilhas e PDF para compartilhamento com profissionais de saúde.
- [DEC-011](./decisions.md#dec-011-filtragem-de-dados-por-período): Adicionamos a capacidade de filtrar os dados exportados por período para maior flexibilidade.

### Dívida Técnica Relacionada
- [Suporte a Múltiplos Arquivos](./techDebt.md): A exportação de múltiplos módulos em CSV gera arquivos separados em vez de um único arquivo ZIP, o que será melhorado em versões futuras.
- [Personalização de Relatórios](./techDebt.md): A formatação dos PDFs é fixa e não permite personalização pelo usuário.

## Próximas Etapas

### Imediatas (1-2 dias)
1. Corrigir pequenos bugs na interface de exportação
2. Adicionar suporte para download de múltiplos arquivos CSV em um único ZIP
3. Melhorar a formatação dos PDFs gerados
4. Adicionar opção para incluir gráficos nos relatórios PDF

### Curto Prazo (3-7 dias)
1. Implementar funcionalidade de agendamento de exportações recorrentes
2. Desenvolver opção para envio dos dados exportados por email
3. Criar templates personalizáveis para relatórios
4. Adicionar suporte para exportação de dados em formato JSON

### Médio Prazo (1-3 semanas)
1. Implementar compartilhamento direto com profissionais de saúde
2. Adicionar criptografia de ponta-a-ponta para exportações
3. Desenvolver dashboard para visualização integrada de todos os dados de saúde
4. Preparar para lançamento da versão beta pública

## Bloqueadores e Desafios

### Bloqueadores Atuais
- Nenhum bloqueador crítico identificado neste momento

### Desafios
1. **Performance com grandes volumes de dados**: A exportação de muitos registros pode causar lentidão
2. **Formatação consistente**: Garantir que os PDFs gerados sejam bem formatados em todas as situações
3. **Proteção de dados sensíveis**: Implementar medidas adicionais de segurança para dados exportados
4. **Experiência em dispositivos móveis**: Melhorar a experiência de exportação em telas pequenas

## Métricas e KPIs

| Métrica | Meta | Atual | Tendência |
|---------|------|-------|-----------|
| Tempo médio de exportação | <5s | 3.2s | ↔ Estável |
| Taxa de sucesso na exportação | >98% | 99% | ↑ Melhorando |
| Satisfação do usuário com relatórios | >4.5/5 | 4.3/5 | ↑ Melhorando |

## Feedback dos Stakeholders

### Equipe de Produto
- Satisfeita com a implementação da exportação de dados, destacando-a como diferencial competitivo
- Solicita adição de mais opções de personalização para relatórios

### Usuários
- Feedback positivo sobre a facilidade de exportar dados
- Solicitações para adicionar mais formatos de exportação (como Excel)
- Interesse em compartilhamento direto com profissionais de saúde

## Detalhes da Implementação de Exportação

### Estrutura do Serviço de Exportação
O serviço `supabaseExport.ts` implementa:
- Exportação modular que permite selecionar quais dados exportar
- Filtragem por período (data inicial e final)
- Opção entre formatos CSV e PDF
- Formatação amigável de nomes de campos para leitura humana

### Formatos Suportados
1. **CSV**: 
   - Um arquivo por módulo
   - Formato padrão compatível com Excel, Google Sheets, etc.
   - Valores complexos (arrays, objetos) são serializados como JSON

2. **PDF**:
   - Documento formatado com tabelas para cada módulo
   - Cabeçalho com informações do usuário e data de geração
   - Agrupamento de todos os dados em um único arquivo
   - Formatação amigável para impressão e leitura

### Melhorias Planejadas
1. Compactação de múltiplos CSVs em arquivo ZIP
2. Adição de gráficos e visualizações nos PDFs
3. Opções de personalização de relatórios
4. Exportação parcial de campos selecionados
5. Exportação em formatos adicionais (Excel, JSON)

## Histórico de Revisões

| Data | Versão | Autor | Alterações |
|------|--------|-------|------------|
| 22/03/2025 | 2.5 | DevTeam | Atualizado com a implementação da exportação de dados e conclusão da migração de medicamentos |
| 15/10/2023 | 2.4 | DevTeam | Atualizado com a conclusão da migração do módulo de Humor e planejamento para Medicamentos |
| 26/09/2023 | 2.3 | DevTeam | Atualizado com a conclusão da adaptação dos componentes do módulo de Sono e planejamento para o módulo de Humor |
| 25/09/2023 | 2.2 | DevTeam | Atualizado para refletir a migração do módulo de Sono |
| 24/09/2023 | 2.1 | DevTeam | Atualizado com detalhes da implementação da interface de migração |
| 23/09/2023 | 2.0 | DevTeam | Atualização completa focada na migração para Supabase |
| 15/09/2023 | 1.0 | DevTeam | Versão inicial do documento |
</file>

<file path="memory-bank/changelog.md">
# Histórico de Alterações (Changelog)

**Status**: [CURRENT] | Última atualização: 25/03/2025 | Versão: 1.8

## Introdução
Este documento registra todas as alterações significativas na documentação do projeto, fornecendo um histórico cronológico de mudanças, versões e atualizações.

## Resumo Executivo
Este changelog registra atualizações em vários documentos do Memory Bank, com ênfase nas mudanças relacionadas à conclusão da migração do módulo de Sono e planejamento para a migração do módulo de Humor, e mais recentemente, a adição do modo Debug para facilitar o processo de identificação e resolução de problemas.

## Registros de Alterações

### 25/03/2025
- **[Novo]** Criado documento `code_mode.md` (v1.0) para documentar as práticas, procedimentos e diretrizes do Modo Código
- **[Atualização]** `changelog.md` atualizado para v1.8 para registrar a adição do modo Código

### 24/03/2025
- **[Novo]** Criado documento `debug_mode.md` (v1.0) para documentar procedimentos e metodologias de debugging
- **[Atualização]** `index.md` atualizado para v2.3 para incluir referência ao documento de modo Debug
- **[Atualização]** `changelog.md` atualizado para v1.7 para registrar a adição do modo Debug

### 26/09/2023 - Versão 1.6
- **activeContext.md (v2.3)**: Atualizado para refletir a conclusão da adaptação dos componentes do módulo de Sono e início do planejamento para a migração do módulo de Humor.
- **decisions.md (v1.4)**: Adicionada a decisão DEC-007 sobre a estruturação das tabelas de humor.
- **progress.md (v2.2)**: Atualizado o status da fase 5b como concluída e detalhado o planejamento para a fase 5c.

### 25/09/2023 - Versão 1.5
- **activeContext.md (v2.2)**: Atualizado para refletir o progresso na migração do módulo de Sono.
- **decisions.md (v1.3)**: Adicionada a decisão DEC-006 sobre a estruturação das tabelas de sono.
- **progress.md (v2.1)**: Atualizado com o status de implementação do módulo de Sono.
- **techDebt.md (v1.2)**: Adicionados novos itens relacionados à duplicação de código nos hooks.

### 24/09/2023 - Versão 1.4
- **activeContext.md (v2.1)**: Atualizado com detalhes da implementação da interface de migração.
- **modules/sleep.md (v1.1)**: Adicionada documentação detalhada sobre o hook useSleep.
- **specialized/hooks.md (v1.2)**: Atualizado com padrões comuns identificados em hooks de acesso ao Supabase.

### 23/09/2023 - Versão 1.3
- **activeContext.md (v2.0)**: Reestruturação completa focada na migração para Supabase.
- **progress.md (v2.0)**: Reestruturação do documento com novo formato e métricas de progresso.
- **knowledgeGraph.md (v1.1)**: Atualizado com novas relações entre componentes e tabelas do Supabase.

### 22/09/2023 - Versão 1.2
- **decisions.md (v1.2)**: Adicionada a decisão DEC-005 sobre verificação de duplicação na migração.
- **progress.md (v1.3)**: Atualizado com a conclusão da migração do módulo de Prioridades.
- **specialized/migration.md (v1.0)**: Criado documento sobre estratégias de migração de dados.

### 15/09/2023 - Versão 1.1
- **activeContext.md (v1.2)**: Atualizado com o foco na migração para Supabase.
- **decisions.md (v1.1)**: Adicionadas as decisões DEC-003 e DEC-004.
- **progress.md (v1.2)**: Adicionado status da implementação do módulo de Medicamentos.
- **techDebt.md (v1.1)**: Criação inicial do documento com registro de dívidas técnicas.

### 01/09/2023 - Versão 1.0
- **index.md (v1.0)**: Criação do índice inicial do Memory Bank.
- **activeContext.md (v1.0)**: Versão inicial com contexto do projeto.
- **decisions.md (v1.0)**: Versão inicial com as decisões fundamentais DEC-001 e DEC-002.
- **progress.md (v1.0)**: Versão inicial com status das fases do projeto.
- **README.md (v1.0)**: Documentação inicial do propósito do Memory Bank.

## Convenções de Versionamento

### Documentos
- **Alterações Maiores**: Incremento no primeiro número (v1.0 → v2.0)
- **Alterações Menores**: Incremento no segundo número (v1.0 → v1.1)
- **Correções**: Adição de um terceiro número para correções (v1.1 → v1.1.1)

### Changelog
- **Versões Principais**: Correspondem a marcos importantes no projeto
- **Versões Menores**: Registram atualizações significativas em documentos específicos

## Observações

### Documentos frequentemente atualizados
- **activeContext.md**: Atualizado a cada mudança significativa de foco ou progresso
- **progress.md**: Atualizado quando fases são concluídas ou metas são atingidas
- **decisions.md**: Atualizado quando novas decisões técnicas são tomadas

### Documentos raramente atualizados
- **README.md**: Atualizado apenas quando há mudanças fundamentais na estrutura do Memory Bank
- **index.md**: Atualizado quando novos documentos são adicionados ou reorganizados

## Histórico de Revisões

| Data | Versão | Autor | Alterações |
|------|--------|-------|------------|
| 26/09/2023 | 1.6 | DevTeam | Adicionadas entradas para atualizações relacionadas à conclusão da migração do módulo de Sono e planejamento do módulo de Humor |
| 25/09/2023 | 1.5 | DevTeam | Adicionadas entradas para decisão sobre estrutura de tabelas de sono |
| 24/09/2023 | 1.4 | DevTeam | Adicionadas entradas para documentação do hook useSleep |
| 23/09/2023 | 1.3 | DevTeam | Adicionadas entradas para reestruturação de documentos |
| 22/09/2023 | 1.2 | DevTeam | Adicionadas entradas para migração do módulo de Prioridades |
| 15/09/2023 | 1.1 | DevTeam | Adicionadas entradas para criação de documentos de dívida técnica |
| 01/09/2023 | 1.0 | DevTeam | Versão inicial do documento |
</file>

<file path="memory-bank/code_mode.md">
# Modo Código

**Status**: [CURRENT] | Última atualização: 25/03/2025 | Versão: 1.0

## Introdução
Este documento define as práticas, procedimentos e diretrizes para trabalhar no Modo Código do projeto StayFocus. O Modo Código é centrado na implementação e desenvolvimento de código, com foco em qualidade, reutilização e manutenção da documentação.

## Resumo Executivo
O Modo Código é um dos modos operacionais principais do Memory Bank, focado na implementação e modificação de código, atualização de documentação e controle de qualidade. Este documento estabelece as práticas recomendadas para trabalhar neste modo, garantindo consistência e qualidade no desenvolvimento.

## Pontos-Chave
- O Modo Código foca na implementação e modificação de código-fonte
- As convenções do projeto devem ser seguidas rigorosamente
- A documentação deve ser atualizada em conjunto com alterações de código
- Testes devem ser escritos ou atualizados para todas as implementações
- As alterações devem seguir os padrões arquiteturais estabelecidos

## Procedimentos do Modo Código

### Inicialização
1. Ler o arquivo activeContext.md para entender o foco atual de desenvolvimento
2. Consultar systemPatterns.md para entender os padrões arquiteturais
3. Revisar codeDocMap.md para identificar a documentação relacionada ao código-alvo
4. Verificar decisions.md para decisões técnicas relevantes
5. Avaliar techDebt.md para identificar oportunidades de melhoria durante o desenvolvimento

### Durante o Desenvolvimento
1. Seguir consistentemente os padrões de código estabelecidos
2. Implementar código autoexplicativo com nomes claros e semânticos
3. Adicionar comentários apenas onde necessário para explicar "por quê", não "como"
4. Estruturar o código seguindo os princípios de DRY (Don't Repeat Yourself)
5. Desenvolver testes para novas funcionalidades
6. Verificar impactos em outros componentes ou módulos
7. Documentar arquitetura e decisões de design importantes

### Antes do Commit
1. Executar todos os testes relevantes
2. Verificar a conformidade com os linters e formatos estabelecidos
3. Revisar o código para possíveis melhorias ou simplificações
4. Garantir que toda a documentação relacionada esteja atualizada
5. Validar que nenhuma dívida técnica não-intencional foi introduzida

### Após o Desenvolvimento
1. Atualizar activeContext.md com as mudanças implementadas
2. Documentar decisões técnicas em decisions.md, se aplicável
3. Registrar qualquer dívida técnica intencional em techDebt.md
4. Atualizar codeDocMap.md com novas relações código-documentação
5. Registrar as alterações em changelog.md

## Tipos de Tarefas

### Implementação de Novas Funcionalidades
- Iniciar com uma definição clara dos requisitos
- Consultar systemPatterns.md para entender como a nova funcionalidade se encaixa na arquitetura
- Desenvolver seguindo o padrão TDD (Test-Driven Development) quando apropriado
- Seguir um processo de design incremental
- Documentar em parallel com o desenvolvimento

### Refatoração de Código Existente
- Identificar claramente o objetivo da refatoração
- Garantir cobertura de testes adequada antes de começar
- Fazer alterações incrementais e testáveis
- Manter a compatibilidade com interfaces existentes, a menos que explicitamente planejado para mudança
- Documentar as melhorias e razões para a refatoração

### Correção de Bugs
- Reproduzir o bug de forma confiável
- Criar um teste que demonstre o bug antes de corrigi-lo
- Identificar a causa raiz antes de aplicar correções
- Considerar o impacto da correção em outras partes do sistema
- Documentar a natureza do bug e da correção em debug_mode.md ou no sistema de rastreamento de problemas

### Otimização de Performance
- Estabelecer uma linha de base mensurável antes da otimização
- Identificar gargalos através de profiling e métricas
- Priorizar otimizações com maior impacto
- Validar que a otimização não compromete a qualidade ou manutenibilidade do código
- Documentar os ganhos de performance e abordagens utilizadas

## Melhores Práticas

### Padrões de Código
- Usar TypeScript para tirar proveito da verificação de tipos
- Implementar componentes React usando funções (não classes)
- Utilizar hooks para lógica reutilizável
- Seguir o padrão de "apresentação/contêiner" para componentes de UI
- Aplicar nomes descritivos para funções, variáveis e componentes

### Gerenciamento de Estado
- Preferir useState e useReducer para estado local
- Utilizar Context API para estados que precisam ser compartilhados entre componentes
- Evitar props drilling (passagem excessiva de props)
- Considerar o uso de bibliotecas de gerenciamento de estado para casos complexos
- Documentar fluxos de dados complexos

### Integração com Supabase
- Seguir os padrões estabelecidos nos hooks personalizados para Supabase
- Utilizar as políticas de RLS (Row Level Security) para segurança de dados
- Implementar tratamento de erros consistente em todas as operações de banco de dados
- Garantir que as queries sejam otimizadas para performance
- Documentar todas as tabelas, relacionamentos e políticas

### Testes
- Escrever testes unitários para lógica de negócios
- Criar testes de integração para fluxos complexos
- Utilizar testes de componentes para validar o comportamento da UI
- Manter uma cobertura de testes adequada para áreas críticas
- Automatizar testes como parte do processo de CI/CD

## Ferramentas e Recursos

### Ferramentas de Desenvolvimento
- Visual Studio Code com extensões recomendadas
- ESLint e Prettier para formatação e linting
- TypeScript para verificação de tipos
- Jest para testes
- React DevTools para debugging de componentes

### Recursos de Documentação
- systemPatterns.md para arquitetura global
- codeDocMap.md para mapeamento código-documentação
- decisions.md para decisões técnicas importantes
- templates/feature_template.md para documentação de novas funcionalidades

## Histórico de Revisões

| Data | Versão | Autor | Alterações |
|------|--------|-------|------------|
| 25/03/2025 | 1.0 | DevTeam | Versão inicial do documento |
</file>

<file path="memory-bank/debug_mode.md">
# Modo Debug

**Status**: [CURRENT] | Última atualização: 24/03/2025 | Versão: 1.0

## Introdução
Este documento define o contexto e as abordagens para o modo Debug no projeto StayFocus, focando na identificação e resolução de problemas, bem como na otimização de desempenho.

## Resumo Executivo
O modo Debug do StayFocus estabelece procedimentos sistemáticos para investigação de problemas, correção de erros e otimização de performance, permitindo a manutenção da estabilidade e qualidade do aplicativo.

## Pontos-Chave
- O modo Debug foca na identificação e resolução de problemas
- Utiliza ferramentas de diagnóstico e monitoramento
- Segue abordagem sistemática para investigação de erros
- Prioriza melhorias de performance e experiência do usuário
- Mantém documentação atualizada sobre bugs e suas soluções

## Ferramentas e Metodologias

### Ferramentas de Diagnóstico
- Console de desenvolvedor do navegador (Chrome DevTools, Firefox DevTools)
- React DevTools para depuração de componentes
- Ferramentas de monitoramento do Supabase
- Vercel Analytics e logs de deploy
- Sentry para captura e análise de erros

### Metodologia de Debugging
1. **Reprodução do problema**: Identificar e documentar passos para reproduzir o bug consistentemente
2. **Isolamento**: Determinar em qual componente ou módulo o problema ocorre
3. **Análise de logs**: Examinar logs de erro e comportamentos inesperados
4. **Depuração interativa**: Utilizar breakpoints e ferramentas de inspeção
5. **Correção**: Implementar solução e verificar se o problema foi resolvido
6. **Testes**: Desenvolver testes para evitar regressões futuras
7. **Documentação**: Registrar o problema e sua solução

## Áreas Comuns de Problemas

### Frontend
- Renderização e atualização de componentes React
- Gerenciamento de estado e ciclo de vida
- Desempenho em dispositivos móveis
- Compatibilidade entre navegadores
- Problemas de estilo e layout responsivo

### Backend e Dados
- Comunicação com Supabase (queries, mutations)
- Sincronização e persistência de dados
- Autenticação e autorização
- Migração e integridade de dados
- Performance de queries

### Integração e Deployment
- Pipeline de CI/CD no Vercel
- Configuração de ambiente
- Variáveis de ambiente
- Dependências e pacotes

## Procedimentos para Debugging

### Para Problemas de Interface
1. Inspecionar elementos e estilos no DevTools
2. Verificar ciclo de vida dos componentes com React DevTools
3. Examinar console para erros e warnings
4. Testar em diferentes navegadores e dispositivos
5. Isolar problemas específicos em componentes

### Para Problemas de Dados
1. Validar queries no console do Supabase
2. Verificar permissões e políticas de segurança
3. Examinar logs de erros no Supabase
4. Verificar integridade das relações entre tabelas
5. Testar migração de dados em ambiente controlado

### Para Problemas de Performance
1. Analisar performance com DevTools (Network, Performance)
2. Identificar gargalos em renderização, queries ou processamento
3. Otimizar queries e estrutura de dados
4. Implementar estratégias de caching e memoização
5. Reduzir re-renderizações desnecessárias

## Registro e Acompanhamento

### Sistema de Tracking
- Utilizar GitHub Issues para registrar bugs
- Classificar por severidade e impacto
- Atribuir responsáveis para correção
- Documentar solução após resolução

### Documentação de Erros Recorrentes
Manter biblioteca de problemas comuns e suas soluções para referência rápida.

## Medidas Preventivas

### Testes Automatizados
- Implementar testes unitários para funções críticas
- Desenvolver testes de integração para fluxos importantes
- Estabelecer testes end-to-end para cenários de usuário

### Code Reviews
- Revisar código para identificar potenciais problemas
- Utilizar linters e formatadores
- Aplicar padrões de código consistentes

## Próximos Passos para Melhoria

1. Implementar sistema de logging mais abrangente
2. Desenvolver dashboard para monitoramento de performance
3. Expandir cobertura de testes automatizados
4. Criar biblioteca de casos de debug comuns
5. Estabelecer processo de debug colaborativo

## Histórico de Revisões

| Data | Versão | Autor | Alterações |
|------|--------|-------|------------|
| 24/03/2025 | 1.0 | DevTeam | Versão inicial do documento |
</file>

<file path="memory-bank/decisions.md">
# Decisões Técnicas e Arquiteturais

**Status**: [CURRENT] | Última atualização: 26/09/2023 | Versão: 1.4

## Resumo Executivo
Este documento registra decisões importantes relacionadas à arquitetura, tecnologia e implementação do MyNeuroApp. Cada decisão inclui contexto, alternativas consideradas, solução escolhida e impactos. Foi adicionada uma nova seção sobre decisões relacionadas à migração de dados do módulo Sono e à estruturação das tabelas do módulo de Humor.

## Índice de Decisões
1. [DEC-001: Escolha do Next.js 13](#dec-001-escolha-do-nextjs-13)
2. [DEC-002: Migração para Supabase](#dec-002-migração-para-supabase)
3. [DEC-003: Estratégia de Autenticação](#dec-003-estratégia-de-autenticação)
4. [DEC-004: Abordagem de Migração Modular](#dec-004-abordagem-de-migração-modular)
5. [DEC-005: Verificação de Duplicação na Migração](#dec-005-verificação-de-duplicação-na-migração)
6. [DEC-006: Estruturação das Tabelas de Sono](#dec-006-estruturação-das-tabelas-de-sono)
7. [DEC-007: Estruturação das Tabelas de Humor](#dec-007-estruturação-das-tabelas-de-humor)

## DEC-001: Escolha do Next.js 13
**Data**: 01/06/2023  
**Status**: Implementado  
**Autor**: Tech Lead  

**Contexto**:  
Necessidade de escolher um framework React moderno para desenvolver uma aplicação web responsiva com bom SEO e experiência de desenvolvimento.

**Alternativas Consideradas**:
1. Create React App
2. Remix
3. Gatsby
4. Next.js 13

**Decisão**:  
Adotar Next.js 13 com App Router para desenvolvimento da aplicação.

**Justificativa**:
- Suporte a Server Components para melhor performance
- Roteamento baseado em sistema de arquivos
- Renderização híbrida (SSR, SSG, ISR)
- Comunidade grande e ativa
- Facilidade de deploy com Vercel

**Implicações**:
- Curva de aprendizado para desenvolvedores não familiarizados com Next.js 13
- Necessidade de planejamento cuidadoso da estrutura de arquivos
- Benefícios de performance e SEO para a aplicação

## DEC-002: Migração para Supabase
**Data**: 15/08/2023  
**Status**: Em implementação  
**Autor**: Tech Lead, DevOps  

**Contexto**:  
O aplicativo inicialmente usava localStorage para persistência de dados, limitando funcionalidades como sincronização entre dispositivos e backup. Necessitamos de uma solução de backend como serviço.

**Alternativas Consideradas**:
1. Firebase
2. Supabase
3. Amplify
4. Backend personalizado com Node.js

**Decisão**:  
Migrar gradualmente do localStorage para Supabase.

**Justificativa**:
- API compatível com PostgreSQL
- Autenticação incorporada
- Políticas de segurança a nível de linha (RLS)
- Open-source e plano gratuito generoso
- APIs para React Native (futura expansão mobile)

**Implicações**:
- Necessidade de migração de dados existentes
- Implementação de estratégias para experiência offline
- Curva de aprendizado para equipe

## DEC-003: Estratégia de Autenticação
**Data**: 01/09/2023  
**Status**: Implementado  
**Autor**: Equipe de Segurança  

**Contexto**:  
Com a migração para Supabase, precisamos implementar autenticação segura e fácil de usar.

**Alternativas Consideradas**:
1. Autenticação exclusiva por email/senha
2. OAuth com provedores populares
3. Autenticação sem senha (magic link)
4. Combinação das opções acima

**Decisão**:  
Implementar autenticação híbrida: email/senha e OAuth (Google), com possibilidade de expansão futura.

**Justificativa**:
- Flexibilidade para usuários
- Segurança robusta
- Facilidade de uso (redução de fricção no registro)
- Suporte nativo no Supabase

**Implicações**:
- Necessidade de tratamento adequado de perfis vindos de diferentes fontes
- Gestão de sessões entre dispositivos
- Configuração de provedores OAuth

## DEC-004: Abordagem de Migração Modular
**Data**: 20/09/2023  
**Status**: Em implementação  
**Autor**: Tech Lead  

**Contexto**:  
A migração do localStorage para Supabase envolve múltiplos módulos da aplicação. Precisamos definir uma estratégia clara.

**Alternativas Consideradas**:
1. Migração completa de uma vez
2. Migração gradual por módulo
3. Sistema híbrido com suporte a ambas fontes de dados

**Decisão**:  
Adotar migração gradual por módulo, começando pelo módulo de Prioridades como piloto.

**Justificativa**:
- Menor risco de perda de dados
- Permite avaliar e ajustar a abordagem entre módulos
- Experiência de usuário mais controlada
- Facilita testes e validação

**Implicações**:
- Complexidade temporária com dois sistemas de armazenamento
- Necessidade de interfaces de migração por módulo
- Documentação clara sobre o estado de cada módulo

## DEC-005: Verificação de Duplicação na Migração
**Data**: 25/09/2023  
**Status**: Implementado  
**Autor**: DevTeam  

**Contexto**:  
Durante a migração de dados de localStorage para Supabase, foi identificado o risco de duplicação quando usuários executam a migração múltiplas vezes.

**Alternativas Consideradas**:
1. Ignorar o problema (permitir duplicação)
2. Bloquear migração após primeira tentativa
3. Verificar e prevenir duplicação durante migração
4. Implementar limpeza periódica de duplicados

**Decisão**:  
Implementar verificação de duplicação durante o processo de migração, tanto para prioridades quanto para registros de sono.

**Justificativa**:
- Previne proliferação de dados redundantes
- Melhora experiência do usuário
- Reduz consumo de recursos no banco de dados
- Mantém integridade dos dados

**Implicações**:
- Aumento da complexidade do código de migração
- Possível impacto de performance para grandes volumes de dados
- Necessidade de critérios claros para determinar duplicação

## DEC-006: Estruturação das Tabelas de Sono
**Data**: 25/09/2023  
**Status**: Implementado  
**Autor**: DevTeam  

**Contexto**:  
A implementação do módulo de Sono no Supabase requer definir a estrutura das tabelas e relacionamentos.

**Alternativas Consideradas**:
1. Tabela única para todos os dados de sono
2. Tabelas separadas para registros e lembretes
3. Estrutura normalizada com tabelas de referência

**Decisão**:  
Implementar duas tabelas principais:
- `sleep_records`: para armazenar registros diários de sono
- `sleep_reminders`: para configurações de lembretes

**Justificativa**:
- Separação clara de responsabilidades
- Facilita consultas e atualizações específicas
- Segue padrões de modelagem relacional
- Preparação para futuros recursos como estatísticas avançadas

**Implicações**:
- Necessidade de manter relacionamentos consistentes
- Implementação de políticas RLS em ambas tabelas
- Hooks de React específicos para cada entidade
- Migrations SQL para criação das estruturas

## DEC-007: Estruturação das Tabelas de Humor
**Data**: 26/09/2023  
**Status**: Implementado  
**Autor**: DevTeam  

**Contexto**:  
A implementação do módulo de Humor no Supabase requer definir a estrutura das tabelas, considerando os requisitos de registro de humor, notas e categorização.

**Alternativas Consideradas**:
1. Tabela única com array de tags
2. Tabela principal com tabela separada para tags
3. Modelo completamente normalizado com múltiplas tabelas
4. Armazenamento JSON para dados não estruturados

**Decisão**:  
Implementar uma única tabela `mood_records` com a seguinte estrutura:
- `id`: UUID (chave primária)
- `user_id`: UUID (referência para auth.users)
- `value`: smallint (valor do humor de 1-5)
- `notes`: text (notas associadas, opcional)
- `tags`: text[] (array de tags, opcional)
- `date`: date (data do registro)
- `created_at`: timestamptz
- `updated_at`: timestamptz

**Justificativa**:
- Simplicidade de implementação e manutenção
- Arrays nativos do PostgreSQL oferecem boa performance para o caso de uso
- Evita joins desnecessários para um volume relativamente pequeno de tags
- Facilita a migração de dados do localStorage
- Mantém consistência com o modelo mental dos usuários na interface existente

**Implicações**:
- Limitações nas operações de filtragem complexas por tags
- Necessidade de usar funções específicas do PostgreSQL para manipulação de arrays
- Simplificação das consultas para recuperar registros completos
- Políticas de segurança mais diretas
- Hook `useHumor` com implementação mais simples

## Histórico de Revisões

| Data | Versão | Autor | Alterações |
|------|--------|-------|------------|
| 26/09/2023 | 1.4 | DevTeam | Adicionada DEC-007 sobre estruturação das tabelas de humor |
| 25/09/2023 | 1.3 | DevTeam | Adicionada DEC-006 sobre estruturação das tabelas de sono |
| 22/09/2023 | 1.2 | DevTeam | Adicionada DEC-005 sobre verificação de duplicação |
| 15/09/2023 | 1.1 | DevTeam | Adicionadas DEC-003 e DEC-004 |
| 01/07/2023 | 1.0 | Tech Lead | Versão inicial com DEC-001 e DEC-002 |
</file>

<file path="memory-bank/index.md">
# Índice do Memory Bank

**Status**: [CURRENT] | Última atualização: 25/03/2025 | Versão: 2.4

## Introdução
Este documento serve como ponto central de navegação para toda a documentação do projeto, fornecendo links rápidos e resumos dos documentos disponíveis no Memory Bank.

## Resumo Executivo
O Memory Bank contém documentação abrangente sobre o projeto MyNeuroApp, cobrindo desde decisões arquiteturais até detalhes de implementação. Atualmente, o foco está na migração dos módulos para o Supabase, com os módulos de Prioridades, Sono, Humor e Medicamentos já migrados, e na implementação de funcionalidades de exportação de dados.

## Documentos Principais

### Documentos Core
| Documento | Versão | Última Atualização | Descrição |
|-----------|--------|---------------------|-----------|
| [ActiveContext](./activeContext.md) | 2.5 | 22/03/2025 | Contexto atual do projeto, incluindo trabalho em andamento, decisões recentes e próximos passos. Foco na exportação de dados e conclusão da migração. |
| [Progress](./progress.md) | 2.2 | 26/09/2023 | Status detalhado do projeto, incluindo o que está funcionando, o que falta construir e problemas conhecidos. |
| [Decisions](./decisions.md) | 1.4 | 26/09/2023 | Registro de decisões técnicas e arquiteturais importantes, incluindo a estruturação das tabelas de humor. |
| [TechDebt](./techDebt.md) | 1.2 | 25/09/2023 | Catálogo de dívidas técnicas identificadas, com priorização e planos de mitigação. |
| [Debug Mode](./debug_mode.md) | 1.0 | 24/03/2025 | Procedimentos e metodologias para identificação e resolução de problemas no sistema. |
| [Code Mode](./code_mode.md) | 1.0 | 25/03/2025 | Práticas, procedimentos e diretrizes para implementação e desenvolvimento de código. |

### Documentos de Navegação
| Documento | Versão | Última Atualização | Descrição |
|-----------|--------|---------------------|-----------|
| [Changelog](./changelog.md) | 1.7 | 24/03/2025 | Histórico cronológico de todas as alterações na documentação. |
| [KnowledgeGraph](./navigation/knowledgeGraph.md) | 1.1 | 23/09/2023 | Mapa visual das relações entre componentes do projeto. |
| [Timeline](./navigation/timeline.md) | 1.0 | 15/09/2023 | Linha do tempo do projeto com marcos importantes. |

### Documentação Especializada
| Documento | Versão | Última Atualização | Descrição |
|-----------|--------|---------------------|-----------|
| [Hooks](./specialized/hooks.md) | 1.2 | 24/09/2023 | Documentação sobre padrões de hooks React usados no projeto. |
| [Migration](./specialized/migration.md) | 1.0 | 22/09/2023 | Estratégias e padrões para migração de dados de localStorage para Supabase. |
| [Authentication](./specialized/authentication.md) | 1.0 | 15/09/2023 | Detalhes sobre o sistema de autenticação com Supabase. |

### Documentação de Módulos
| Documento | Versão | Última Atualização | Descrição |
|-----------|--------|---------------------|-----------|
| [Prioridades](./modules/priorities.md) | 1.1 | 22/09/2023 | Documentação do módulo de Prioridades, incluindo hooks, componentes e migração. |
| [Sono](./modules/sleep.md) | 1.1 | 24/09/2023 | Documentação do módulo de Sono, incluindo estrutura de tabelas, hooks e migração. |
| [Humor](./modules/mood.md) | 0.8 | 15/09/2023 | Documentação do módulo de Humor, parcialmente atualizada com planejamento para migração. |
| [Medicamentos](./modules/medications.md) | 0.7 | 15/09/2023 | Documentação inicial do módulo de Medicamentos com foco na implementação localStorage. |

## Visões Específicas

### Visões por Papel
| Documento | Versão | Última Atualização | Descrição |
|-----------|--------|---------------------|-----------|
| [Desenvolvedor](./views/developer_view.md) | 1.1 | 23/09/2023 | Visão técnica focada na implementação e desenvolvimento. |
| [Product Owner](./views/product_owner_view.md) | 1.0 | 15/09/2023 | Visão com foco em progresso, funcionalidades e roadmap. |

### Visões por Tarefa
| Documento | Versão | Última Atualização | Descrição |
|-----------|--------|---------------------|-----------|
| [Onboarding](./views/onboarding_view.md) | 1.0 | 15/09/2023 | Guia para novos membros da equipe. |
| [Migração](./views/migration_view.md) | 1.1 | 23/09/2023 | Visão específica para o processo de migração para Supabase. |

## Atualizações Recentes
As atualizações mais recentes na documentação (últimos 7 dias):

### 25/03/2025
- **[Code Mode](./code_mode.md)**: Criado na v1.0 com práticas, procedimentos e diretrizes para o desenvolvimento de código.
- **[Changelog](./changelog.md)**: Atualizado para v1.8 para registrar a adição do modo Código.
- **[Index](./index.md)**: Atualizado para v2.4 para incluir referência ao documento de modo Código.

### 24/03/2025
- **[Debug Mode](./debug_mode.md)**: Criado na v1.0 com procedimentos e metodologias para debugging.
- **[Changelog](./changelog.md)**: Atualizado para v1.7 para registrar a adição do modo Debug.
- **[Index](./index.md)**: Atualizado para v2.3 para incluir referência ao documento de modo Debug.

### 26/09/2023
- **[ActiveContext](./activeContext.md)**: Atualizado para v2.3 com a conclusão da adaptação dos componentes do módulo de Sono e planejamento para a migração do módulo de Humor.
- **[Decisions](./decisions.md)**: Atualizado para v1.4 com a adição da decisão DEC-007 sobre a estruturação das tabelas de humor.
- **[Changelog](./changelog.md)**: Atualizado para v1.6 com as entradas das alterações mais recentes.

### 25/09/2023
- **[Decisions](./decisions.md)**: Atualizado para v1.3 com a adição da decisão DEC-006 sobre a estruturação das tabelas de sono.
- **[TechDebt](./techDebt.md)**: Atualizado para v1.2 com a adição de novos itens relacionados à duplicação de código nos hooks.

### 24/09/2023
- **[ActiveContext](./activeContext.md)**: Atualizado para v2.1 com detalhes da implementação da interface de migração.
- **[Sleep](./modules/sleep.md)**: Atualizado para v1.1 com documentação detalhada sobre o hook useSleep.
- **[Hooks](./specialized/hooks.md)**: Atualizado para v1.2 com padrões comuns identificados em hooks de acesso ao Supabase.

## Próximas Atualizações Planejadas
Documentos que serão atualizados em breve:

- **[Mood](./modules/mood.md)**: Será atualizado para v1.0 com a implementação completa da migração para Supabase.
- **[KnowledgeGraph](./navigation/knowledgeGraph.md)**: Será atualizado com as novas relações do módulo de Humor.
- **[Migration](./specialized/migration.md)**: Será expandido com os aprendizados da migração dos módulos de Prioridades e Sono.

## Histórico de Revisões

| Data | Versão | Autor | Alterações |
|------|--------|-------|------------|
| 24/03/2025 | 2.3 | DevTeam | Atualizado com a adição do documento de Debug Mode e atualizações recentes |
| 26/09/2023 | 2.2 | DevTeam | Atualizado com os documentos modificados relacionados à conclusão da migração do módulo de Sono e planejamento para o módulo de Humor |
| 25/09/2023 | 2.1 | DevTeam | Atualizado com as alterações relacionadas ao módulo de Sono |
| 23/09/2023 | 2.0 | DevTeam | Reestruturação completa do índice com novas seções e categorias |
| 15/09/2023 | 1.1 | DevTeam | Adicionados links para documentação de módulos |
| 01/09/2023 | 1.0 | DevTeam | Versão inicial do documento |

## Links Rápidos

- **Trabalho Atual**: Migração para Supabase - [activeContext.md](core/activeContext.md)
- **Detalhes da Migração**: [migracao_supabase.md](specialized/migracao_supabase.md)
- **Padrões de Hooks**: [hooks_supabase.md](specialized/hooks_supabase.md)

## Tarefas Pendentes no Memory Bank

1. Atualizar `systemPatterns.md` com os novos padrões de armazenamento com Supabase
2. Documentar o fluxo de autenticação e segurança no sistema 
3. Criar um documento para as políticas de Row Level Security (RLS) no Supabase
4. Atualizar `techContext.md` com informações sobre as novas dependências
</file>

<file path="memory-bank/progress.md">
# Progresso do Desenvolvimento

**Status**: [CURRENT] | Última atualização: 22/03/2025 | Versão: 2.3

## Introdução
Este documento rastreia o progresso do desenvolvimento do MyNeuroApp, incluindo funcionalidades concluídas, em andamento e planejadas.

## Resumo Executivo
Concluímos a migração de todos os módulos principais para o Supabase (Prioridades, Sono, Humor e Medicamentos) e implementamos a funcionalidade de exportação de dados em CSV e PDF. Agora estamos focando em melhorar a experiência de exportação e preparar o lançamento beta.

## Progresso por Fase

### Fase 1: Configuração e Estruturação Inicial ✅
- **Status**: Concluída (Set/2023)
- **Objetivo**: Estabelecer a estrutura básica do aplicativo e desenvolver os módulos core usando localStorage
- **Entregáveis**:
  - ✅ Estrutura básica do aplicativo com Next.js
  - ✅ Tema claro/escuro
  - ✅ Armazenamento local com Zustand
  - ✅ Navegação responsiva
  - ✅ Dashboard inicial

### Fase 2: Módulos Principais - Versão 1 ✅
- **Status**: Concluída (Set/2023)
- **Objetivo**: Implementar os módulos principais do aplicativo
- **Entregáveis**:
  - ✅ Módulo de Prioridades
  - ✅ Módulo de Sono
  - ✅ Módulo de Humor
  - ✅ Módulo de Alimentação
  - ✅ Módulo de Medicamentos
  - ✅ Exportação/Importação de dados local

### Fase 3: Autenticação e Backend ✅
- **Status**: Concluída (Set/2023)
- **Objetivo**: Implementar autenticação de usuários e integração com backend
- **Entregáveis**:
  - ✅ Integração com Supabase
  - ✅ Autenticação por email/senha
  - ✅ Autenticação OAuth (Google)
  - ✅ Middleware de proteção de rotas
  - ✅ Perfil de usuário básico

### Fase 4: Migração de Componentes para Servidor ✅
- **Status**: Concluída (Set/2023)
- **Objetivo**: Migrar componentes para o modelo de App Router do Next.js
- **Entregáveis**:
  - ✅ Componentes Server vs. Client
  - ✅ Route Handlers para API
  - ✅ Layouts aninhados
  - ✅ Loading States
  - ✅ Error Boundaries

### Fase 5: Migração de Dados para Supabase ✅
- **Status**: Concluída (Mar/2025)
- **Objetivo**: Migrar armazenamento de dados de localStorage para Supabase
- **Entregáveis**:
  
  #### Fase 5a: Migração do Módulo de Prioridades ✅
  - ✅ Estruturação da tabela `priorities`
  - ✅ Hook `usePriorities`
  - ✅ Componente de interface para migração
  - ✅ Adaptação dos componentes existentes
  
  #### Fase 5b: Migração do Módulo de Sono ✅
  - ✅ Estruturação das tabelas `sleep_records` e `sleep_reminders`
  - ✅ Hook `useSleep`
  - ✅ Componente para migração de dados
  - ✅ Adaptação do visualizador semanal
  - ✅ Adaptação das configurações de lembretes
  
  #### Fase 5c: Migração do Módulo de Humor ✅
  - ✅ Estruturação da tabela `mood_records` 
  - ✅ Hook `useHumor`
  - ✅ Componente para migração de dados
  - ✅ Adaptação do registro diário
  - ✅ Adaptação do visualizador de tendências
  
  #### Fase 5d: Migração do Módulo de Medicamentos ✅
  - ✅ Estruturação das tabelas `medications` e `medication_doses`
  - ✅ Hook `useMedications`
  - ✅ Componente para migração de dados
  - ✅ Adaptação da lista de medicamentos
  - ✅ Adaptação do registro de doses

### Fase 6: Exportação de Dados ✅
- **Status**: Concluída (Mar/2025)
- **Objetivo**: Implementar recursos de exportação de dados do Supabase
- **Entregáveis**:
  - ✅ Exportação em CSV
  - ✅ Exportação em PDF
  - ✅ Filtragem por período
  - ✅ Seleção de módulos para exportação
  - ✅ Interface de usuário para exportação
  - ⏳ Compactação em ZIP para múltiplos arquivos
  - ⏳ Personalização de relatórios

### Fase 7: Sincronização e Funcionalidades Avançadas ⏳
- **Status**: Em Planejamento (Abr/2025)
- **Objetivo**: Implementar sincronização offline/online e funcionalidades avançadas
- **Entregáveis**:
  - ⏳ Funcionamento offline com sincronização posterior
  - ⏳ WebSockets para atualizações em tempo real
  - ⏳ Sistema de notificações push
  - ⏳ Compartilhamento de dados com profissionais
  - ⏳ API pública para integrações

## Progresso por Módulo

### Módulo de Prioridades
- **Armazenamento**: ✅ Migrado para Supabase (Set/2023)
- **Status**: ✅ Completo
- **Funcionalidades**:
  - ✅ Criação, edição, exclusão
  - ✅ Categorização
  - ✅ Prazo (due date)
  - ✅ Filtros e ordenação
  - ✅ Exportação de dados

### Módulo de Sono
- **Armazenamento**: ✅ Migrado para Supabase (Set/2023)
- **Status**: ✅ Completo
- **Funcionalidades**:
  - ✅ Registro de horários
  - ✅ Qualidade do sono
  - ✅ Visualização semanal
  - ✅ Configuração de lembretes
  - ✅ Exportação de dados

### Módulo de Humor
- **Armazenamento**: ✅ Migrado para Supabase (Out/2023)
- **Status**: ✅ Completo
- **Funcionalidades**:
  - ✅ Registro diário
  - ✅ Visualização de tendências
  - ✅ Fatores de influência
  - ✅ Notas de contexto
  - ✅ Exportação de dados

### Módulo de Medicamentos
- **Armazenamento**: ✅ Migrado para Supabase (Mar/2025)
- **Status**: ✅ Completo
- **Funcionalidades**:
  - ✅ Cadastro de medicamentos
  - ✅ Registro de doses
  - ✅ Lembretes de horários
  - ✅ Histórico de doses
  - ✅ Exportação de dados

### Módulo de Alimentação
- **Armazenamento**: ⏳ Ainda usando localStorage
- **Status**: 🔶 Parcial
- **Funcionalidades**:
  - ✅ Registro de refeições
  - ✅ Categorização
  - ⏳ Migração para Supabase
  - ⏳ Exportação de dados

## Funcionalidades Transversais

### Autenticação
- **Status**: ✅ Completo
- **Funcionalidades**:
  - ✅ Registro com email/senha
  - ✅ Login com Google
  - ✅ Recuperação de senha
  - ✅ Perfil básico
  - ✅ Proteção de rotas

### Experiência de Usuário
- **Status**: 🔶 Parcial
- **Funcionalidades**:
  - ✅ Tema claro/escuro
  - ✅ Layout responsivo
  - ✅ Estados de carregamento
  - ✅ Tratamento de erros
  - ⏳ Tour de introdução
  - ⏳ Dicas contextuais

### Exportação/Importação
- **Status**: 🔶 Parcial
- **Funcionalidades**:
  - ✅ Exportação para CSV
  - ✅ Exportação para PDF
  - ✅ Filtragem por período
  - ✅ Seleção de módulos
  - ⏳ Compactação de múltiplos arquivos
  - ⏳ Compartilhamento direto com profissionais

## Métricas de Desenvolvimento

| Métrica | Valor | Tendência |
|---------|-------|-----------|
| Cobertura de código | 72% | ↗ |
| Bugs abertos | 8 | ↘ |
| Tempo médio de resolução de bugs | 3 dias | ↘ |
| Pull requests pendentes | 3 | ↘ |
| Velocidade do sprint | 32 pontos | ↗ |

## Próximos Marcos

1. **Lançamento Beta Fechado** (Abril/2025)
   - Todos os módulos principais migrados para Supabase
   - Exportação de dados completa
   - Correção de bugs críticos
   - Testes com usuários selecionados

2. **Lançamento Beta Público** (Junho/2025)
   - Sincronização offline/online
   - Notificações push
   - API para integrações
   - Melhorias baseadas no feedback da beta fechada

## Bloqueadores Atuais
- Nenhum bloqueador crítico no momento

## Histórico de Revisões

| Data | Versão | Autor | Alterações |
|------|--------|-------|------------|
| 22/03/2025 | 2.3 | DevTeam | Atualização com a conclusão da Fase 5d (Migração de Medicamentos) e Fase 6 (Exportação) |
| 15/10/2023 | 2.2 | DevTeam | Atualização com a conclusão da Fase 5c (Migração de Humor) |
| 26/09/2023 | 2.1 | DevTeam | Atualização com o progresso da Fase 5b (Migração de Sono) |
| 15/09/2023 | 2.0 | DevTeam | Reorganização do documento em fases e módulos |
| 01/09/2023 | 1.0 | DevTeam | Documento inicial de progresso |
</file>

<file path="memory-bank/README.md">
# Memory Bank do MyNeuroApp

## Status: [CURRENT] | Última Atualização: Data Atual | Versão: 1.0

## Introdução
Este diretório contém a documentação completa (Memory Bank) do projeto MyNeuroApp, uma aplicação web para pessoas neurodivergentes. O Memory Bank serve como fonte única de verdade para todos os aspectos do projeto.

## Resumo Executivo
O Memory Bank é um sistema de documentação estruturado que armazena todo o conhecimento do projeto, desde sua visão geral até detalhes técnicos específicos. Ele é projetado para manter uma documentação consistente e atualizada, facilitando a compreensão do projeto por qualquer pessoa que trabalhe nele.

## Pontos-Chave [IMPORTANTE]
- O Memory Bank é a fonte única de verdade para o projeto
- A documentação segue uma estrutura hierárquica clara
- Todos os documentos seguem um formato padronizado
- A atualização regular da documentação é essencial
- O índice (index.md) é o ponto de entrada central

## Estrutura do Memory Bank

```
memory-bank/
│
├── core/                          # Documentação central
│   ├── projectbrief.md            # Visão geral do projeto
│   ├── productContext.md          # Contexto do produto
│   ├── activeContext.md           # Foco atual do desenvolvimento
│   ├── systemPatterns.md          # Padrões técnicos e arquiteturais
│   ├── techContext.md             # Contexto técnico
│   └── progress.md                # Status atual e progresso
│
├── navigation/                    # Documentos de navegação
│   ├── index.md                   # Índice geral (ponto de entrada)
│   ├── knowledgeGraph.md          # Grafo visual de relações
│   ├── timeline.md                # Linha do tempo do projeto
│   ├── changelog.md               # Registro de mudanças
│   └── communicationRegistry.md   # Registro de comunicações
│
├── specialized/                   # Documentação especializada
│   ├── decisions.md               # Registro de decisões
│   ├── techDebt.md                # Dívida técnica
│   ├── codeDocMap.md              # Mapeamento código-documentação
│   ├── llm_patterns.md            # Padrões de interação com LLMs
│   └── code_generation_guidelines.md  # Diretrizes para geração de código
│
├── modules/                       # Documentação por módulo
│   ├── homepage.md                # Módulo da página inicial
│   ├── food.md                    # Módulo de alimentação
│   ├── health.md                  # Módulo de saúde
│   └── ...                        # Outros módulos
│
├── templates/                     # Templates para documentação
│   ├── document_template.md       # Template básico de documento
│   ├── decision_template.md       # Template para decisões
│   └── ...                        # Outros templates
│
├── views/                         # Visualizações específicas
│   ├── developer_view.md          # Visão para desenvolvedores
│   ├── manager_view.md            # Visão para gerentes
│   └── ...                        # Outras visualizações
│
└── README.md                      # Este arquivo
```

## Como Usar o Memory Bank

### Para Novos Membros da Equipe
1. Comece pelo arquivo `navigation/index.md`
2. Leia os documentos core na seguinte ordem:
   - `core/projectbrief.md`
   - `core/productContext.md`
   - `core/activeContext.md`
3. Explore a documentação específica do seu papel utilizando as visualizações em `views/`

### Para Desenvolvedores Atuais
1. Consulte `core/activeContext.md` para entender o foco atual
2. Verifique `core/systemPatterns.md` e `specialized/decisions.md` antes de implementar novas funcionalidades
3. Consulte a documentação específica do módulo em que está trabalhando
4. Atualize a documentação após fazer alterações significativas

### Para Atualizar a Documentação
1. Siga o formato padrão definido nos templates
2. Atualize o status do documento e a data de última atualização
3. Registre a mudança no arquivo `navigation/changelog.md`
4. Atualize o índice (`navigation/index.md`) se necessário
5. Atualize qualquer documentação relacionada que possa ser afetada

## Convenções de Documentação

### Status do Documento
- **[CURRENT]**: Documento atualizado e confiável
- **[NEEDS UPDATE]**: Documento desatualizado que precisa de revisão
- **[DEPRECATED]**: Documento não mais relevante mas mantido para referência
- **[DRAFT]**: Documento em estado de rascunho
- **[REVIEW]**: Documento pronto para revisão
- **[PENDING APPROVAL]**: Documento atualizado aguardando aprovação

### Versionamento
- Versão principal (e.g., 1.0 → 2.0): Mudanças significativas
- Versão secundária (e.g., 1.0 → 1.1): Atualizações menores
- Formato de identificador único: DOC-AAAAMMDD-X.Y

### Formato Padrão dos Documentos
1. Título
2. Status e informações de versão
3. Introdução
4. Resumo Executivo
5. Pontos-Chave
6. Conteúdo Principal (seções específicas)
7. Feedback
8. Histórico de Revisões
9. Changelog

## Manutenção do Memory Bank

### Quando Atualizar
- Após concluir uma nova funcionalidade
- Quando ocorrerem mudanças no planejamento
- Ao tomar decisões técnicas importantes
- Durante revisões periódicas (semanais/mensais)
- Quando identificar inconsistências ou desatualizações

### Processo de Revisão
1. Autor atualiza o documento e altera o status para [REVIEW]
2. Revisor verifica a precisão e completude
3. Feedback é incorporado ou endereçado
4. Documento é aprovado e status alterado para [CURRENT]
5. Alterações são registradas no changelog

## Contribuição

Para contribuir com o Memory Bank:
1. Identifique lacunas ou necessidades de atualização
2. Utilize os templates apropriados
3. Mantenha a estrutura e formato consistentes
4. Submeta para revisão por outro membro da equipe
5. Atualize o índice e referências cruzadas

## Feedback

Este documento está aberto a sugestões e melhorias. Por favor, forneça feedback sobre:
- Clareza da estrutura do Memory Bank
- Facilidade de uso e navegação
- Áreas não cobertas pela documentação atual
- Sugestões para melhorias no processo

## Histórico de Revisões

| Data | Versão | Autor | Mudanças |
|------|--------|-------|----------|
| Data Atual | 1.0 | Equipe | Versão inicial |

## Changelog

- **DOC-20230322-1.0**: Criação do documento README.md
</file>

<file path="memory-bank/techDebt.md">
# Dívida Técnica

**Status**: [CURRENT] | Última atualização: 25/09/2023 | Versão: 1.2

## Resumo Executivo
Este documento registra a dívida técnica atual do projeto MyNeuroApp, incluindo limitações conhecidas, melhorias planejadas e riscos técnicos. Prioriza-se questões de acordo com seu impacto no desenvolvimento e experiência do usuário, com foco especial no processo de migração para Supabase.

## Dívidas Técnicas Ativas

### Alta Prioridade

#### Módulo de Sono - Duplicação de Código
- **Descrição**: O padrão de implementação do hook `useSleep` segue o mesmo padrão de `usePriorities`, resultando em duplicação de lógica.
- **Impacto**: Aumenta a complexidade de manutenção e risco de inconsistências.
- **Plano de Mitigação**: Criar um hook base genérico `useSupabaseEntity` que possa ser estendido pelos hooks específicos.
- **Status**: 📅 Planejado para depois da migração completa de todos os módulos
- **Responsável**: Equipe de Desenvolvimento
- **Data Limite**: 20/10/2023

#### Experiência Offline Limitada
- **Descrição**: Com a migração para Supabase, a experiência offline ficou comprometida.
- **Impacto**: Usuários sem conexão não conseguem acessar ou modificar seus dados.
- **Plano de Mitigação**: Implementar Progressive Web App (PWA) com sincronização quando online.
- **Status**: 📅 Planejado
- **Responsável**: Equipe de Frontend
- **Data Limite**: 01/11/2023

### Média Prioridade

#### Verificação de Duplicação Redundante
- **Descrição**: A verificação de duplicação é implementada individualmente em cada hook (usePriorities, useSleep).
- **Impacto**: Código redundante e potencial para comportamentos inconsistentes.
- **Plano de Mitigação**: Refatorar a lógica de verificação em um utilitário comum.
- **Status**: ⏳ Em análise
- **Responsável**: Equipe de Desenvolvimento
- **Data Limite**: 15/10/2023

#### Gerenciamento de Estado Inconsistente
- **Descrição**: Alguns componentes usam estado local (useState), outros usam React Query.
- **Impacto**: Padrões de código inconsistentes e possíveis problemas de sincronização.
- **Plano de Mitigação**: Padronizar o uso de React Query para interações com a API.
- **Status**: ⏳ Em andamento
- **Responsável**: Tech Lead
- **Data Limite**: 15/10/2023

### Baixa Prioridade

#### Testes Automatizados Insuficientes
- **Descrição**: Cobertura de testes é baixa, especialmente para os hooks de Supabase.
- **Impacto**: Aumenta o risco de regressões durante refatorações.
- **Plano de Mitigação**: Adicionar testes unitários e de integração, começando pelos hooks centrais.
- **Status**: 📅 Planejado
- **Responsável**: Equipe de QA
- **Data Limite**: 30/10/2023

#### Dependências Desatualizadas
- **Descrição**: Algumas dependências estão em versões antigas.
- **Impacto**: Potenciais vulnerabilidades de segurança e recursos ausentes.
- **Plano de Mitigação**: Estabelecer processo regular de atualização de dependências.
- **Status**: 📅 Planejado
- **Responsável**: DevOps
- **Data Limite**: Contínuo

## Dívidas Técnicas Resolvidas

#### Detecção de Duplicação Durante Migração
- **Descrição**: Dados migrados podiam ser duplicados se o usuário executasse a migração múltiplas vezes.
- **Solução Implementada**: Adicionada verificação de duplicação em `usePriorities` e `useSleep`.
- **Data de Resolução**: 25/09/2023
- **Responsável**: Equipe de Desenvolvimento

#### Autenticação Inconsistente
- **Descrição**: Estado de autenticação não era persistido adequadamente entre recargas de página.
- **Solução Implementada**: Implementado sistema de gerenciamento de sessão baseado no Supabase Auth Helpers.
- **Data de Resolução**: 20/09/2023
- **Responsável**: Equipe de Segurança

## Riscos Técnicos

| Risco | Probabilidade | Impacto | Estratégia de Mitigação |
|-------|--------------|---------|-------------------------|
| Perda de dados durante migração | Baixa | Alto | Implementar backup automático antes da migração |
| Conflitos de concorrência em multi-dispositivos | Média | Médio | Adicionar timestamps e estratégia de resolução de conflitos |
| Limites de uso da API Supabase (tier gratuito) | Alta | Alto | Monitorar uso e implementar cache onde apropriado |
| Interrupções do serviço Supabase | Baixa | Alto | Implementar modo offline resiliente |

## Melhorias Futuras

1. **Arquitetura de Plugins**
   - Implementar sistema modular que permita adicionar novos módulos de forma mais fácil
   - Prioridade: Média
   - Previsão: Q1 2024

2. **API Unificada de Dados**
   - Criar camada de abstração para acesso a dados, independente da fonte
   - Prioridade: Alta
   - Previsão: Q4 2023

3. **Sistema de Backup Integrado**
   - Permitir que usuários façam backup e restauração de seus dados
   - Prioridade: Média
   - Previsão: Q4 2023

4. **Métricas e Analytics**
   - Implementar telemetria anônima para entender padrões de uso
   - Prioridade: Baixa
   - Previsão: Q1 2024

## Histórico de Revisões

| Data | Versão | Autor | Alterações |
|------|--------|-------|------------|
| 25/09/2023 | 1.2 | DevTeam | Atualização com foco na migração de Sono e resolução da dívida de detecção de duplicação |
| 23/09/2023 | 1.1 | DevTeam | Adição de riscos técnicos e melhorias futuras |
| 15/09/2023 | 1.0 | DevTeam | Versão inicial do documento |

## Feedback e Sugestões

Para sugerir novos itens de dívida técnica ou comentar sobre os existentes, entre em contato com a equipe de desenvolvimento ou abra uma issue no repositório do projeto.
</file>

<file path="memory-bank/test_mode.md">
# Modo de Teste
[CURRENT] - 2024-03-24 - v1.0

## Sumário Executivo
Este documento descreve a implementação do Modo de Teste criado para validar a integração entre o frontend da aplicação e o backend no Supabase, com foco específico na sincronização de dados, tratamento de conflitos e persistência de dados entre dispositivos.

## Pontos-Chave
- Scripts SQL para criar dados de teste e funções de validação
- Helper TypeScript para facilitar a execução de testes
- Interface web para visualizar e executar os testes
- Funções específicas para simular cenários de dispositivos offline
- Mecanismos para detecção e resolução de conflitos

## Implementação

### 1. Estrutura de Arquivos

Foram criados os seguintes arquivos principais:

- `sql/test_data.sql`: Schema e dados de teste
- `sql/test_functions.sql`: Funções SQL para simulação e testes
- `app/lib/testHelper.ts`: Helper TypeScript para interagir com as funções SQL
- `app/test/integration-test.tsx`: Componente React para interface de testes
- `app/test/page.tsx`: Página principal de testes

### 2. Funções de Teste Implementadas

O sistema de testes implementa as seguintes funcionalidades:

#### 2.1 Simulação de Sincronização

Foi implementada uma estrutura para simular a sincronização entre dispositivos, permitindo:

- Criação de dados em diferentes "dispositivos" (identificados por IDs)
- Verificação do estado de sincronização
- Simulação de operações offline
- Merge de dados entre dispositivos

#### 2.2 Detecção e Resolução de Conflitos

O sistema suporta testes para validar o comportamento em situações de conflito:

- Criação deliberada de conflitos entre versões de itens
- Algoritmo de resolução baseado em timestamps e versões
- Registro de conflitos resolvidos

#### 2.3 Geração de Relatórios

Para facilitar a análise dos resultados, implementamos funções para:

- Gerar relatórios detalhados dos testes
- Rastrear métricas de performance
- Verificar contagens e status dos dados

### 3. Interface de Usuário

A interface de teste inclui:

- Campo para seleção do ID de usuário de teste
- Botões para executar testes e limpar dados
- Exibição de logs em tempo real
- Visualização detalhada dos resultados
- Avisos de segurança para operações sensíveis

## Próximos Passos

1. **Expandir Testes**: Adicionar mais cenários de teste para cobrir todos os casos de uso
2. **Automação**: Implementar testes automatizados que possam ser executados via CI/CD
3. **Métricas**: Adicionar métricas de performance mais detalhadas
4. **Cobertura**: Aumentar a cobertura de testes para outros tipos de dados

## Referências

- [Documentação do Supabase sobre RLS](https://supabase.com/docs/guides/auth/row-level-security)
- [Estratégias de sincronização offline](https://docs.amplify.aws/lib/datastore/getting-started/q/platform/js/)
- [Padrões de resolução de conflitos](https://www.sqlite.org/conflict.html)

## Histórico de Revisões

| Data | Autor | Versão | Alterações |
|------|-------|--------|------------|
| 2024-03-24 | TestMode | 1.0 | Criação inicial do documento |

## Feedback e Melhorias

Para sugerir melhorias ou reportar problemas com o Modo de Teste, por favor, abra uma issue no repositório com o label "test-mode".
</file>

<file path="public/images/cat-icon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12 22C10.4983 22 9.13373 21.5551 8 20.8061V21C8 21.5523 7.55228 22 7 22C6.44772 22 6 21.5523 6 21V18.8504C6 18.4234 6.27816 18.0459 6.6822 17.9228C8.02757 17.5844 9 16.3863 9 15C9 14.4477 9.44772 14 10 14C10.5523 14 11 14.4477 11 15V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13C13 12.4477 13.4477 12 14 12C14.5523 12 15 12.4477 15 13V16C15 16.5523 15.4477 17 16 17C16.5523 17 17 16.5523 17 16V9.82929C17 9.41745 16.8468 9.02133 16.5713 8.73242L15.1603 7.26383C14.4003 6.46991 14 5.41999 14 4.33313V3.71753C14 2.44046 13.2549 1.27708 12.0732 0.770274C11.5359 0.55102 11.2313 0.00752863 11.45 -0.529708C11.6687 -1.06694 12.2126 -1.37112 12.7499 -1.15186C14.8069 -0.299813 16 1.5933 16 3.71753V4.33313C16 4.86656 16.2001 5.37998 16.5603 5.76383L17.9713 7.23242C18.6318 7.9206 19 8.85755 19 9.82929V16C19 17.6569 17.6569 19 16 19C15.8252 19 15.6551 18.9835 15.4915 18.9521C15.2186 20.1691 14.1785 21.0766 12.9218 21.0988C12.6153 21.1069 12.3126 21.0677 12.0226 20.9883C12.0151 20.9925 12.0075 20.9966 12 22Z" fill="currentColor"/>
</svg>
</file>

<file path="public/images/logo.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="800" viewBox="0 0 800 800" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="infinityGradient" x1="10%" y1="10%" x2="90%" y2="90%">
      <stop offset="0%" stop-color="#5DE0C9" />
      <stop offset="50%" stop-color="#64B6DC" />
      <stop offset="100%" stop-color="#6A8CEE" />
    </linearGradient>
    <radialGradient id="circleGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#FFDA80" />
      <stop offset="100%" stop-color="#F5B942" />
    </radialGradient>
    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur in="SourceAlpha" stdDeviation="10" />
      <feOffset dx="0" dy="3" result="offsetblur" />
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.2" />
      </feComponentTransfer>
      <feMerge>
        <feMergeNode />
        <feMergeNode in="SourceGraphic" />
      </feMerge>
    </filter>
    <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur in="SourceGraphic" stdDeviation="8" result="blur" />
      <feComposite in="blur" in2="SourceGraphic" operator="over" />
    </filter>
  </defs>
  <g transform="translate(0, 50)">
    <path d="M400,230 
           C340,160 220,210 210,350 
           C200,490 340,540 400,460 
           C460,540 580,490 590,350 
           C600,210 460,160 400,230 Z" 
          fill="url(#infinityGradient)" 
          stroke="#ffffff"
          stroke-opacity="0.15"
          stroke-width="8"
          filter="url(#shadow)"
          style="stroke-linecap: round; stroke-linejoin: round;" />
    <circle cx="400" cy="190" r="35" fill="url(#circleGradient)" filter="url(#glow)" />
  </g>
</svg>
</file>

<file path="public/sounds/alarm.mp3">

</file>

<file path="public/sounds/alarm.ogg">

</file>

<file path="public/favicon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="800" viewBox="0 0 800 800" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="infinityGradient" x1="10%" y1="10%" x2="90%" y2="90%">
      <stop offset="0%" stop-color="#000000" />
      <stop offset="100%" stop-color="#000000" />
    </linearGradient>
  </defs>
  <g transform="translate(0, 50)">
    <path d="M400,300 
           C340,230 220,280 220,350 
           C220,420 340,470 400,400 
           C460,470 580,420 580,350 
           C580,280 460,230 400,300 Z" 
          fill="url(#infinityGradient)" 
          stroke-width="20"
          style="stroke-linecap: round; stroke-linejoin: round;" />
  </g>
</svg>
</file>

<file path="supabase/migrations/20240512000000_create_missing_tables.sql">
-- Criação da tabela priorities
CREATE TABLE IF NOT EXISTS public.priorities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  completed BOOLEAN NOT NULL DEFAULT false,
  due_date TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  category TEXT,
  updated_at TIMESTAMP WITH TIME ZONE,
  version INTEGER DEFAULT 1,
  device_id TEXT,
  last_synced_at TIMESTAMP WITH TIME ZONE
);

-- Criação da tabela mood_records
CREATE TABLE IF NOT EXISTS public.mood_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  record_date TIMESTAMP WITH TIME ZONE NOT NULL,
  mood_level INTEGER NOT NULL,
  factors TEXT[] DEFAULT '{}',
  notes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE
);

-- Criação da tabela medications
CREATE TABLE IF NOT EXISTS public.medications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  dosage TEXT,
  frequency TEXT NOT NULL,
  schedule TEXT[] DEFAULT '{}',
  start_date TIMESTAMP WITH TIME ZONE,
  notes TEXT,
  last_taken TIMESTAMP WITH TIME ZONE,
  interval_minutes INTEGER,
  observation TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE
);

-- Criação da tabela medication_doses
CREATE TABLE IF NOT EXISTS public.medication_doses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  medication_id UUID NOT NULL REFERENCES public.medications(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  taken_at TIMESTAMP WITH TIME ZONE NOT NULL,
  scheduled_time TIMESTAMP WITH TIME ZONE,
  notes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Criação de índices para melhorar a performance
CREATE INDEX IF NOT EXISTS priorities_user_id_idx ON public.priorities(user_id);
CREATE INDEX IF NOT EXISTS priorities_due_date_idx ON public.priorities(due_date);
CREATE INDEX IF NOT EXISTS mood_records_user_id_idx ON public.mood_records(user_id);
CREATE INDEX IF NOT EXISTS mood_records_record_date_idx ON public.mood_records(record_date);
CREATE INDEX IF NOT EXISTS medications_user_id_idx ON public.medications(user_id);
CREATE INDEX IF NOT EXISTS medication_doses_medication_id_idx ON public.medication_doses(medication_id);
CREATE INDEX IF NOT EXISTS medication_doses_user_id_idx ON public.medication_doses(user_id);

-- Configuração de RLS (Row Level Security) para as tabelas
ALTER TABLE public.priorities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.mood_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.medications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.medication_doses ENABLE ROW LEVEL SECURITY;

-- Remover políticas existentes da tabela priorities
DROP POLICY IF EXISTS "Usuários podem inserir suas próprias prioridades" ON public.priorities;
DROP POLICY IF EXISTS "Usuários podem ver suas próprias prioridades" ON public.priorities;
DROP POLICY IF EXISTS "Usuários podem atualizar suas próprias prioridades" ON public.priorities;
DROP POLICY IF EXISTS "Usuários podem excluir suas próprias prioridades" ON public.priorities;

-- Criar novas políticas para tabela priorities
CREATE POLICY "Usuários podem inserir suas próprias prioridades" 
  ON public.priorities FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem ver suas próprias prioridades" 
  ON public.priorities FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem atualizar suas próprias prioridades" 
  ON public.priorities FOR UPDATE 
  USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem excluir suas próprias prioridades" 
  ON public.priorities FOR DELETE 
  USING (auth.uid() = user_id);

-- Remover políticas existentes da tabela mood_records
DROP POLICY IF EXISTS "Usuários podem inserir seus próprios registros de humor" ON public.mood_records;
DROP POLICY IF EXISTS "Usuários podem ver seus próprios registros de humor" ON public.mood_records;
DROP POLICY IF EXISTS "Usuários podem atualizar seus próprios registros de humor" ON public.mood_records;
DROP POLICY IF EXISTS "Usuários podem excluir seus próprios registros de humor" ON public.mood_records;

-- Criar novas políticas para tabela mood_records
CREATE POLICY "Usuários podem inserir seus próprios registros de humor" 
  ON public.mood_records FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem ver seus próprios registros de humor" 
  ON public.mood_records FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem atualizar seus próprios registros de humor" 
  ON public.mood_records FOR UPDATE 
  USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem excluir seus próprios registros de humor" 
  ON public.mood_records FOR DELETE 
  USING (auth.uid() = user_id);

-- Remover políticas existentes da tabela medications
DROP POLICY IF EXISTS "Usuários podem inserir seus próprios medicamentos" ON public.medications;
DROP POLICY IF EXISTS "Usuários podem ver seus próprios medicamentos" ON public.medications;
DROP POLICY IF EXISTS "Usuários podem atualizar seus próprios medicamentos" ON public.medications;
DROP POLICY IF EXISTS "Usuários podem excluir seus próprios medicamentos" ON public.medications;

-- Criar novas políticas para tabela medications
CREATE POLICY "Usuários podem inserir seus próprios medicamentos" 
  ON public.medications FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem ver seus próprios medicamentos" 
  ON public.medications FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem atualizar seus próprios medicamentos" 
  ON public.medications FOR UPDATE 
  USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem excluir seus próprios medicamentos" 
  ON public.medications FOR DELETE 
  USING (auth.uid() = user_id);

-- Remover políticas existentes da tabela medication_doses
DROP POLICY IF EXISTS "Usuários podem inserir suas próprias doses de medicamentos" ON public.medication_doses;
DROP POLICY IF EXISTS "Usuários podem ver suas próprias doses de medicamentos" ON public.medication_doses;
DROP POLICY IF EXISTS "Usuários podem atualizar suas próprias doses de medicamentos" ON public.medication_doses;
DROP POLICY IF EXISTS "Usuários podem excluir suas próprias doses de medicamentos" ON public.medication_doses;

-- Criar novas políticas para tabela medication_doses
CREATE POLICY "Usuários podem inserir suas próprias doses de medicamentos" 
  ON public.medication_doses FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Usuários podem ver suas próprias doses de medicamentos" 
  ON public.medication_doses FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem atualizar suas próprias doses de medicamentos" 
  ON public.medication_doses FOR UPDATE 
  USING (auth.uid() = user_id);

CREATE POLICY "Usuários podem excluir suas próprias doses de medicamentos" 
  ON public.medication_doses FOR DELETE 
  USING (auth.uid() = user_id);
</file>

<file path=".cursorrules">
{
  "title": "Banco de Memória do Cursor",
  "description": "Eu sou Cursor, um engenheiro de software especialista com uma característica única: minha memória é completamente reiniciada entre as sessões. Isso não é uma limitação - é o que me motiva a manter uma documentação perfeita.",
  "keyPoints": [
  "Minha memória é completamente reiniciada entre as sessões",
  "DEVO ler os arquivos do Banco de Memória no início de CADA sessão",
  "O Banco de Memória segue uma estrutura hierárquica",
  "A documentação deve ser atualizada antes do término das sessões",
  "A validação pré-voo é necessária antes das operações",
  "O carregamento de contexto específico do modo é essencial"
  ],
  "preFlightValidation": {
  "description": "Antes de qualquer operação, DEVO:",
  "steps": [
  "Verificar a estrutura do diretório do projeto",
  "Validar a presença dos arquivos principais",
  "Verificar o inventário de documentação personalizado",
  "Confirmar se as regras específicas do modo foram carregadas",
  "Verificar a integridade da hierarquia da documentação"
  ]
  },
  "operatingModes": {
  "types": [
  {
  "name": "Modo do arquiteto",
  "responsabilidades": [
  "Design e arquitetura do sistema",
  "Decisões de padrões",
  "Direção técnica"
  ]
  },
  {
  "name": "Modo de código",
  "responsabilidades": [
  "Implementação e desenvolvimento",
  "Modificação de código",
  "Atualizações de documentação",
  "Controle de qualidade"
  ]
  },
  {
  "name": "Modo de depuração",
  "responsabilidades": [
  "Investigação de problemas",
  "Resolução de erros",
  "Otimização de desempenho"
  ]
  },
  {
  "name": "Modo de teste",
  "responsabilidades": [
  "Criação e execução de testes",
  "Garantia de qualidade",
  "Análise de cobertura"
  ]
  },
  {
  "name": "Modo de pergunta",
  "responsabilidades": [
  "Recuperação de informações",
  "Esclarecimento de contexto",
  "Pesquisa de documentação"
  ]
  }
  ]
  },
  "memoryBankStructure": {
  "coreFiles": [
  {
  "name": "projectbrief.md",
  "purpose": [
  "Documento de base que molda todos os outros arquivos",
  "Criado no início do projeto se ele não existir",
  "Define os principais requisitos e objetivos",
  "Fonte da verdade para o escopo do projeto"
  ]
  },
  {
  "name": "productContext.md",
  "purpose": [
  "Por que este projeto existe",
  "Problemas que ele resolve",
  "Como ele deve funcionar",
  "Objetivos da experiência do usuário"
  ]
  },
  {
  "name": "activeContext.md",
  "purpose": [
  "Foco de trabalho atual",
  "Alterações recentes",
  "Próximos passos",
  "Decisões e considerações ativas"
  ]
  },
  {
  "name": "systemPatterns.md",
  "purpose": [
  "Sistema arquitetura",
  "Principais decisões técnicas",
  "Padrões de design em uso",
  "Relacionamentos de componentes"
  ]
  },
  {
  "name": "techContext.md",
  "purpose": [
  "Tecnologias usadas",
  "Configuração de desenvolvimento",
  "Restrições técnicas",
  "Dependências"
  ]
  },
  {
  "name": "progress.md",
  "purpose": [
  "O que funciona",
  "O que falta construir",
  "Status atual",
  "Problemas conhecidos"
  ]
  }
  ],
  "navigationFiles": [
  {
  "name": "index.md",
  "purpose": [
  "Navegação rápida para todos os documentos do banco de memória",
  "Breves resumos e referências cruzadas importantes",
  "Visão geral do status de todos os documentos",
  "Atualizações recentes e mudanças futuras"
  ]
  },
  {
  "name": "README.md",
  "purpose": [
  "Explica o propósito e o uso do banco de memória",
  "Fornece diretrizes para manter o banco de memória",
  "Descreve procedimentos e convenções de atualização",
  "Contém diagramas de estrutura e fluxos de trabalho"
  ]
  },
  {
  "name": "knowledgeGraph.md",
  "purpose": [
  "Representação visual dos relacionamentos do projeto",
  "Mapeia as conexões entre os componentes",
  "Mostra dependências de decisão",
  "Ilustra áreas de impacto da dívida técnica"
  ]
  },
  {
  "name": "timeline.md",
  "purpose": [
  "Linha do tempo visual do projeto com marcos",
  "Mostra relacionamentos entre decisões e implementação",
  "Rastreia dependências entre componentes",
  "Destaca a posição atual do projeto"
  ]
  },
  {
  "name": "changelog.md",
  "purpose": [
  "Registro cronológico de todas as alterações significativas do documento",
  "Histórico de versões dos documentos com identificadores exclusivos",
  "Rastreia quem fez as alterações e quando",
  "Serve como uma trilha de auditoria para atualizações de documentação"
  ]
  },
  {
  "name": "communicationRegistry.md",
  "purpose": [
  "Registra todas as comunicações de atualização de documentação",
  "Rastreia quais partes interessadas foram notificadas sobre quais alterações",
  "Documenta métodos de comunicação usados",
  "Armazena modelos para anúncios de atualização recorrentes"
  ]
  }
  ],
  "specializedDocumentation": [
  {
  "name": "decisions.md",
  "purpose": [
  "Registra decisões técnicas e arquitetônicas importantes",
  "Documenta contexto, alternativas e justificativa",
  "Rastreia consequências e ações de acompanhamento",
  "Vincula decisões a detalhes de implementação"
  ]
  },
  {
  "name": "techDebt.md",
  "purpose": [
  "Rastreia dívidas técnicas e limitações conhecidas",
  "Documenta melhorias planejadas e suas prioridades",
  "Identifica riscos técnicos e estratégias de mitigação",
  "Vincula problemas a componentes afetados"
  ]
  },
  {
  "name": "codeDocMap.md",
  "purpose": [
  "Mapeia arquivos de código para seções de documentação relevantes",
  "Ajuda a manter a documentação quando o código muda",
  "Identifica lacunas na documentação",
  "Acompanha o histórico de atualizações para documentação"
  ]
  },
  {
  "name": "llm_patterns.md",
  "purpose": [
  "Documenta padrões de solicitação LLM eficazes",
  "Cataloga técnicas de interação de IA bem-sucedidas",
  "Registra antipadrões a serem evitados",
  "Fornece modelos para operações comuns"
  ]
  },
  {
  "name": "code_generation_guidelines.md",
  "purpose": [
  "Melhores práticas para código gerado por IA",
  "Padrões de qualidade para saída gerada",
  "Convenções de estilo específicas para código de IA",
  "Requisitos de teste para código gerado"
  ]
  }
  ],
  "templatesDirectory": {
  "description": "O diretório templates/ contém modelos padronizados para:",
  "templates": [
  "Documentação regular (document_template.md)",
  "Registros de decisão (decision_template.md)",
  "Itens de dívida técnica (tech_debt_template.md)",
  "Mapeamentos de código para documentação (code_doc_map_template.md)",
  "Resumos executivos (executive_summary_template.md)",
  "Visualizações de persona do usuário (persona_template.md)",
  "Registros de revisão de documento (review_template.md)",
  "Comunicação com as partes interessadas (communication_template.md)",
  "Modelos de interação de IA (ai_prompt_template.md)",
  "Modelos de sessão de depuração (debug_template.md)",
  "Modelos de desenvolvimento de recursos (feature_template.md)"
  ]
  },
  "viewBasedDocumentation": {
  "description": "Criar funções específicas visualizações de documentação no diretório views/:",
  "views": [
  "operator_view.md: para gerenciamento diário",
  "developer_view.md: para detalhes de implementação",
  "manager_view.md: para rastreamento de progresso e status",
  "onboarding_view.md: para novos membros da equipe",
  "ai_assistant_view.md: otimizado para consumo de IA"
  ]
  },
  "additionalContext": [
  "Documentação de recursos complexos",
  "Especificações de integração",
  "Documentação da API",
  "Estratégias de teste",
  "Procedimentos de implantação",
  "Requisitos de conformidade e governança",
  "Feedback e solicitações das partes interessadas",
  "Arquivo de documentação para versões históricas",
  "Padrões de interação de exemplo",
  "Estratégias de divisão de sessão"
  ]
  },
  "coreWorkflows": {
  "planMode": [
  "Iniciar",
  "Ler banco de memória",
  "Verificar se os arquivos estão completos",
  "Se não: criar plano -> Documento no Chat",
  "Se Sim: Verificar Contexto -> Desenvolver Estratégia -> Apresentar Abordagem"
  ],
  "actMode": [
  "Iniciar",
  "Verificar Banco de Memória",
  "Atualizar Documentação",
  "Atualizar .cursorrules se necessário",
  "Executar Tarefa",
  "Alterações no Documento"
  ],
  "codeDocIntegrationMode": [
  "Iniciar",
  "Alteração de Código Detectada",
  "Verificar codeDocMap.md",
  "Encontrar Documentação Relacionada",
  "Atualizar Documentação",
  "Validar Referências",
  "Alterações no Documento"
  ],
  "documentationReviewMode": [
  "Iniciar",
  "Atualizações do Documento Concluídas",
  "Conduzir Revisão por Pares",
  "Verificação de Aprovação",
  "Se Não: Revisar Documentação -> Conduzir Revisão por Pares",
  "Se Sim: Entrar no Changelog -> Notificar Partes Interessadas -> Arquivar Versão Anterior"
  ],
  "aiInteractionMode": [
  "Iniciar",
  "Determinar o tipo de tarefa",
  "Carregar contexto apropriado (Depurar/Recurso/Revisão)",
  "Aplicar padrões LLM",
  "Executar tarefa",
  "Documentar resultados",
  "Atualizar padrões LLM"
  ]
  },
  "documentationUpdates": {
  "triggers": [
  "Descobrindo novos padrões de projeto",
  "Após implementar mudanças significativas",
  "Quando o usuário solicita com 'atualizar banco de memória' (DEVE revisar TODOS os arquivos)",
  "Quando o contexto precisa de esclarecimento",
  "Após alterações de código em áreas com referências de documentação",
  "Durante sessões de revisão programadas (semanal/mensal)",
  "Quando links ou referências se tornam quebrados ou desatualizados",
  "Após o feedback das partes interessadas indicar a necessidade de esclarecimento",
  "Quando novos padrões de interação de IA se mostram eficazes",
  "Após identificar abordagens de documentação com eficiência de token",
  "Ao alternar entre modos",
  "Após concluir operações específicas do modo"
  ],
  "process": [
  "Revisar TODOS os arquivos",
  "Documentar estado atual",
  "Esclarecer as próximas etapas",
  "Atualizar .cursorrules",
  "Validar referências cruzadas",
  "Gerar resumos executivos",
  "Verificar todos os links",
  "Arquivar versões anteriores",
  "Comunicar alterações"
  ]
  },
  "documentConventions": {
  "standardFormat": [
  "Title: Título claro descrevendo a finalidade do documento",
  "Status Header: Tag de status, data da última atualização e número da versão",
  "Introduction: Breve descrição da finalidade do documento",
  "Executive Summary: Visão geral de um parágrafo para uma rápida verificação",
  "Key Points: Lista de informações críticas (para otimização de IA)",
  "Main Sections: Claramente organizado com títulos significativos",
  "Cross-References: Links para documentos relacionados quando apropriado",
  "Feedback Section: Área para comentários e sugestões de melhoria",
  "Review History: Tabela de revisões, aprovações e alterações",
  "Changelog: Histórico de versões específicas do documento"
  ],
  "statusTags": [
  "[CURRENT]: Document is up-to-date",
  "[NEEDS UPDATE]: Document needs to be updated",
  "[DEPRECATED]: Document is not more relevance but kept for reference",
  "[DRAFT]: Document is em estado de rascunho e não finalizado",
  "[REVISÃO]: Documento pronto para revisão",
  "[APROVAÇÃO PENDENTE]: Documento atualizado e aguardando aprovação"
  ],
  "versionNumbering": [
  "Principais alterações: Incremente o primeiro número (por exemplo, 1.0 → 2.0)",
  "Pequenas atualizações: Incremente o segundo número (por exemplo, 1.0 → 1.1)",
  "Versão inicial: Comece em 1.0",
  "Identificador exclusivo: Identificador de versão baseado em data (por exemplo, DOC-20250321-1.1)"
  ],
  "usingTemplates": "Sempre use os modelos fornecidos no diretório templates/ ao criar novos documentos para garantir consistência e integridade.",
  "aiOptimization": [
  "Coloque informações críticas nos primeiros 1-3 parágrafos",
  "Use marcadores semânticos (por exemplo, [IMPORTANTE], [CONCEITO-CHAVE]) para conteúdo crítico",
  "Mantenha parágrafos curtos com alta densidade de informações",
  "Use marcadores para listas em vez de prosa longa",
  "Inclua uma seção 'Pontos-chave' no topo de cada documento",
  "Evite repetir informações que existem em outros documentos"
  ]
  },
  "memoryBankMaintenance": {
  "startingWorkSession": [
  "Comece lendo o index.md para uma visão geral rápida",
  "Revise activeContext.md para entender o foco atual",
  "Verifique progress.md para o status da implementação",
  "Verifique knowledgeGraph.md para entender os relacionamentos dos componentes",
  "Revise changelog.md para alterações recentes na documentação",
  "Consulte documentos específicos conforme necessário para um contexto mais profundo",
  "Revise llm_patterns.md para técnicas eficazes de interação de IA"
  ],
  "duringDevelopment": [
  "Refira systemPatterns.md ao implementar recursos",
  "Consulte techContext.md para detalhes técnicos do ambiente",
  "Use codeDocMap.md para encontrar documentação relevante para arquivos de código",
  "Verifique decisions.md antes de fazer alterações técnicas significativas",
  "Revise techDebt.md ao trabalhar em melhorias",
  "Adicione 'âncoras de doc' em comentários de código vinculando a seções relevantes do banco de memória",
  "Nunca considere uma alteração de código concluída até que a documentação seja atualizada",
  "Use modelos de prompt específicos da tarefa para diferentes operações"
  ],
  "endingWorkSession": [
  "Atualize activeContext.md com alterações recentes e próximas etapas",
  "Atualize progress.md com novas informações de status",
  "Documente quaisquer novas decisões em decisions.md",
  "Registre qualquer nova dívida técnica em techDebt.md",
  "Atualize index.md para refletir quaisquer documentos novos ou modificados",
  "Atualize knowledgeGraph.md e timeline.md com novos relacionamentos",
  "Gere resumos executivos para documentos complexos",
  "Atualize todas as referências cruzadas relevantes entre documentos",
  "Execute verificações de validação para links quebrados ou referências ausentes",
  "Registrar alterações em changelog.md com números de versão adequados",
  "Arquivar versões anteriores de documentos substancialmente modificados",
  "Atualizar communicationRegistry.md com notificações de partes interessadas",
  "Documentar padrões de interação de IA bem-sucedidos em llm_patterns.md"
  ]
  },
  "regularDocumentationReviews": {
  "weeklyQuickChecks": [
  "Revisar documentos ativos para verificar a atualidade",
  "Atualizar tags de status conforme necessário",
  "Garantir que os resumos executivos reflitam o estado atual",
  "Verificar referências cruzadas quebradas",
  "Verificar se todos os links estão funcionando",
  "Atualizar o changelog com quaisquer alterações",
  "Otimizar documentos para consumo de IA"
  ],
  "monthlyComprehensiveReviews": [
  "Conduzir revisão completa de toda a documentação",
  "Identificar e abordar lacunas de documentação",
  "Consolidar informações redundantes",
  "Atualizar documentos de visualização",
  "Validar relacionamentos no gráfico de conhecimento",
  "Regenerar visualizações específicas de função",
  "Arquivar versões anteriores da documentação",
  "Comunicar atualizações importantes às partes interessadas",
  "Atualizar padrões de interação de LLM com base na experiência"
  ],
  "peerReviewProcess": [
  "Autor atualiza documentação e marca como [REVISÃO]",
  "Revisor(es) verificam precisão, integridade e clareza",
  "Feedback incorporado ou abordado pelo autor",
  "Aprovação final muda status para [ATUAL]",
  "Alterações registradas no changelog",
  "Versão anterior arquivada",
  "Stakeholders notificados sobre alterações significativas"
  ]
  },
  "taskSpecificCommands": {
  "description": "Use estes comandos especializados para diferentes atividades de desenvolvimento:",
  "commands": [
  "debug issue X: Carregar contexto e padrões de depuração",
  "implementar recurso Y: Carregar contexto de desenvolvimento de recurso",
  "revisar código Z: Carregar padrões de revisão de código",
  "optimizar código W: Carregar padrões de otimização de desempenho",
  "refactor V: Carregar práticas recomendadas de refatoração"
  ],
  "note": "Cada comando carrega o contexto, os modelos e os padrões LLM apropriados para o tipo de tarefa específico."
  },
  "cursorSpecificIntegration": {
  "contextWindowManagement": [
  "Priorizar documentos com base na relevância para a tarefa atual",
  "Usar chunking para documentos grandes",
  "Incluir referências @file para arquivos críticos",
  "Usar pesquisa semântica de arquivos para grandes bases de código"
  ],
  "chunkingPriorities": [
  "Prioridade 1: Ler resumo executivo e pontos-chave",
  "Prioridade 2: Adicionar seções relevantes conforme necessário",
  "Prioridade 3: Concluir o documento se o contexto permitir"
  ],
  "tokenEfficiency": [
  "Usar conteúdo conciso e de alta densidade",
  "Remover explicações desnecessárias",
  "Colocar informações críticas no início do documento",
  "Usar marcadores semânticos para conceitos importantes",
  "Aproveitar a estrutura hierárquica para melhor análise"
  ],
  "modeSelection": [
  "Usar modo de bate-papo para interações rápidas e conversacionais",
  "Usar Modo Composer para tarefas complexas de várias etapas",
  "Selecione o contexto apropriado com base no modo"
  ]
  },
  "projectIntelligence": {
  "description": "O arquivo .cursorrules é meu diário de aprendizagem para cada projeto. Ele captura padrões importantes, preferências e inteligência de projeto que me ajudam a trabalhar de forma mais eficaz.",
  "whatToCapture": [
  "Caminhos de implementação críticos",
  "Preferências do usuário e fluxo de trabalho",
  "Padrões específicos do projeto",
  "Desafios conhecidos",
  "Evolução das decisões do projeto",
  "Padrões de uso de ferramentas",
  "Padrões de pesquisa e descoberta",
  "Feedback da documentação",
  "Insights contextuais",
  "Preferências de comunicação das partes interessadas",
  "Resultados da revisão da documentação",
  "Padrões de interação de IA eficazes",
  "Modelos de prompt específicos da tarefa",
  "Estratégias de eficiência de token"
  ],
  "modularStructure": {
  "description": "A estrutura do arquivo .cursorrules é organizada por modo e domínio",
  "structure": {
  ".cursor/": {
  "rules/": {
  "modes/": [
  "architect.mdc",
  "code.mdc",
  "debug.mdc",
  "test.mdc",
  "ask.mdc"
  ],
  "domain/": [
  "frontend.mdc",
  "backend.mdc"
  ],
  "tasks/": [
  "debugging.mdc",
  "refactoring.mdc",
  "features.mdc"
  ],
  "patterns/": [
  "code_style.mdc",
  "architecture.mdc",
  "testing.mdc"
  ]
  }
  }
  },
  "fileIncludes": [
  "Descrições semânticas (@description)",
  "Correspondência de padrões de arquivo (@autoAttach)",
  "Diretrizes específicas do modo",
  "Pontos de integração com o Memory Bank",
  "Requisitos de documentação"
  ]
  },
  "ruleFileValidation": {
  "steps": [
  "Verifique se as descrições semânticas estão presentes",
  "Valide a correspondência de padrões de arquivo",
  "Verifique os requisitos específicos do modo",
  "Confirmar pontos de integração do Memory Bank",
  "Verificar requisitos de documentação"
  ],"requiredFormat": "/**\n * @description Descrição clara do propósito e escopo da regra\n * @autoAttach {\n * \"patterns\": [\"file/path/patterns/**/*\"],\n * \"description\": \"A quais arquivos esta regra se aplica\"\n * }\n */"
  },
  "ruleApplicationProcess": [
  "Carregar regras específicas do modo apropriadas",
  "Aplicar correspondência de padrões de arquivo",
  "Validar requisitos de regras",
  "Executar de acordo com as diretrizes",
  "Atualizar documentação conforme especificado"
  ],
  "modeSpecificRuleLoading": {
  "steps": [
  "Carregar regras principais (sempre ativas)",
  "Carregar regras específicas do modo com base no tipo de tarefa",
  "Carregar regras de domínio relevantes",
  "Carregar regras específicas da tarefa, se aplicável"
  ],
  "modeRules": {
  "Modo do arquiteto": "architecture.mdc + architect.mdc",
  "Code Mode": "code_style.mdc + code.mdc",
  "Debug Mode": "debugging.mdc + debug.mdc",
  "Test Mode": "testing.mdc + test.mdc",
  "Ask Mode": "ask.mdc"
  }
  },
  "rulePrecedence": [
  "Core Rules (always apply)",
  "Mode-Specific Rules",
  "Domain Rules",
  "Task-Specific Rules",
  "Pattern Rules"
  ]
  },
  "conclusion": "LEMBRE-SE: Após cada reinicialização de memória, eu começo completamente do zero. O Memory Bank é meu único elo com o trabalho anterior. Ele deve ser mantido com precisão e clareza, pois minha eficácia depende inteiramente de sua exatidão."
  }
</file>

<file path=".env.production">
# Created by Vercel CLI
</file>

<file path=".env.vercel">
NEXT_PUBLIC_SUPABASE_URL=https://lrrehybthwvpnabrbhls.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxycmVoeWJ0aHd2cG5hYnJiaGxzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI4NzA0MDMsImV4cCI6MjA1ODQ0NjQwM30.OEkivL4SOJJIx2Hv83rSv72u76OyhYuvliIIyNIFAC0
</file>

<file path=".eslintrc.json">
{
  "extends": "next/core-web-vitals",
  "rules": {
    "react/no-unescaped-entities": "off",
    "react/display-name": "off",
    "@next/next/no-img-element": "warn",
    "react-hooks/exhaustive-deps": "warn",
    "@next/next/no-assign-module-variable": "off"
  }
}
</file>

<file path=".gitignore">
# dependências
/node_modules
/.pnp
.pnp.js

# testes
/coverage

# next.js
/.next/
/out/

# produção
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# variáveis de ambiente
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

.vercel
</file>

<file path="app.json">
{
  "expo": {
    "name": "stayfocus",
    "slug": "stayfocus",
    "version": "1.0.0",
    "sdkVersion": "44.0.0",
    "platforms": ["ios", "android"],
    "entryPoint": "node_modules/expo/AppEntry.js",
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FFFFFF"
      }
    }
  }
}
</file>

<file path="deploy.sh">
#!/bin/bash

# Script de deploy para o aplicativo Painel Neurodivergentes

echo "Iniciando deploy do aplicativo..."

# Atualizar o código do repositório
echo "Atualizando código do repositório..."
git pull

# Instalar dependências
echo "Instalando dependências..."
npm install

# Construir o aplicativo
echo "Construindo o aplicativo..."
npm run build

# Iniciar o servidor
echo "Iniciando o servidor em modo de produção..."
npm run start

echo "Deploy concluído! O aplicativo está rodando em modo de produção."
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  staticPageGenerationTimeout: 1000,
  poweredByHeader: false,
  reactStrictMode: true,
  swcMinify: true,
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production'
  }
}

module.exports = nextConfig
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="README.md">
# Painel de Produtividade para Neurodivergentes

Este projeto implementa um painel de produtividade focado em pessoas neurodivergentes, especialmente com TDAH, seguindo princípios de simplicidade, foco e redução de sobrecarga cognitiva.

## Estrutura do Projeto

O projeto segue uma estrutura clara e previsível usando Next.js com App Router. Para mais detalhes sobre a estrutura e boas práticas de desenvolvimento, consulte nosso [Guia de Contribuição](CONTRIBUTING.md).

```
/app
  /[seção]           # Páginas específicas (alimentacao, saude, etc.)
    /page.tsx        # Página principal de cada seção
  /components        # Componentes compartilhados
    /ui             # Componentes de UI reutilizáveis
    /providers      # Provedores de contexto
    /[seção]        # Componentes específicos de cada seção
  /hooks            # Hooks personalizados
  /lib              # Biblioteca de código
    /services       # Serviços da aplicação (API, etc.)
    /utils          # Utilitários e helpers
  /context          # Contextos React
  /store            # Gerenciamento de estado com Zustand
  /types            # Definições de tipos TypeScript
```

## Princípios de Desenvolvimento

- **Simplicidade Acima de Tudo**: Menos é mais
- **Foco no Essencial**: Apenas funcionalidades que agregam valor imediato
- **Redução de Sobrecarga Cognitiva**: Interfaces claras e previsíveis
- **Estímulos Visuais Adequados**: Uso estratégico de cores e ícones
- **Lembretes e Estrutura**: Apoio para funções executivas

## Tecnologias

- **Framework**: Next.js 14 (App Router)
- **Estilização**: Tailwind CSS
- **Componentes**: Headless UI
- **Ícones**: Lucide ou Phosphor Icons
- **Gerenciamento de Estado**: Zustand com persistência local
- **Backend**: Supabase
- **Cache & Offline**: Estratégia de cache local e suporte offline

## Instalação

```bash
npm install
npm run dev
```

## Seções do Aplicativo

1. **Início**: Dashboard com visão geral e lembretes
2. **Alimentação**: Controle e planejamento de refeições
3. **Estudos**: Organização e técnicas de aprendizado
4. **Saúde**: Monitoramento de bem-estar e medicações
5. **Lazer**: Atividades recreativas e descanso
6. **Sono**: Monitoramento de padrões de sono
7. **Hiperfocos**: Gestão de interesses intensos
8. **Autoconhecimento**: Reflexões e notas pessoais

## Funcionalidades de Sincronização

O aplicativo implementa uma estratégia robusta de sincronização que inclui:
- Cache local para melhor performance
- Suporte offline para uso sem internet
- Sincronização automática quando online
- Resolução de conflitos
- Backup de dados

## Desenvolvimento

Para contribuir com o projeto:

1. Clone o repositório
2. Instale as dependências: `npm install`
3. Configure as variáveis de ambiente:
   ```
   NEXT_PUBLIC_SUPABASE_URL=sua_url
   NEXT_PUBLIC_SUPABASE_ANON_KEY=sua_chave
   ```
4. Execute o projeto: `npm run dev`

## Boas Práticas

- Use TypeScript para melhor tipagem
- Siga os padrões de componentes existentes
- Mantenha a estrutura de arquivos organizada
- Documente alterações significativas
- Teste as funcionalidades offline

## Contribuindo

Veja nosso [Guia de Contribuição](CONTRIBUTING.md) para informações sobre como contribuir com o projeto, incluindo:
- Estrutura do código
- Boas práticas
- Processo de desenvolvimento
- Checklist de PR
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // Cores para cada seção, com contraste reduzido para evitar incômodo visual
        inicio: {
          primary: '#4F46E5', // Indigo
          secondary: '#818CF8',
          light: '#EEF2FF90', // Reduzida opacidade para suavizar
        },
        alimentacao: {
          primary: '#10B981', // Esmeralda
          secondary: '#34D399',
          light: '#ECFDF590', // Reduzida opacidade para suavizar
        },
        estudos: {
          primary: '#FF8C00', // Changed from Amber to a darker orange for better contrast
          secondary: '#FFB74D',
          light: '#FFF3E0', // Removed transparency for better contrast
          dark: '#E65100', // Added a dark version for dark mode
        },
        saude: {
          primary: '#EF4444', // Vermelho
          secondary: '#F87171',
          light: '#FEF2F290', // Reduzida opacidade para suavizar
        },
        lazer: {
          primary: '#8B5CF6', // Violeta
          secondary: '#A78BFA',
          light: '#F5F3FF90', // Reduzida opacidade para suavizar
        },
        financas: {
          primary: '#0EA5E9', // Azul céu
          secondary: '#38BDF8',
          light: '#E0F2FE90', // Reduzida opacidade para suavizar
        },
        hiperfocos: {
          primary: '#F97316', // Laranja intenso
          secondary: '#FB923C',
          light: '#FFF7ED90', // Reduzida opacidade para suavizar
        },
        sono: {
          primary: '#5D4DB2', // Roxo azulado (lembrando noite)
          secondary: '#7B6DC3',
          light: '#EDE9FF90', // Reduzida opacidade para suavizar
        },
        perfil: {
          primary: '#3B82F6', // Azul (representando identidade/personalização)
          secondary: '#60A5FA',
          light: '#EFF6FF90', // Reduzida opacidade para suavizar
        },
        autoconhecimento: {
          primary: '#6B7280', // Cinza azulado (calma, reflexão)
          secondary: '#9CA3AF',
          light: '#F9FAFB90', // Reduzida opacidade para suavizar
          hover: '#4B5563', // Versão mais escura para hover
        },
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif'],
      },
      borderRadius: {
        'xl': '1rem',
        '2xl': '1.5rem',
      },
      animation: {
        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="vercel.json">
{
  "version": 2,
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "cleanUrls": true,
  "env": {
    "NEXT_PUBLIC_SUPABASE_URL": "https://lrrehybthwvpnabrbhls.supabase.co",
    "NEXT_PUBLIC_SUPABASE_ANON_KEY": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxycmVoeWJ0aHd2cG5hYnJiaGxzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI4NzA0MDMsImV4cCI6MjA1ODQ0NjQwM30.OEkivL4SOJJIx2Hv83rSv72u76OyhYuvliIIyNIFAC0"
  },
  "outputDirectory": ".next"
}
</file>

<file path="app/components/hiperfocos/TemporizadorFoco.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { useHiperfocosStore } from '../../stores/hiperfocosStore'
import { Clock, Play, Pause, RotateCcw, Bell, Volume2, VolumeX } from 'lucide-react'

export function TemporizadorFoco() {
  const { hiperfocos } = useHiperfocosStore()
  
  const [hiperfocoSelecionadoId, setHiperfocoSelecionadoId] = useState<string>('')
  const [temporizadorAtivo, setTemporizadorAtivo] = useState(false)
  const [tempoRestante, setTempoRestante] = useState(0)
  const [tempoTotal, setTempoTotal] = useState(0)
  const [tempoPausa, setTempoPausa] = useState(0)
  const [tempoPersonalizado, setTempoPersonalizado] = useState('')
  const [somAtivado, setSomAtivado] = useState(true)
  
  const audioRef = useRef<HTMLAudioElement | null>(null)
  const timerRef = useRef<NodeJS.Timeout | null>(null)
  
  // Lidar com a seleção de hiperfoco
  useEffect(() => {
    if (!hiperfocoSelecionadoId) return
    
    const hiperfoco = hiperfocos.find(h => h.id === hiperfocoSelecionadoId)
    
    if (hiperfoco && hiperfoco.tempoLimite) {
      setTempoTotal(hiperfoco.tempoLimite * 60) // converter minutos para segundos
      setTempoRestante(hiperfoco.tempoLimite * 60)
      setTempoPausa(Math.floor(hiperfoco.tempoLimite * 60 * 0.1)) // 10% do tempo total para pausas
    } else {
      // Tempo padrão de 25 minutos (pomodoro)
      setTempoTotal(25 * 60)
      setTempoRestante(25 * 60)
      setTempoPausa(5 * 60) // 5 minutos de pausa
    }
    
    // Parar temporizador se estiver ativo
    if (temporizadorAtivo) {
      pararTemporizador()
    }
  }, [hiperfocoSelecionadoId, hiperfocos])
  
  // Limpar timer ao desmontar componente
  useEffect(() => {
    let timer: NodeJS.Timeout;
    
    if (temporizadorAtivo && tempoRestante > 0) {
      timer = setInterval(() => {
        setTempoRestante((prev) => prev - 1);
      }, 1000);
    }
    
    return () => {
      if (timer) {
        clearInterval(timer);
      }
    };
  }, [tempoRestante, temporizadorAtivo]);
  
  // Iniciar temporizador
  const iniciarTemporizador = () => {
    if (!hiperfocoSelecionadoId) return
    
    setTemporizadorAtivo(true)
    
    timerRef.current = setInterval(() => {
      setTempoRestante(prev => {
        if (prev <= 1) {
          // Temporizador chegou a zero
          tocarAlarme()
          pararTemporizador()
          return 0
        }
        return prev - 1
      })
    }, 1000)
  }
  
  // Parar temporizador
  const pararTemporizador = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current)
      timerRef.current = null
    }
    setTemporizadorAtivo(false)
  }
  
  // Pausar/Resumir temporizador
  const toggleTemporizador = () => {
    if (temporizadorAtivo) {
      pararTemporizador()
    } else {
      iniciarTemporizador()
    }
  }
  
  // Reiniciar temporizador
  const reiniciarTemporizador = () => {
    pararTemporizador()
    setTempoRestante(tempoTotal)
  }
  
  // Tocar som de alarme
  const tocarAlarme = () => {
    if (!somAtivado) return
    
    if (audioRef.current) {
      audioRef.current.currentTime = 0
      audioRef.current.play().catch(e => console.error('Erro ao tocar alarme:', e))
    }
  }
  
  // Formatar tempo para exibição (minutos:segundos)
  const formatarTempo = (segundos: number) => {
    const mins = Math.floor(segundos / 60)
    const segs = segundos % 60
    return `${mins.toString().padStart(2, '0')}:${segs.toString().padStart(2, '0')}`
  }
  
  // Calcular percentual de progresso
  const calcularProgresso = () => {
    if (tempoTotal === 0) return 0
    return ((tempoTotal - tempoRestante) / tempoTotal) * 100
  }
  
  // Configurar tempo personalizado
  const definirTempoPersonalizado = () => {
    const minutos = parseInt(tempoPersonalizado)
    if (isNaN(minutos) || minutos <= 0) return
    
    pararTemporizador()
    const segundos = minutos * 60
    setTempoTotal(segundos)
    setTempoRestante(segundos)
    setTempoPausa(Math.floor(segundos * 0.1)) // 10% do tempo para pausas
    setTempoPersonalizado('')
  }
  
  // Iniciar tempo de pausa
  const iniciarPausa = () => {
    pararTemporizador()
    setTempoRestante(tempoPausa)
    setTempoTotal(tempoPausa)
  }
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-6">
        Temporizador de Foco
      </h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-white dark:bg-gray-700 rounded-lg shadow-sm p-6">
          {/* Seletor de hiperfoco */}
          <div className="mb-6">
            <label htmlFor="hiperfoco-select" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Hiperfoco para temporizador
            </label>
            <select
              id="hiperfoco-select"
              value={hiperfocoSelecionadoId}
              onChange={(e) => setHiperfocoSelecionadoId(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            >
              <option value="">Selecione um hiperfoco</option>
              {hiperfocos.map((hiperfoco) => (
                <option key={hiperfoco.id} value={hiperfoco.id}>
                  {hiperfoco.titulo} {hiperfoco.tempoLimite ? `(${hiperfoco.tempoLimite} min)` : ''}
                </option>
              ))}
            </select>
          </div>
          
          {/* Tempo personalizado */}
          <div className="mb-6">
            <label htmlFor="tempo-personalizado" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Tempo personalizado (minutos)
            </label>
            <div className="flex">
              <input
                type="number"
                id="tempo-personalizado"
                value={tempoPersonalizado}
                onChange={(e) => setTempoPersonalizado(e.target.value)}
                min="1"
                className="flex-1 px-3 py-2 border border-gray-300 rounded-l-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                placeholder="Ex: 30"
              />
              <button
                onClick={definirTempoPersonalizado}
                className="px-4 py-2 bg-hiperfocos-primary text-white rounded-r-md hover:bg-hiperfocos-secondary"
                aria-label="Definir tempo personalizado"
              >
                Definir
              </button>
            </div>
          </div>
          
          {/* Áudio para o alarme */}
          <audio ref={audioRef} preload="auto">
            <source src="/sounds/alarm.mp3" type="audio/mpeg" />
            <source src="/sounds/alarm.ogg" type="audio/ogg" />
            Seu navegador não suporta o elemento de áudio.
          </audio>
          
          {/* Controle de som */}
          <div className="flex items-center justify-between mb-3">
            <span className="text-sm text-gray-600 dark:text-gray-300">
              Som de alarme
            </span>
            <button
              onClick={() => setSomAtivado(!somAtivado)}
              className={`p-2 rounded-md ${somAtivado ? 'text-hiperfocos-primary' : 'text-gray-400'}`}
              aria-label={somAtivado ? 'Desativar som' : 'Ativar som'}
              aria-pressed={somAtivado}
            >
              {somAtivado ? <Volume2 className="h-5 w-5" /> : <VolumeX className="h-5 w-5" />}
            </button>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-700 rounded-lg shadow-sm p-6 flex flex-col items-center justify-center">
          {/* Display do temporizador */}
          <div className="relative w-48 h-48 mb-6">
            <div 
              className="absolute inset-0 rounded-full bg-gray-200 dark:bg-gray-600"
              style={{
                background: `conic-gradient(
                  ${hiperfocoSelecionadoId && hiperfocos.find(h => h.id === hiperfocoSelecionadoId)?.cor || '#0EA5E9'} ${calcularProgresso()}%, 
                  #9CA3AF ${calcularProgresso()}%
                )`
              }}
            />
            <div className="absolute inset-2 rounded-full bg-white dark:bg-gray-700 flex items-center justify-center">
              <div className="text-4xl font-bold text-gray-800 dark:text-white">
                {formatarTempo(tempoRestante)}
              </div>
            </div>
          </div>
          
          {/* Controles do temporizador */}
          <div className="flex space-x-4">
            <button
              onClick={toggleTemporizador}
              disabled={!hiperfocoSelecionadoId && tempoTotal === 0}
              className="p-3 bg-hiperfocos-primary text-white rounded-full hover:bg-hiperfocos-secondary disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label={temporizadorAtivo ? 'Pausar temporizador' : 'Iniciar temporizador'}
            >
              {temporizadorAtivo ? <Pause className="h-6 w-6" /> : <Play className="h-6 w-6" />}
            </button>
            
            <button
              onClick={reiniciarTemporizador}
              disabled={tempoTotal === 0}
              className="p-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500 disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label="Reiniciar temporizador"
            >
              <RotateCcw className="h-6 w-6" />
            </button>
            
            <button
              onClick={iniciarPausa}
              disabled={!hiperfocoSelecionadoId && tempoTotal === 0}
              className="p-3 bg-hiperfocos-light text-hiperfocos-primary rounded-full hover:bg-opacity-80 disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label="Iniciar pausa"
            >
              <Bell className="h-6 w-6" />
            </button>
          </div>
          
          {/* Status do temporizador */}
          <div className="mt-4 text-sm text-gray-600 dark:text-gray-300">
            {temporizadorAtivo ? 'Temporizador ativo' : 'Temporizador parado'}
          </div>
        </div>
      </div>
      
      {/* Nota explicativa */}
      <div className="mt-6 p-4 bg-blue-50 text-blue-800 dark:bg-blue-900 dark:text-blue-100 rounded-md">
        <h3 className="font-medium mb-2 flex items-center">
          <Clock className="h-5 w-5 mr-2" />
          Dica para gerenciar o tempo
        </h3>
        <p className="text-sm">
          Utilizar temporizadores ajuda a manter o foco e evitar o hiperfoco prolongado. 
          Defina intervalos de trabalho e pausa regulares para melhorar a produtividade.
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/components/saude/MonitoramentoHumor.tsx">
'use client'

import { useState, useCallback, useMemo } from 'react'
import { Calendar, Plus, X, Edit, Trash, Smile, Frown, Meh, AlertCircle } from 'lucide-react'
import { useAppStore } from '@/app/store'
import { Card } from '../ui/Card'
import { Button } from '../ui/Button'
import { Input } from '../ui/Input'
import { Textarea } from '../ui/Textarea'
import { Badge } from '../ui/Badge'
import { Modal } from '../ui/Modal'
import { Alert } from '../ui/Alert'
import { StatCard } from './StatCard'
import { HumorCalendar } from './HumorCalendar'
import { FatoresHumor } from './FatoresHumor'
import { toast } from 'react-hot-toast'

export function MonitoramentoHumor() {
  // Usar o Zustand para gerenciamento de estado
  const { registrosHumor, adicionarRegistroHumor, atualizarRegistroHumor, removerRegistroHumor } = useAppStore(
    (state) => ({
      registrosHumor: state.registrosHumor || [],
      adicionarRegistroHumor: state.adicionarRegistroHumor,
      atualizarRegistroHumor: state.atualizarRegistroHumor,
      removerRegistroHumor: state.removerRegistroHumor,
    })
  )
  
  const [novoRegistro, setNovoRegistro] = useState({
    data: new Date().toISOString().split('T')[0],
    nivel: 3,
    fatores: [] as string[],
    notas: '',
  })
  
  const [editandoId, setEditandoId] = useState<string | null>(null)
  const [mostrarForm, setMostrarForm] = useState(false)
  const [novoFator, setNovoFator] = useState('')
  const [mesAtual, setMesAtual] = useState(() => new Date().getMonth())
  const [anoAtual, setAnoAtual] = useState(() => new Date().getFullYear())
  const [erro, setErro] = useState('')

  // Usar useCallback para funções que são passadas como props ou dependências
  const handleAdicionarRegistro = useCallback(() => {
    if (!novoRegistro.data) {
      setErro('A data é obrigatória')
      return
    }

    adicionarRegistroHumor({
      data: novoRegistro.data,
      nivel: novoRegistro.nivel,
      fatores: [...novoRegistro.fatores],
      notas: novoRegistro.notas,
    })
    
    resetForm()
  }, [adicionarRegistroHumor, novoRegistro])

  const iniciarEdicao = useCallback((registro: typeof registrosHumor[0]) => {
    setEditandoId(registro.id)
    setNovoRegistro({
      data: registro.data,
      nivel: registro.nivel,
      fatores: [...registro.fatores],
      notas: registro.notas,
    })
    setMostrarForm(true)
  }, [])

  const salvarEdicao = useCallback(() => {
    if (!editandoId || !novoRegistro.data) {
      setErro('A data é obrigatória')
      return
    }

    atualizarRegistroHumor(editandoId, {
      data: novoRegistro.data,
      nivel: novoRegistro.nivel,
      fatores: [...novoRegistro.fatores],
      notas: novoRegistro.notas,
    })
    
    resetForm()
  }, [atualizarRegistroHumor, editandoId, novoRegistro])

  const adicionarFator = useCallback(() => {
    if (!novoFator) return
    
    if (novoRegistro.fatores.includes(novoFator)) {
      setErro('Este fator já foi adicionado')
      return
    }
    
    setNovoRegistro({
      ...novoRegistro,
      fatores: [...novoRegistro.fatores, novoFator],
    })
    
    setNovoFator('')
    setErro('')
  }, [novoFator, novoRegistro])

  const removerFator = useCallback((fator: string) => {
    setNovoRegistro({
      ...novoRegistro,
      fatores: novoRegistro.fatores.filter((f) => f !== fator),
    })
  }, [novoRegistro])

  const resetForm = useCallback(() => {
    setNovoRegistro({
      data: new Date().toISOString().split('T')[0],
      nivel: 3,
      fatores: [],
      notas: '',
    })
    setEditandoId(null)
    setMostrarForm(false)
    setNovoFator('')
    setErro('')
  }, [])

  // Usar useMemo para cálculos ou transformações de dados
  const registrosOrdenados = useMemo(() => {
    return [...registrosHumor].sort((a, b) => new Date(b.data).getTime() - new Date(a.data).getTime())
  }, [registrosHumor])

  const registrosPorMes = useMemo(() => {
    const meses: Record<string, typeof registrosHumor> = {}
    
    registrosOrdenados.forEach((registro) => {
      const [ano, mes] = registro.data.split('-')
      const chave = `${ano}-${mes}`
      
      if (!meses[chave]) {
        meses[chave] = []
      }
      
      meses[chave].push(registro)
    })
    
    return meses
  }, [registrosOrdenados])

  const humorMedio = useMemo(() => {
    if (registrosHumor.length === 0) return 0
    
    const soma = registrosHumor.reduce((acc, registro) => acc + registro.nivel, 0)
    return (soma / registrosHumor.length).toFixed(1)
  }, [registrosHumor])

  const tendenciaHumor = useMemo(() => {
    if (registrosHumor.length < 5) return null
    
    const registrosRecentes = [...registrosHumor]
      .sort((a, b) => new Date(b.data).getTime() - new Date(a.data).getTime())
      .slice(0, 5)
    
    const registrosAnteriores = [...registrosHumor]
      .sort((a, b) => new Date(b.data).getTime() - new Date(a.data).getTime())
      .slice(5, 10)
    
    if (registrosAnteriores.length === 0) return null
    
    const mediaRecente = registrosRecentes.reduce((acc, reg) => acc + reg.nivel, 0) / registrosRecentes.length
    const mediaAnterior = registrosAnteriores.reduce((acc, reg) => acc + reg.nivel, 0) / registrosAnteriores.length
    
    const diferenca = ((mediaRecente - mediaAnterior) / mediaAnterior) * 100
    
    return {
      valor: Math.abs(Number(diferenca.toFixed(0))),
      positivo: diferenca > 0
    }
  }, [registrosHumor])

  const formatarData = useCallback((data: string) => {
    return new Date(data).toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    })
  }, [])

  const handleMesAnterior = useCallback(() => {
    setMesAtual(prev => {
      if (prev === 0) {
        setAnoAtual(ano => ano - 1)
        return 11
      }
      return prev - 1
    })
  }, [])

  const handleProximoMes = useCallback(() => {
    setMesAtual(prev => {
      if (prev === 11) {
        setAnoAtual(ano => ano + 1)
        return 0
      }
      return prev + 1
    })
  }, [])

  const handleSelecionarDia = useCallback((data: string) => {
    const registroExistente = registrosHumor.find(r => r.data === data)
    
    if (registroExistente) {
      iniciarEdicao(registroExistente)
    } else {
      setNovoRegistro(prev => ({ ...prev, data }))
      setMostrarForm(true)
      setEditandoId(null)
    }
  }, [registrosHumor, iniciarEdicao])

  const nomeDoMes = useMemo(() => {
    return new Date(anoAtual, mesAtual).toLocaleDateString('pt-BR', { month: 'long' })
  }, [mesAtual, anoAtual])

  const handleSubmit = useCallback(async (event: React.FormEvent) => {
    event.preventDefault();
    
    try {
      // ... código existente ...
      
      resetForm();
    } catch (error) {
      console.error('Erro ao salvar registro:', error);
      toast.error('Erro: Não foi possível salvar o registro');
    }
  }, [resetForm]);

  const handleCancel = useCallback(() => {
    resetForm();
  }, [resetForm]);

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-4">
        <Card className="flex-1">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
              Monitoramento de Humor
            </h2>
            <Button
              onClick={() => {
                resetForm()
                setMostrarForm(true)
              }}
              icon={<Plus className="h-4 w-4" />}
              aria-label="Adicionar novo registro de humor"
            >
              Novo Registro
            </Button>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <StatCard
              title="Humor Médio"
              value={humorMedio}
              icon={<Smile className="h-5 w-5" />}
              description="Baseado em todos os registros"
              trend={tendenciaHumor ? {
                value: Number(tendenciaHumor.valor),
                label: "últimos registros",
                positive: tendenciaHumor.positivo
              } : undefined}
            />
            
            <div className="md:col-span-2">
              <FatoresHumor registros={registrosHumor} />
            </div>
          </div>
          
          <div className="mb-6">
            <div className="flex flex-wrap justify-between items-center mb-3 gap-2">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                Calendário de Humor
              </h3>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleMesAnterior}
                  aria-label="Mês anterior"
                >
                  &larr;
                </Button>
                <span className="text-sm font-medium whitespace-nowrap">
                  {nomeDoMes} {anoAtual}
                </span>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleProximoMes}
                  aria-label="Próximo mês"
                >
                  &rarr;
                </Button>
              </div>
            </div>
            
            <div className="overflow-x-auto">
              <HumorCalendar
                registros={registrosHumor}
                mes={mesAtual}
                ano={anoAtual}
                onSelectDay={handleSelecionarDia}
              />
            </div>
          </div>
          
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
            Registros Recentes
          </h3>
          
          {registrosOrdenados.length === 0 ? (
            <Alert
              variant="info"
              title="Nenhum registro encontrado"
            >
              Adicione seu primeiro registro de humor usando o botão "Novo Registro".
            </Alert>
          ) : (
            <div className="space-y-3">
              {registrosOrdenados.slice(0, 5).map((registro) => (
                <Card key={registro.id} className="p-4">
                  <div className="flex justify-between items-start">
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 mb-1 flex-wrap">
                        <span className="font-medium text-gray-900 dark:text-white">
                          {formatarData(registro.data)}
                        </span>
                        <div className="flex items-center">
                          {[1, 2, 3, 4, 5].map((nivel) => (
                            <span
                              key={nivel}
                              className={`w-5 h-5 rounded-full flex items-center justify-center text-xs ${
                                nivel <= registro.nivel
                                  ? 'bg-saude-primary text-white'
                                  : 'bg-gray-200 dark:bg-gray-700 text-gray-500 dark:text-gray-400'
                              }`}
                              aria-label={`Nível ${nivel} de 5`}
                            >
                              {nivel}
                            </span>
                          ))}
                        </div>
                      </div>
                      
                      {registro.fatores.length > 0 && (
                        <div className="flex flex-wrap gap-1 mb-2">
                          {registro.fatores.map((fator) => (
                            <Badge key={fator} variant="secondary">
                              {fator}
                            </Badge>
                          ))}
                        </div>
                      )}
                      
                      {registro.notas && (
                        <p className="text-sm text-gray-600 dark:text-gray-300 break-words">
                          {registro.notas}
                        </p>
                      )}
                    </div>
                    
                    <div className="flex gap-1 ml-2 flex-shrink-0">
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => iniciarEdicao(registro)}
                        aria-label="Editar registro"
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => removerRegistroHumor(registro.id)}
                        aria-label="Remover registro"
                      >
                        <Trash className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                </Card>
              ))}
            </div>
          )}
        </Card>
      </div>

      {/* Modal para adicionar/editar registro */}
      <Modal
        isOpen={mostrarForm}
        onClose={resetForm}
        title={editandoId ? "Editar Registro de Humor" : "Novo Registro de Humor"}
        footer={
          <div className="flex justify-end gap-2">
            <Button variant="outline" onClick={resetForm}>
              Cancelar
            </Button>
            <Button 
              onClick={editandoId ? salvarEdicao : handleAdicionarRegistro}
            >
              {editandoId ? "Salvar Alterações" : "Adicionar Registro"}
            </Button>
          </div>
        }
      >
        {erro && (
          <Alert variant="error" className="mb-4">
            {erro}
          </Alert>
        )}
        
        <div className="space-y-4">
          <Input
            type="date"
            value={novoRegistro.data}
            onChange={(e) => setNovoRegistro({ ...novoRegistro, data: e.target.value })}
            label="Data"
            required
          />
          
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Nível de Humor (1-5)
            </label>
            <div className="flex gap-2">
              {[1, 2, 3, 4, 5].map((nivel) => (
                <button
                  key={nivel}
                  type="button"
                  onClick={() => setNovoRegistro({ ...novoRegistro, nivel })}
                  className={`w-10 h-10 rounded-full flex items-center justify-center ${
                    nivel === novoRegistro.nivel
                      ? 'bg-saude-primary text-white'
                      : 'bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600'
                  }`}
                  aria-label={`Nível de humor ${nivel}`}
                  aria-pressed={nivel === novoRegistro.nivel}
                >
                  {nivel}
                </button>
              ))}
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Fatores que Influenciaram
            </label>
            <div className="flex gap-2 mb-2">
              <Input
                value={novoFator}
                onChange={(e) => setNovoFator(e.target.value)}
                placeholder="Adicionar fator..."
                className="flex-1"
              />
              <Button
                onClick={adicionarFator}
                disabled={!novoFator}
                aria-label="Adicionar fator"
              >
                <Plus className="h-4 w-4" />
              </Button>
            </div>
            
            {novoRegistro.fatores.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {novoRegistro.fatores.map((fator) => (
                  <Badge key={fator} variant="secondary" className="flex items-center gap-1">
                    {fator}
                    <button
                      onClick={() => removerFator(fator)}
                      className="ml-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                      aria-label={`Remover fator ${fator}`}
                    >
                      <X className="h-3 w-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            )}
          </div>
          
          <Textarea
            value={novoRegistro.notas}
            onChange={(e) => setNovoRegistro({ ...novoRegistro, notas: e.target.value })}
            label="Notas (opcional)"
            placeholder="Adicione detalhes sobre como você se sentiu..."
          />
        </div>
      </Modal>
    </div>
  )
}
</file>

<file path="app/components/saude/RegistroMedicamentos.tsx">
'use client'

import { useState, useCallback, useMemo } from 'react'
import { Pill, Plus, X, Edit, Trash, Check, Clock, Calendar } from 'lucide-react'
import { useAppStore } from '@/app/store'
import { Card } from '../ui/Card'
import { Button } from '../ui/Button'
import { Input } from '../ui/Input'
import { Textarea } from '../ui/Textarea'
import { Select } from '../ui/Select'
import { Badge } from '../ui/Badge'
import { Modal } from '../ui/Modal'
import { Alert } from '../ui/Alert'
import { MedicamentosList } from './MedicamentosList'
import { StatCard } from './StatCard'
import { toast } from 'react-hot-toast'

export function RegistroMedicamentos() {
  // Usar o Zustand para gerenciamento de estado
  const { medicamentos, adicionarMedicamento, atualizarMedicamento, removerMedicamento, registrarTomadaMedicamento } = useAppStore(
    (state) => ({
      medicamentos: state.medicamentos || [],
      adicionarMedicamento: state.adicionarMedicamento,
      atualizarMedicamento: state.atualizarMedicamento,
      removerMedicamento: state.removerMedicamento,
      registrarTomadaMedicamento: state.registrarTomadaMedicamento,
    })
  )
  
  const [novoMedicamento, setNovoMedicamento] = useState({
    nome: '',
    dosagem: '',
    frequencia: 'Diária',
    horarios: ['08:00'],
    observacoes: '',
    dataInicio: new Date().toISOString().split('T')[0],
    intervalo: 240, // 4 horas por padrão (em minutos)
  })
  
  const [editandoId, setEditandoId] = useState<string | null>(null)
  const [mostrarForm, setMostrarForm] = useState(false)
  const [novoHorario, setNovoHorario] = useState('08:00')
  const [erro, setErro] = useState('')

  // Usar useCallback para funções que são passadas como props ou dependências
  const handleAdicionarMedicamento = useCallback(() => {
    if (!novoMedicamento.nome) {
      setErro('O nome do medicamento é obrigatório')
      return
    }

    if (novoMedicamento.horarios.length === 0) {
      setErro('Adicione pelo menos um horário')
      return
    }
    
    adicionarMedicamento({
      nome: novoMedicamento.nome,
      dosagem: novoMedicamento.dosagem,
      frequencia: novoMedicamento.frequencia,
      horarios: [...novoMedicamento.horarios],
      observacoes: novoMedicamento.observacoes,
      dataInicio: novoMedicamento.dataInicio,
      ultimaTomada: null,
      intervalo: novoMedicamento.intervalo,
    })
    
    resetForm()
  }, [adicionarMedicamento, novoMedicamento])

  const iniciarEdicao = useCallback((id: string) => {
    const medicamento = medicamentos.find(med => med.id === id);
    if (!medicamento) return;
    
    setEditandoId(medicamento.id)
    setNovoMedicamento({
      nome: medicamento.nome,
      dosagem: medicamento.dosagem,
      frequencia: medicamento.frequencia,
      horarios: [...medicamento.horarios],
      observacoes: medicamento.observacoes,
      dataInicio: medicamento.dataInicio,
      intervalo: medicamento.intervalo || 240, // Se não tiver intervalo definido, usar 4 horas como padrão
    })
    setMostrarForm(true)
  }, [medicamentos])

  const salvarEdicao = useCallback(() => {
    if (!editandoId || !novoMedicamento.nome) {
      setErro('O nome do medicamento é obrigatório')
      return
    }

    if (novoMedicamento.horarios.length === 0) {
      setErro('Adicione pelo menos um horário')
      return
    }
    
    atualizarMedicamento(editandoId, {
      nome: novoMedicamento.nome,
      dosagem: novoMedicamento.dosagem,
      frequencia: novoMedicamento.frequencia,
      horarios: [...novoMedicamento.horarios],
      observacoes: novoMedicamento.observacoes,
      dataInicio: novoMedicamento.dataInicio,
      intervalo: novoMedicamento.intervalo,
    })
    
    resetForm()
  }, [atualizarMedicamento, editandoId, novoMedicamento])

  const adicionarHorario = useCallback(() => {
    if (!novoHorario) return
    
    if (novoMedicamento.horarios.includes(novoHorario)) {
      setErro('Este horário já foi adicionado')
      return
    }
    
    setNovoMedicamento({
      ...novoMedicamento,
      horarios: [...novoMedicamento.horarios, novoHorario].sort(),
    })
    
    setNovoHorario('08:00')
    setErro('')
  }, [novoHorario, novoMedicamento])

  const removerHorario = useCallback((horario: string) => {
    setNovoMedicamento({
      ...novoMedicamento,
      horarios: novoMedicamento.horarios.filter((h) => h !== horario),
    })
  }, [novoMedicamento])

  const handleRegistrarTomada = useCallback((id: string) => {
    const agora = new Date().toISOString()
    registrarTomadaMedicamento(id, agora)
  }, [registrarTomadaMedicamento])

  const resetForm = useCallback(() => {
    setNovoMedicamento({
      nome: '',
      dosagem: '',
      frequencia: 'Diária',
      horarios: ['08:00'],
      observacoes: '',
      dataInicio: new Date().toISOString().split('T')[0],
      intervalo: 240, // 4 horas por padrão
    })
    setEditandoId(null)
    setMostrarForm(false)
    setNovoHorario('08:00')
    setErro('')
  }, [])

  const handleSubmit = useCallback(async (event: React.FormEvent) => {
    event.preventDefault();
    
    try {
      // ... código existente ...
      
      resetForm();
    } catch (error) {
      console.error('Erro ao salvar medicamento:', error);
      toast.error('Erro: Não foi possível salvar o medicamento');
    }
  }, [resetForm]);

  const handleCancel = useCallback(() => {
    resetForm();
  }, [resetForm]);

  // Estatísticas sobre medicamentos
  const estatisticas = useMemo(() => {
    const total = medicamentos.length
    const tomadosHoje = medicamentos.filter(med => {
      if (!med.ultimaTomada) return false
      const dataUltimaTomada = med.ultimaTomada.split('T')[0]
      const hoje = new Date().toISOString().split('T')[0]
      return dataUltimaTomada === hoje
    }).length
    
    const percentualTomados = total > 0 ? Math.round((tomadosHoje / total) * 100) : 0
    
    return {
      total,
      tomadosHoje,
      percentualTomados
    }
  }, [medicamentos])

  // Próxima dose calculada
  const proximaDose = useMemo(() => {
    if (medicamentos.length === 0) return { texto: "N/A", descricao: "Sem medicamentos" };
    
    const agora = new Date();
    const medicamentosOrdenados = [...medicamentos].sort((a, b) => {
      // Encontrar o próximo horário para cada medicamento
      const horariosA = a.horarios.map(h => {
        const [hora, minuto] = h.split(':').map(Number);
        const dataHora = new Date(agora);
        dataHora.setHours(hora, minuto, 0, 0);
        // Se o horário já passou hoje, considerar para amanhã
        if (dataHora < agora) {
          dataHora.setDate(dataHora.getDate() + 1);
        }
        return dataHora;
      });
      
      const horariosB = b.horarios.map(h => {
        const [hora, minuto] = h.split(':').map(Number);
        const dataHora = new Date(agora);
        dataHora.setHours(hora, minuto, 0, 0);
        if (dataHora < agora) {
          dataHora.setDate(dataHora.getDate() + 1);
        }
        return dataHora;
      });
      
      // Pegar o próximo horário mais próximo para cada medicamento
      const proximoA = horariosA.sort((x, y) => x.getTime() - y.getTime())[0];
      const proximoB = horariosB.sort((x, y) => x.getTime() - y.getTime())[0];
      
      return proximoA.getTime() - proximoB.getTime();
    });
    
    // Pegar o primeiro medicamento (o com próxima dose mais próxima)
    const proximoMedicamento = medicamentosOrdenados[0];
    
    // Calcular quanto tempo falta
    const proximoHorario = proximoMedicamento.horarios
      .map(h => {
        const [hora, minuto] = h.split(':').map(Number);
        const dataHora = new Date(agora);
        dataHora.setHours(hora, minuto, 0, 0);
        if (dataHora < agora) {
          dataHora.setDate(dataHora.getDate() + 1);
        }
        return dataHora;
      })
      .sort((a, b) => a.getTime() - b.getTime())[0];
    
    const diffMs = proximoHorario.getTime() - agora.getTime();
    const diffHoras = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMinutos = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    let textoTempo;
    if (diffHoras > 0) {
      textoTempo = `${diffHoras}h${diffMinutos > 0 ? ` ${diffMinutos}m` : ''}`;
    } else {
      textoTempo = `${diffMinutos}m`;
    }
    
    return {
      texto: textoTempo,
      descricao: proximoMedicamento.nome
    };
  }, [medicamentos])

  // Opções para frequência de medicamentos
  const opcoesFrequencia = [
    { value: 'Diária', label: 'Diária' },
    { value: 'Semanal', label: 'Semanal' },
    { value: 'Mensal', label: 'Mensal' },
    { value: 'Conforme necessário', label: 'Conforme necessário' },
  ]

  // Opções para intervalo entre doses
  const opcoesIntervalo = [
    { value: '60', label: '1 hora' },
    { value: '120', label: '2 horas' },
    { value: '180', label: '3 horas' },
    { value: '240', label: '4 horas' },
    { value: '360', label: '6 horas' },
    { value: '480', label: '8 horas' },
    { value: '720', label: '12 horas' },
    { value: '1440', label: '24 horas' },
  ]

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-4">
        <Card className="flex-1">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
              Registro de Medicamentos
            </h2>
            <Button
              onClick={() => {
                resetForm()
                setMostrarForm(true)
              }}
              icon={<Plus className="h-4 w-4" />}
              aria-label="Adicionar novo medicamento"
            >
              Novo Medicamento
            </Button>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <StatCard
              title="Total de Medicamentos"
              value={estatisticas.total}
              icon={<Pill className="h-5 w-5" />}
            />
            
            <StatCard
              title="Tomados Hoje"
              value={estatisticas.tomadosHoje}
              icon={<Check className="h-5 w-5" />}
              description={`${estatisticas.percentualTomados}% dos medicamentos`}
            />
            
            <StatCard
              title="Próxima Dose"
              value={proximaDose.texto}
              icon={<Clock className="h-5 w-5" />}
              description={proximaDose.descricao}
            />
          </div>
          
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
            Seus Medicamentos
          </h3>
          
          <MedicamentosList
            medicamentos={medicamentos}
            onEdit={iniciarEdicao}
            onDelete={removerMedicamento}
            onRegistrarTomada={handleRegistrarTomada}
          />
        </Card>
      </div>

      {/* Modal para adicionar/editar medicamento */}
      <Modal
        isOpen={mostrarForm}
        onClose={resetForm}
        title={editandoId ? "Editar Medicamento" : "Novo Medicamento"}
        footer={
          <div className="flex justify-end gap-2">
            <Button variant="outline" onClick={resetForm}>
              Cancelar
            </Button>
            <Button 
              onClick={editandoId ? salvarEdicao : handleAdicionarMedicamento}
            >
              {editandoId ? "Salvar Alterações" : "Adicionar Medicamento"}
            </Button>
          </div>
        }
      >
        {erro && (
          <Alert variant="error" className="mb-4">
            {erro}
          </Alert>
        )}
        
        <div className="space-y-4">
          <Input
            value={novoMedicamento.nome}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, nome: e.target.value })}
            label="Nome do Medicamento"
            placeholder="Ex: Ritalina, Fluoxetina"
            required
          />
          
          <Input
            value={novoMedicamento.dosagem}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, dosagem: e.target.value })}
            label="Dosagem"
            placeholder="Ex: 10mg, 1 comprimido"
          />
          
          <Select
            value={novoMedicamento.frequencia}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, frequencia: e.target.value })}
            label="Frequência"
            options={opcoesFrequencia}
          />
          
          <Select
            value={novoMedicamento.intervalo?.toString() || '240'}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, intervalo: parseInt(e.target.value) })}
            label="Intervalo entre doses"
            options={opcoesIntervalo}
            helpText="Tempo mínimo recomendado entre uma dose e outra"
          />
          
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Horários
            </label>
            <div className="flex gap-2 mb-2">
              <Input
                type="time"
                value={novoHorario}
                onChange={(e) => setNovoHorario(e.target.value)}
                className="flex-1"
              />
              <Button
                onClick={adicionarHorario}
                aria-label="Adicionar horário"
              >
                <Plus className="h-4 w-4" />
              </Button>
            </div>
            
            {novoMedicamento.horarios.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {novoMedicamento.horarios.map((horario) => (
                  <Badge key={horario} variant="primary" className="flex items-center gap-1">
                    <Clock className="h-3 w-3 mr-1" />
                    {horario}
                    <button
                      onClick={() => removerHorario(horario)}
                      className="ml-1 text-blue-700 hover:text-blue-900 dark:text-blue-300 dark:hover:text-blue-100"
                      aria-label={`Remover horário ${horario}`}
                    >
                      <X className="h-3 w-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            )}
          </div>
          
          <Input
            type="date"
            value={novoMedicamento.dataInicio}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, dataInicio: e.target.value })}
            label="Data de Início"
          />
          
          <Textarea
            value={novoMedicamento.observacoes}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, observacoes: e.target.value })}
            label="Observações (opcional)"
            placeholder="Adicione informações importantes sobre o medicamento..."
          />
        </div>
      </Modal>
    </div>
  )
}
</file>

<file path="app/components/ui/Toast.tsx">
'use client'

import { useState, useEffect } from 'react'
import { X, CheckCircle, AlertCircle, Info, AlertTriangle } from 'lucide-react'

type ToastType = 'success' | 'error' | 'info' | 'warning'

type ToastProps = {
  type: ToastType
  message: string
  duration?: number
  onClose?: () => void
  show: boolean
}

// Estado global para o toast atual
let toastCallback: ((props: { title?: string, description: string, variant?: ToastType }) => void) | null = null;

export function Toast({
  type = 'info',
  message,
  duration = 5000,
  onClose,
  show
}: ToastProps) {
  const [isVisible, setIsVisible] = useState(true)

  const handleClose = () => {
    setIsVisible(false)
    onClose?.()
  }

  useEffect(() => {
    if (duration && isVisible) {
      const timer = setTimeout(handleClose, duration)
      return () => clearTimeout(timer)
    }
  }, [isVisible, duration, handleClose])

  // Se não estiver visível, não renderizar nada
  if (!isVisible) return null

  // Classes baseadas no tipo de toast
  const typeClasses = {
    success: 'bg-green-50 dark:bg-green-900/20 border-green-500 text-green-800 dark:text-green-200',
    error: 'bg-red-50 dark:bg-red-900/20 border-red-500 text-red-800 dark:text-red-200',
    info: 'bg-blue-50 dark:bg-blue-900/20 border-blue-500 text-blue-800 dark:text-blue-200',
    warning: 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-500 text-yellow-800 dark:text-yellow-200'
  }

  // Ícones baseados no tipo de toast
  const icons = {
    success: <CheckCircle className="h-5 w-5" />,
    error: <AlertCircle className="h-5 w-5" />,
    info: <Info className="h-5 w-5" />,
    warning: <AlertTriangle className="h-5 w-5" />
  }

  return (
    <div className="fixed bottom-4 right-4 z-50">
      <div 
        className={`p-4 rounded-md shadow-md border-l-4 flex items-start gap-3 max-w-md animate-fade-in-up ${typeClasses[type]}`}
      >
        <div className="flex-shrink-0">
          {icons[type]}
        </div>
        <div className="flex-1">
          <p className="text-sm font-medium">{message}</p>
        </div>
        <button 
          onClick={handleClose}
          className="flex-shrink-0 flex items-center justify-center h-5 w-5 rounded-full hover:bg-black/10 transition-colors"
          aria-label="Fechar"
        >
          <X className="h-3 w-3" />
        </button>
      </div>
    </div>
  )
}

// Cria uma função toast que os outros componentes podem usar
export function setToastCallback(callback: (props: { title?: string, description: string, variant?: ToastType }) => void) {
  toastCallback = callback;
}

// Função para mostrar um toast
export const toast = (props: { title?: string, description: string, variant?: ToastType }) => {
  if (toastCallback) {
    toastCallback(props);
  } else {
    // Fallback para console quando o componente Toast não estiver montado
    console.log(`Toast: ${props.title || ''} - ${props.description}`);
  }
}

// Animação para o toast
// Adicione isso ao seu arquivo globals.css ou tailwind.config.js
// @keyframes fadeInUp {
//   from {
//     opacity: 0;
//     transform: translateY(1rem);
//   }
//   to {
//     opacity: 1;
//     transform: translateY(0);
//   }
// }
// .animate-fade-in-up {
//   animation: fadeInUp 0.3s ease-out;
// }
</file>

<file path="app/components/SyncStatus.tsx">
import { useDataSync } from '../hooks/useDataSync'
import { useStore } from '../stores/store'
import { Button } from '@/app/components/ui/Button'
import { Loader2 } from 'lucide-react'

export function SyncStatus() {
  const store = useStore()
  const { syncStatus } = useDataSync({
    table: 'priorities',
    localStorageKey: 'priorities',
    getLocalData: () => store.prioridades,
    setLocalData: (data) => store.setPrioridades(data),
    enabled: true,
    interval: 5000 // sincroniza a cada 5 segundos
  })

  return (
    <div className="flex items-center gap-2">
      {syncStatus === 'syncing' && (
        <>
          <Loader2 className="h-4 w-4 animate-spin" />
          <span className="text-sm text-muted-foreground">Sincronizando...</span>
        </>
      )}
      {syncStatus === 'error' && (
        <>
          <span className="text-sm text-destructive">Erro na sincronização</span>
          <Button variant="outline" size="sm" onClick={() => window.location.reload()}>
            Tentar novamente
          </Button>
        </>
      )}
    </div>
  )
}
</file>

<file path="app/context/AuthContext.tsx">
'use client';

import { createContext, useContext, ReactNode, useEffect } from 'react';
import { User, Session } from '@supabase/supabase-js';
import { useAuth } from '@/app/hooks/useAuth';
import { useDataSync } from '@/app/hooks/useDataSync';
import { useStore } from '@/app/stores/store';
import { BaseItem } from '@/app/types/supabase';

type AuthContextType = {
  user: User | null;
  session: Session | null;
  loading: boolean;
  error: Error | null;
  signInWithEmail: (email: string, password: string) => Promise<{ data: any; error: any }>;
  signUpWithEmail: (email: string, password: string, userData?: { [key: string]: any }) => Promise<{ data: any; error: any }>;
  signOut: () => Promise<{ success: boolean; error: any }>;
  signInWithGoogle: () => Promise<{ data: any; error: any }>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Configurações comuns para sincronização
const SYNC_CONFIG = {
  enabled: true,
  interval: 30000 // aumentado para 30 segundos para reduzir a frequência
} as const;

export function AuthProvider({ children }: { children: ReactNode }) {
  const auth = useAuth();
  const store = useStore();

  // Configurar sincronização para cada tipo de dado
  const prioritiesSync = useDataSync({
    table: 'priorities',
    localStorageKey: 'priorities',
    getLocalData: () => store.prioridades,
    setLocalData: (data) => {
      if (JSON.stringify(data) !== JSON.stringify(store.prioridades)) {
        store.setPrioridades(data);
      }
    },
    ...SYNC_CONFIG
  });

  const medicationsSync = useDataSync({
    table: 'medications',
    localStorageKey: 'medications',
    getLocalData: () => store.medicamentos,
    setLocalData: (data) => {
      if (JSON.stringify(data) !== JSON.stringify(store.medicamentos)) {
        store.setMedicamentos(data);
      }
    },
    ...SYNC_CONFIG
  });

  const moodRecordsSync = useDataSync({
    table: 'mood_records',
    localStorageKey: 'mood_records',
    getLocalData: () => store.registrosHumor,
    setLocalData: (data) => {
      if (JSON.stringify(data) !== JSON.stringify(store.registrosHumor)) {
        store.setRegistrosHumor(data);
      }
    },
    ...SYNC_CONFIG
  });

  const sleepRecordsSync = useDataSync({
    table: 'sleep_records',
    localStorageKey: 'sleep_records',
    getLocalData: () => store.registrosSono,
    setLocalData: (data) => {
      if (JSON.stringify(data) !== JSON.stringify(store.registrosSono)) {
        store.setRegistrosSono(data);
      }
    },
    ...SYNC_CONFIG
  });

  // Sincronização inicial apenas quando o usuário estiver autenticado
  useEffect(() => {
    if (auth.user && !auth.loading) {
      Promise.all([
        prioritiesSync.synchronize(),
        medicationsSync.synchronize(),
        moodRecordsSync.synchronize(),
        sleepRecordsSync.synchronize()
      ]).catch(console.error);
    }
  }, [auth.user, auth.loading]);

  return (
    <AuthContext.Provider value={auth}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuthContext() {
  const context = useContext(AuthContext);

  if (typeof window === 'undefined') {
    return {
      user: null,
      session: null,
      loading: true,
      error: null,
      signInWithEmail: () => Promise.resolve({ data: null, error: null }),
      signUpWithEmail: () => Promise.resolve({ data: null, error: null }),
      signOut: () => Promise.resolve({ success: false, error: null }),
      signInWithGoogle: () => Promise.resolve({ data: null, error: null })
    };
  }

  if (!context) {
    throw new Error('useAuthContext must be used within an AuthProvider');
  }

  return context;
}
</file>

<file path="app/hooks/useSleep.ts">
import { useCallback, useState, useRef, useEffect } from 'react';
import { createClient } from '@/app/lib/supabase';
import { useAuthContext } from '@/app/context/AuthContext';
import { 
  SleepRecord, 
  SleepReminder, 
  NewSleepRecord, 
  SleepRecordUpdate,
  NewSleepReminder,
  SleepReminderUpdate 
} from '@/app/types/supabase';

// Definindo o tipo de retorno para a função de migração
type MigrationResult = {
  success: boolean;
  recordsCount: number;
  remindersCount: number;
  duplicateRecordsCount: number;
  duplicateRemindersCount: number;
  error?: string;
};

// Cache para armazenar os resultados das requisições
const cache = {
  sleepRecords: new Map<string, { data: SleepRecord[]; timestamp: number }>(),
  sleepReminders: new Map<string, { data: SleepReminder[]; timestamp: number }>(),
};

// Tempo de expiração do cache em milissegundos (5 minutos)
const CACHE_EXPIRATION = 5 * 60 * 1000;

// Função para verificar se o cache está válido
const isCacheValid = (timestamp: number) => {
  return Date.now() - timestamp < CACHE_EXPIRATION;
};

export function useSleep() {
  const supabase = createClient();
  const { user } = useAuthContext();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // Ref para controlar se o componente está montado
  const isMounted = useRef(true);
  
  // Ref para debounce
  const debounceTimer = useRef<NodeJS.Timeout>();
  
  // Configurar e limpar flag de montagem
  useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
    };
  }, []);
  
  // Função para limpar erros
  const resetError = useCallback(() => {
    if (isMounted.current) {
      setError(null);
    }
  }, []);

  // Função de debounce com tipo genérico
  const debounce = <T>(fn: () => Promise<T>, delay: number = 300): Promise<T> => {
    if (debounceTimer.current) {
      clearTimeout(debounceTimer.current);
    }
    return new Promise((resolve) => {
      debounceTimer.current = setTimeout(async () => {
        const result = await fn();
        resolve(result);
      }, delay);
    });
  };

  // GERENCIAMENTO DE REGISTROS DE SONO

  // Obter todos os registros de sono do usuário
  const getSleepRecords = useCallback(async (): Promise<SleepRecord[]> => {
    if (!user || !isMounted.current) return [];
    
    const cacheKey = `${user.id}_records`;
    const cachedData = cache.sleepRecords.get(cacheKey);
    
    if (cachedData && isCacheValid(cachedData.timestamp)) {
      return cachedData.data;
    }
    
    if (isMounted.current) {
      setIsLoading(true);
      setError(null);
    }
    
    try {
      const result = await debounce<SleepRecord[]>(async () => {
        const { data, error } = await supabase
          .from('sleep_records')
          .select('*')
          .eq('user_id', user.id)
          .order('start_time', { ascending: false });
          
        if (error) throw new Error(error.message);
        
        // Atualizar cache
        const records = data || [];
        cache.sleepRecords.set(cacheKey, {
          data: records,
          timestamp: Date.now(),
        });
        
        return records;
      });
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar registros de sono';
      if (isMounted.current) {
        setError(new Error(errorMessage));
      }
      return [];
    } finally {
      if (isMounted.current) {
        setIsLoading(false);
      }
    }
  }, [user, supabase]);
  
  // Obter um registro de sono específico por ID
  const getSleepRecord = useCallback(async (id: string): Promise<SleepRecord | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('sleep_records')
        .select('*')
        .eq('id', id)
        .eq('user_id', user.id)
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar registro de sono';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Adicionar um novo registro de sono
  const addSleepRecord = useCallback(async (record: NewSleepRecord): Promise<SleepRecord | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('sleep_records')
        .insert([
          { 
            ...record,
            user_id: user.id,
          }
        ])
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao adicionar registro de sono';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Atualizar um registro de sono existente
  const updateSleepRecord = useCallback(async (id: string, updates: SleepRecordUpdate): Promise<SleepRecord | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('sleep_records')
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao atualizar registro de sono';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Registrar hora de acordar (completar um registro de sono)
  const recordWakeUp = useCallback(async (id: string, endTime: string, quality?: number | null, notes?: string | null): Promise<SleepRecord | null> => {
    return updateSleepRecord(id, { 
      end_time: endTime,
      quality,
      notes,
      updated_at: new Date().toISOString()
    });
  }, [updateSleepRecord]);
  
  // Excluir um registro de sono
  const deleteSleepRecord = useCallback(async (id: string): Promise<boolean> => {
    if (!user) return false;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { error } = await supabase
        .from('sleep_records')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id);
        
      if (error) throw new Error(error.message);
      
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao excluir registro de sono';
      setError(new Error(errorMessage));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);

  // GERENCIAMENTO DE LEMBRETES

  // Obter todos os lembretes de sono do usuário
  const getSleepReminders = useCallback(async (): Promise<SleepReminder[]> => {
    if (!user) return [];
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('sleep_reminders')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: true });
        
      if (error) throw new Error(error.message);
      
      return data || [];
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar lembretes de sono';
      setError(new Error(errorMessage));
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Adicionar um novo lembrete de sono
  const addSleepReminder = useCallback(async (reminder: NewSleepReminder): Promise<SleepReminder | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('sleep_reminders')
        .insert([
          { 
            ...reminder,
            user_id: user.id,
          }
        ])
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao adicionar lembrete de sono';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Atualizar um lembrete de sono existente
  const updateSleepReminder = useCallback(async (id: string, updates: SleepReminderUpdate): Promise<SleepReminder | null> => {
    if (!user) return null;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { data, error } = await supabase
        .from('sleep_reminders')
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      
      return data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao atualizar lembrete de sono';
      setError(new Error(errorMessage));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Alternar o estado ativo de um lembrete
  const toggleReminderActive = useCallback(async (id: string, active: boolean): Promise<SleepReminder | null> => {
    return updateSleepReminder(id, { active });
  }, [updateSleepReminder]);
  
  // Excluir um lembrete de sono
  const deleteSleepReminder = useCallback(async (id: string): Promise<boolean> => {
    if (!user) return false;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const { error } = await supabase
        .from('sleep_reminders')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id);
        
      if (error) throw new Error(error.message);
      
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao excluir lembrete de sono';
      setError(new Error(errorMessage));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  // Migrar registros de sono do localStorage para o Supabase
  const migrateFromLocalStorage = useCallback(async (): Promise<MigrationResult> => {
    if (!user) {
      return {
        success: false,
        recordsCount: 0,
        remindersCount: 0,
        duplicateRecordsCount: 0,
        duplicateRemindersCount: 0,
        error: 'Usuário não autenticado'
      };
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Obter dados do localStorage
      const sleepRecordsData = localStorage.getItem('sleepRecords');
      const sleepRemindersData = localStorage.getItem('sleepReminders');
      
      if (!sleepRecordsData && !sleepRemindersData) {
        return {
          success: true,
          recordsCount: 0,
          remindersCount: 0,
          duplicateRecordsCount: 0,
          duplicateRemindersCount: 0
        };
      }
      
      // Inicializar contadores
      let recordsCount = 0;
      let remindersCount = 0;
      let duplicateRecordsCount = 0;
      let duplicateRemindersCount = 0;
      
      // Migrar registros de sono, se existirem
      if (sleepRecordsData) {
        try {
          const parsedRecords = JSON.parse(sleepRecordsData);
          
          if (Array.isArray(parsedRecords)) {
            const recordsToInsert = [];
            
            // Verificar e preparar registros para inserção
            for (const record of parsedRecords) {
              // Verificar duplicação com base no horário de início
              const { data: existingRecord } = await supabase
                .from('sleep_records')
                .select('id')
                .eq('user_id', user.id)
                .eq('start_time', record.start_time)
                .maybeSingle();
                
              if (existingRecord) {
                duplicateRecordsCount++;
                continue;
              }
              
              recordsToInsert.push({
                start_time: record.start_time,
                end_time: record.end_time,
                quality: record.quality,
                notes: record.notes || '',
                user_id: user.id
              });
            }
            
            if (recordsToInsert.length > 0) {
              const { error: recordsError } = await supabase
                .from('sleep_records')
                .insert(recordsToInsert);
                
              if (recordsError) throw new Error(recordsError.message);
              
              recordsCount = recordsToInsert.length;
            }
          }
        } catch (err) {
          console.error("Erro ao processar registros de sono:", err);
        }
      }
      
      // Migrar lembretes, se existirem
      if (sleepRemindersData) {
        try {
          const parsedReminders = JSON.parse(sleepRemindersData);
          
          if (Array.isArray(parsedReminders)) {
            const remindersToInsert = [];
            
            // Verificar e preparar lembretes para inserção
            for (const reminder of parsedReminders) {
              // Verificar duplicação com base no horário e tipo
              const { data: existingReminder } = await supabase
                .from('sleep_reminders')
                .select('id')
                .eq('user_id', user.id)
                .eq('type', reminder.type)
                .eq('time', reminder.time)
                .maybeSingle();
                
              if (existingReminder) {
                duplicateRemindersCount++;
                continue;
              }
              
              remindersToInsert.push({
                type: reminder.type,
                time: reminder.time,
                days_of_week: reminder.days_of_week,
                active: reminder.active,
                user_id: user.id
              });
            }
            
            if (remindersToInsert.length > 0) {
              const { error: remindersError } = await supabase
                .from('sleep_reminders')
                .insert(remindersToInsert);
                
              if (remindersError) throw new Error(remindersError.message);
              
              remindersCount = remindersToInsert.length;
            }
          }
        } catch (err) {
          console.error("Erro ao processar lembretes de sono:", err);
        }
      }
      
      return {
        success: true,
        recordsCount,
        remindersCount,
        duplicateRecordsCount,
        duplicateRemindersCount
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao migrar dados de sono';
      setError(new Error(errorMessage));
      return {
        success: false,
        recordsCount: 0,
        remindersCount: 0,
        duplicateRecordsCount: 0,
        duplicateRemindersCount: 0,
        error: errorMessage
      };
    } finally {
      setIsLoading(false);
    }
  }, [user, supabase]);
  
  return {
    // Estado
    isLoading,
    error,
    resetError,
    
    // Operações de registros de sono
    getSleepRecords,
    getSleepRecord,
    addSleepRecord,
    updateSleepRecord,
    recordWakeUp,
    deleteSleepRecord,
    
    // Operações de lembretes
    getSleepReminders,
    addSleepReminder,
    updateSleepReminder,
    toggleReminderActive,
    deleteSleepReminder,
    
    // Migração
    migrateFromLocalStorage
  };
}
</file>

<file path="app/lib/services/api.js">
import axios from 'axios';
import { supabase } from '../lib/supabase';

// Cache simplificado
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutos em desenvolvimento
const cache = new Map();

// Função simplificada para fazer requisições
const fetchData = async (endpoint) => {
  const cacheKey = endpoint;
  
  // Verificar cache primeiro
  const cached = cache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  
  try {
    const { data, error } = await supabase
      .from(endpoint.slice(1))
      .select('*')
      .order('updated_at', { ascending: false })
      .limit(20);
      
    if (error) throw error;
    
    // Armazenar no cache
    cache.set(cacheKey, {
      data,
      timestamp: Date.now()
    });
    
    return data;
  } catch (error) {
    console.error('Erro na requisição:', error);
    return [];
  }
};

// Métodos simplificados da API
const apiService = {
  // Medications
  getMedications: () => fetchData('/medications'),
  createMedication: async (data) => {
    const { data: result } = await supabase.from('medications').insert(data);
    cache.delete('/medications');
    return result;
  },
  updateMedication: async (id, data) => {
    const { data: result } = await supabase.from('medications').update(data).eq('id', id);
    cache.delete('/medications');
    return result;
  },
  
  // Mood records
  getMoodRecords: () => fetchData('/mood_records'),
  createMoodRecord: async (data) => {
    const { data: result } = await supabase.from('mood_records').insert(data);
    cache.delete('/mood_records');
    return result;
  },
  
  // Sleep records
  getSleepRecords: () => fetchData('/sleep_records'),
  createSleepRecord: async (data) => {
    const { data: result } = await supabase.from('sleep_records').insert(data);
    cache.delete('/sleep_records');
    return result;
  },
  
  // Priorities
  getPriorities: () => fetchData('/priorities'),
  createPriority: async (data) => {
    const { data: result } = await supabase.from('priorities').insert(data);
    cache.delete('/priorities');
    return result;
  },
  updatePriority: async (id, data) => {
    const { data: result } = await supabase.from('priorities').update(data).eq('id', id);
    cache.delete('/priorities');
    return result;
  },
  
  // Limpar cache
  clearCache: () => {
    cache.clear();
    console.log('Cache limpo com sucesso');
  }
};

export default apiService;
</file>

<file path="app/lib/utils/apiClient.js">
import axios from 'axios';
import { handleError, ErrorTypes, AppError } from './errorHandler';
import { logApiCall } from './logger';

// Configuração do cliente Axios
const apiClient = axios.create({
  baseURL: process.env.REACT_APP_API_URL || 'https://api.stayfocus.app',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Interceptor para adicionar token de autenticação
apiClient.interceptors.request.use(config => {
  const token = localStorage.getItem('authToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Função para esperar antes de tentar novamente
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

// Configuração de retry
const retryConfig = {
  maxRetries: 3,
  initialDelayMs: 1000, // 1 segundo
  maxDelayMs: 10000,    // 10 segundos
  shouldRetry: (error) => {
    // Retornar true apenas para erros de rede ou 5xx
    const errorType = error.type || (error.isAxiosError ? 
      identifyErrorType(error) : ErrorTypes.UNKNOWN);
    
    return errorType === ErrorTypes.NETWORK || 
           (error.response && error.response.status >= 500);
  }
};

// Função com lógica de retry
export async function fetchWithRetry(requestFn, retryOptions = {}) {
  const options = { ...retryConfig, ...retryOptions };
  let lastError = null;
  let retryCount = 0;
  
  const startTime = Date.now();
  
  while (retryCount <= options.maxRetries) {
    try {
      const response = await requestFn();
      
      // Log de sucesso após retries
      if (retryCount > 0) {
        logApiCall({
          url: requestFn.url || 'unknown',
          success: true,
          retryCount,
          duration: Date.now() - startTime
        });
      }
      
      return response;
    } catch (error) {
      lastError = handleError(error);
      
      if (retryCount >= options.maxRetries || !options.shouldRetry(lastError)) {
        break;
      }
      
      // Exponential backoff com jitter
      const delayMs = Math.min(
        options.initialDelayMs * Math.pow(2, retryCount) * (0.9 + Math.random() * 0.2),
        options.maxDelayMs
      );
      
      console.warn(`Tentativa #${retryCount + 1} falhou. Tentando novamente em ${delayMs}ms`);
      await delay(delayMs);
      retryCount++;
    }
  }
  
  // Log de falha final
  logApiCall({
    url: requestFn.url || 'unknown',
    success: false,
    retryCount,
    duration: Date.now() - startTime,
    error: lastError
  });
  
  throw lastError;
}

// API wrapper methods com retry integrado
const apiClientMethods = {
  async get(url, config = {}) {
    return fetchWithRetry(() => apiClient.get(url, config));
  },
  
  async post(url, data, config = {}) {
    return fetchWithRetry(() => apiClient.post(url, data, config));
  },
  
  async put(url, data, config = {}) {
    return fetchWithRetry(() => apiClient.put(url, data, config));
  },
  
  async delete(url, config = {}) {
    return fetchWithRetry(() => apiClient.delete(url, config));
  }
};

export default apiClientMethods;
</file>

<file path="app/lib/utils/logger.js">
/**
 * Sistema de logging para a aplicação StayFocus
 */

// Níveis de log
const LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  PERFORMANCE: 4
};

// Configuração atual
const config = {
  currentLevel: process.env.NODE_ENV === 'production' ? LOG_LEVELS.WARN : LOG_LEVELS.DEBUG,
  sendToServer: process.env.NODE_ENV === 'production',
  serverEndpoint: '/api/logs',
  maxQueueSize: 50,
  batchSendInterval: 60000, // 1 minuto
};

// Fila de logs para envio em batch
let logQueue = [];
let sendInterval = null;

// Formatar log para exibição/armazenamento
function formatLog(level, message, data = {}) {
  return {
    timestamp: new Date().toISOString(),
    level,
    message,
    data,
    userAgent: navigator.userAgent,
    url: window.location.href,
    sessionId: localStorage.getItem('sessionId') || 'unknown'
  };
}

// Enviar logs para o servidor
async function sendLogsToServer() {
  if (!logQueue.length) return;
  
  const logsToSend = [...logQueue];
  logQueue = [];
  
  if (config.sendToServer) {
    try {
      await fetch(config.serverEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ logs: logsToSend }),
        // Não queremos que falhas de log causem retries
        keepalive: true
      });
    } catch (error) {
      console.error('Falha ao enviar logs para o servidor:', error);
    }
  }
}

// Iniciar intervalo de envio
function startSendInterval() {
  if (!sendInterval) {
    sendInterval = setInterval(sendLogsToServer, config.batchSendInterval);
  }
}

// Adicionar log à fila
function queueLog(level, message, data) {
  const logEntry = formatLog(level, message, data);
  logQueue.push(logEntry);
  
  if (logQueue.length >= config.maxQueueSize) {
    sendLogsToServer();
  }
  
  startSendInterval();
  return logEntry;
}

// Funções exportadas
export function logDebug(message, data) {
  if (config.currentLevel <= LOG_LEVELS.DEBUG) {
    console.debug(`[DEBUG] ${message}`, data);
    return queueLog('debug', message, data);
  }
}

export function logInfo(message, data) {
  if (config.currentLevel <= LOG_LEVELS.INFO) {
    console.info(`[INFO] ${message}`, data);
    return queueLog('info', message, data);
  }
}

export function logWarning(message, data) {
  if (config.currentLevel <= LOG_LEVELS.WARN) {
    console.warn(`[WARN] ${message}`, data);
    return queueLog('warn', message, data);
  }
}

export function logError(message, data) {
  if (config.currentLevel <= LOG_LEVELS.ERROR) {
    console.error(`[ERROR] ${message}`, data);
    return queueLog('error', message, data);
  }
}

export function logPerformance(message, metrics) {
  if (config.currentLevel <= LOG_LEVELS.PERFORMANCE) {
    console.info(`[PERF] ${message}`, metrics);
    return queueLog('performance', message, metrics);
  }
}

// Configuração
export function configureLogger(options = {}) {
  Object.assign(config, options);
}

// Inicializar
startSendInterval();

// Limpar intervalo quando a página for fechada
window.addEventListener('beforeunload', () => {
  if (sendInterval) {
    clearInterval(sendInterval);
    sendLogsToServer();
  }
});

const logger = {
  logDebug,
  logInfo,
  logWarning,
  logError,
  logPerformance,
  configureLogger
};

export default logger;
</file>

<file path="app/lib/utils/queryPerformance.js">
import { info, warn } from './logger';

/**
 * Utilitário para monitorar a performance das queries
 */

// Limites para avisar sobre queries lentas (em ms)
const PERFORMANCE_THRESHOLDS = {
  DB_QUERY: 100,     // Query de banco de dados local
  API_REQUEST: 500,  // Requisição para a API
  RENDER: 50,        // Tempo de renderização de componente
};

// Armazena métricas de performance
const performanceMetrics = {
  queries: {},
  apiCalls: {},
  renders: {}
};

// Monitor de performance para queries de DB
export function monitorDBQuery(queryName, queryFn) {
  return async (...args) => {
    const startTime = performance.now();
    try {
      const result = await queryFn(...args);
      const duration = performance.now() - startTime;
      
      // Registrar a métrica
      trackPerformance('DB_QUERY', queryName, duration, args);
      
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      
      // Registrar erro de query
      trackPerformance('DB_QUERY', queryName, duration, args, error);
      
      throw error;
    }
  };
}

// Monitor de performance para chamadas de API
export function monitorAPICall(apiCallName, apiFn) {
  return async (...args) => {
    const startTime = performance.now();
    try {
      const result = await apiFn(...args);
      const duration = performance.now() - startTime;
      
      // Registrar a métrica
      trackPerformance('API_REQUEST', apiCallName, duration, args);
      
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      
      // Registrar erro de API
      trackPerformance('API_REQUEST', apiCallName, duration, args, error);
      
      throw error;
    }
  };
}

// HOC para monitorar performance de componentes React
export function withPerformanceTracking(Component, componentName) {
  return function WrappedComponent(props) {
    const startTime = performance.now();
    
    // Usar um ref para capturar o tempo após a renderização
    const ref = React.useRef(null);
    
    React.useEffect(() => {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      if (duration > PERFORMANCE_THRESHOLDS.RENDER) {
        console.warn(`Query performance warning: ${componentName} took ${duration}ms`);
      }
      
      return () => {
        // Cleanup if needed
      };
    }, [componentName, startTime]);
    
    return <Component ref={ref} {...props} />;
  };
}

// Registrar métricas de performance
function trackPerformance(type, name, duration, args = [], error = null) {
  // Preparar metadados para logging
  const metadata = {
    duration,
    timestamp: new Date().toISOString(),
    args: safeStringify(args)
  };
  
  // Adicionar à coleção de métricas
  if (!performanceMetrics[type]) {
    performanceMetrics[type] = {};
  }
  
  if (!performanceMetrics[type][name]) {
    performanceMetrics[type][name] = {
      count: 0,
      totalDuration: 0,
      min: Infinity,
      max: 0,
      avg: 0,
      recentItems: []
    };
  }
  
  const metrics = performanceMetrics[type][name];
  metrics.count++;
  metrics.totalDuration += duration;
  metrics.min = Math.min(metrics.min, duration);
  metrics.max = Math.max(metrics.max, duration);
  metrics.avg = metrics.totalDuration / metrics.count;
  
  // Manter um histórico das execuções mais recentes
  metrics.recentItems.push(metadata);
  if (metrics.recentItems.length > 10) {
    metrics.recentItems.shift();
  }
  
  // Verificar o limite de performance
  const threshold = PERFORMANCE_THRESHOLDS[type];
  
  if (threshold && duration > threshold) {
    warn(`Performance lenta: ${type} "${name}" levou ${duration.toFixed(2)}ms (limite: ${threshold}ms)`, {
      type,
      name,
      duration,
      threshold,
      args: safeStringify(args)
    });
  }
  
  // Se houver erro, registrá-lo também
  if (error) {
    warn(`Erro em ${type} "${name}" após ${duration.toFixed(2)}ms`, {
      type,
      name,
      duration,
      error: error.message,
      stack: error.stack
    });
  }
  
  return metadata;
}

// Obter relatório de performance
export function getPerformanceReport() {
  return performanceMetrics;
}

// Limpar métricas de performance
export function clearPerformanceMetrics() {
  Object.keys(performanceMetrics).forEach(key => {
    performanceMetrics[key] = {};
  });
}

// Função para serializar args com segurança
function safeStringify(obj) {
  try {
    // Limitar a profundidade e tamanho
    return JSON.stringify(obj, (key, value) => {
      if (typeof value === 'object' && value !== null) {
        // Evitar objetos muito grandes/profundos
        return Object.keys(value).length > 10 ? 
          `[Objeto com ${Object.keys(value).length} propriedades]` : value;
      }
      return value;
    }).substring(0, 500);
  } catch (e) {
    return "[Não serializável]";
  }
}
</file>

<file path="middleware.ts">
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req: request, res })

  // Verificar se o usuário está autenticado
  const { data: { session } } = await supabase.auth.getSession()

  // Lista de rotas públicas
  const publicRoutes = [
    '/auth/login', 
    '/auth/cadastro', 
    '/auth/callback',
    '/test',
    '/test/supabase',
    '/test/auth'
  ]

  // Verificar se a rota atual é pública
  const isPublicRoute = publicRoutes.some(route => request.nextUrl.pathname.startsWith(route))

  // Se não estiver autenticado e tentar acessar uma rota protegida
  if (!session && !isPublicRoute) {
    return NextResponse.redirect(new URL('/auth/login', request.url))
  }

  // Se estiver autenticado e tentar acessar uma rota pública de autenticação
  if (session && isPublicRoute && request.nextUrl.pathname.startsWith('/auth/')) {
    return NextResponse.redirect(new URL('/', request.url))
  }

  return res
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - images (public images)
     */
    '/((?!_next/static|_next/image|favicon.ico|images).*)',
  ],
}
</file>

<file path="app/hooks/useDataSync.ts">
import { useEffect, useState, useRef, useCallback } from 'react'
import { useStore } from '../stores/store'
import { createClient } from '../lib/supabase'
import { BaseItem } from '../types/supabase'

interface SyncConfig<T extends BaseItem> {
  table: string
  localStorageKey: string
  getLocalData: () => T[]
  setLocalData: (data: T[]) => void
  enabled: boolean
  interval: number
}

interface PendingOperation {
  type: 'create' | 'update' | 'delete'
  data: any
  timestamp: number
}

// Hook separado para gerenciar estado online/offline
const useOnlineStatus = () => {
  const [isOnline, setIsOnline] = useState(typeof navigator !== 'undefined' ? navigator.onLine : true)

  useEffect(() => {
    if (typeof window === 'undefined') return

    const handleOnline = () => setIsOnline(true)
    const handleOffline = () => setIsOnline(false)
    
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return isOnline
}

export function useDataSync<T extends BaseItem>(config: SyncConfig<T>) {
  const supabase = createClient()
  const [syncStatus, setSyncStatus] = useState<'idle' | 'syncing' | 'error'>('idle')
  const store = useStore()
  const isOnline = useOnlineStatus()
  const [isSyncing, setIsSyncing] = useState(false)
  const [lastSyncTime, setLastSyncTime] = useState<number | null>(null)
  const lastDataRef = useRef<string>('')
  
  const isMounted = useRef(true)
  const subscriptionRef = useRef<any>(null)
  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  
  const safeSetState = useCallback(<S,>(setter: React.Dispatch<React.SetStateAction<S>>, value: React.SetStateAction<S>) => {
    if (isMounted.current) {
      setter(value)
    }
  }, [])

  // Função para sincronizar dados - movida para o início e memoizada com useCallback
  const synchronize = useCallback(async () => {
    if (!isOnline || isSyncing || !isMounted.current) return
    
    setIsSyncing(true)
    setSyncStatus('syncing')
    
    try {
      const pendingOps = JSON.parse(localStorage.getItem(`${config.localStorageKey}_pending`) || '[]')
      
      for (const op of pendingOps) {
        if (!isMounted.current) break
        
        try {
          switch (op.type) {
            case 'create':
              await supabase.from(config.table).insert(op.data)
              break
            case 'update':
              await supabase.from(config.table).update(op.data).eq('id', op.data.id)
              break
            case 'delete':
              await supabase.from(config.table).delete().eq('id', op.data.id)
              break
          }
        } catch (error) {
          console.error(`Erro ao processar operação ${op.type}:`, error)
        }
      }
      
      if (!isMounted.current) return
      
      const { data, error } = await supabase
        .from(config.table)
        .select('*')
        .order('updated_at', { ascending: false })
        .limit(50)
        
      if (error) throw error
      
      if (isMounted.current) {
        const dataString = JSON.stringify(data)
        if (dataString !== lastDataRef.current) {
          config.setLocalData(data)
          lastDataRef.current = dataString
          localStorage.setItem(`${config.localStorageKey}_pending`, '[]')
          setLastSyncTime(Date.now())
        }
        setSyncStatus('idle')
      }
    } catch (error) {
      console.error('Erro na sincronização:', error)
      if (isMounted.current) {
        setSyncStatus('error')
      }
    } finally {
      if (isMounted.current) {
        setIsSyncing(false)
      }
    }
  }, [isOnline, isSyncing, config, supabase])

  // Carregar dados do localStorage
  useEffect(() => {
    const savedData = localStorage.getItem(config.localStorageKey)
    if (savedData && isMounted.current) {
      const parsedData = JSON.parse(savedData)
      const dataString = JSON.stringify(parsedData)
      if (dataString !== lastDataRef.current) {
        config.setLocalData(parsedData)
        lastDataRef.current = dataString
      }
    }
  }, [config.localStorageKey])
  
  // Salvar dados no localStorage quando mudarem
  useEffect(() => {
    const currentData = config.getLocalData()
    const dataString = JSON.stringify(currentData)
    if (dataString !== lastDataRef.current) {
      localStorage.setItem(config.localStorageKey, dataString)
      lastDataRef.current = dataString
    }
  }, [config.getLocalData, config.localStorageKey])
  
  // Sincronização inicial
  useEffect(() => {
    if (config.enabled && !isSyncing && isOnline) {
      synchronize()
    }
  }, [config.enabled, isSyncing, isOnline, synchronize])

  // Sincronização periódica
  useEffect(() => {
    if (config.enabled && config.interval > 0 && isOnline) {
      syncTimeoutRef.current = setTimeout(synchronize, config.interval)
    }
    
    return () => {
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current)
      }
    }
  }, [config.enabled, config.interval, isOnline, synchronize, lastSyncTime])
  
  // Setup e cleanup do componente
  useEffect(() => {
    isMounted.current = true
    
    if (typeof window === 'undefined') return
    
    const subscription = supabase
      .channel(config.table)
      .on('postgres_changes', { event: '*', schema: 'public', table: config.table }, () => {
        if (isMounted.current && !isSyncing) {
          synchronize()
        }
      })
      .subscribe()
    
    subscriptionRef.current = subscription

    return () => {
      isMounted.current = false
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current)
      }
      if (subscriptionRef.current) {
        subscriptionRef.current.unsubscribe()
        subscriptionRef.current = null
      }
    }
  }, [supabase, config.table, synchronize, isSyncing])

  // Função para adicionar operação pendente
  const addPendingOperation = useCallback((type: 'create' | 'update' | 'delete', data: any) => {
    const pendingOps = JSON.parse(localStorage.getItem(`${config.localStorageKey}_pending`) || '[]')
    pendingOps.push({ type, data, timestamp: Date.now() })
    localStorage.setItem(`${config.localStorageKey}_pending`, JSON.stringify(pendingOps))
  }, [config.localStorageKey])

  return {
    syncStatus,
    isOnline,
    isSyncing,
    lastSyncTime,
    synchronize,
    addPendingOperation
  }
}
</file>

<file path="package.json">
{
  "name": "painel-neurodivergentes",
  "version": "0.1.1",
  "private": true,
  "description": "Painel de assistência para pessoas neurodivergentes com integração do Gemini 2.0-flash",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.0",
    "@headlessui/react": "^1.7.17",
    "@langchain/openai": "^0.4.7",
    "@reduxjs/toolkit": "^2.6.1",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.49.1",
    "@tabler/icons-react": "^3.31.0",
    "@types/uuid": "^10.0.0",
    "@vercel/speed-insights": "^1.2.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.7",
    "jspdf": "^3.0.1",
    "jspdf-autotable": "^5.0.2",
    "langchain": "^0.3.19",
    "lucide-react": "^0.294.0",
    "next": "14.0.4",
    "next-themes": "^0.2.1",
    "pg": "^8.14.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hot-toast": "^2.5.2",
    "react-redux": "^9.2.0",
    "recharts": "^2.15.1",
    "tailwind-merge": "^3.0.2",
    "uuid": "^11.1.0",
    "vercel": "^41.4.1",
    "zustand": "^4.5.6"
  },
  "devDependencies": {
    "@types/node": "^20.10.4",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.17",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-config-next": "14.0.4",
    "postcss": "^8.4.32",
    "prettier": "^3.1.1",
    "tailwindcss": "^3.3.6",
    "typescript": "^5.3.3"
  }
}
</file>

</files>
